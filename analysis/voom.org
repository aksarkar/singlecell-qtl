#+TITLE: voom estimation
#+SETUPFILE: setup.org

* Introduction

  The key idea of [[http://genomebiology.com/2014/15/2/R29][Law et al 2014]] is that the distribution of \(Y =
  \log_2(\mathrm{CPM} + 1)\) is approximately Gaussian. For simplicity,
  consider one gene in one individual.

  \[ R = \mbox{number of reads} \]
  \[ E[R] = \lambda \]
  \[ V[R] = \lambda + \phi \lambda^2 \]
  \[ Y = \log_2(R) + \mathrm{const} \]

  By first order Taylor expansion:

  \[ E[Y] = \mu \approx \log_2 \lambda \]

  By the delta method:

  \[ V[Y] = \sigma^2 \approx V[R] / \lambda^2 = 1/\lambda + \phi \]

  The key issues are:

  1. *This approach does not explicitly account for dropout.* This might be OK,
     because both dropout and dispersion depend on mean expression. However, it
     might be the case that there is an additional dependency between dropout
     and dispersion which this approach would not account for.

  2. *Should we use the sample mean in the dispersion model?* This is simplest
     if we are confident that the sample mean can be reliably estimated from
     the data (this might not be true with dropout).

     In ~voom~, Law et al fit a non-parametric model \(\sqrt\sigma = g(\mu)\)
     because in their application the sample mean could not be reliably
     estimated from the data (too few replicates).

     This is related to issue (3).

  3. *Do we need to worry about mean QTLs in LD with variance QTLs?* We
     previously [[https://github.com/YPARK/fqtl][built multivariate mean/variance QTL models]] which could account
     for LD, and could share information between the mean and variance models.

     The fundamental problem is that if we assume that the mean and dispersion
     both have genetic components, then the mean is no longer independent of
     the dispersion.

     This actually could be derived without using the fact that both depend on
     the same genotypes if we use second-order Taylor expansion:

     \[ \mu \approx \log_2 \lambda + \frac{V[R]}{2 \lambda^2} \]

     Our idea was to build a Bayesian model which simultaneously calls mean and
     variance QTLs based on the likelihood:

     \[ Y \sim N(X\beta, \exp(-X\beta) + X\gamma) \]

     Fitting this model will require writing new software as opposed to
     plugging into ~QTLtools~. 

     One simple approach to get around this would be to fit multivariate mean
     models (using a standard package) and either plug in predicted mean
     expression in place of the empirical mean, or regress out the mean from
     the estimated variance.

* Setup                                                            :noexport:

  #+BEGIN_SRC emacs-lisp
    (org-babel-lob-ingest "/home/aksarkar/projects/singlecell-qtl/analysis/sc-vs-bulk.org")
    (org-babel-lob-ingest "/home/aksarkar/.emacs.d/org-templates/library.org")
  #+END_SRC

  #+RESULTS:
  : 1

  #+CALL: ipython3(memory="16G", venv="scqtl") :dir /scratch/midway2/aksarkar/singlecell

  #+RESULTS:
  : Submitted batch job 40916778

  #+BEGIN_SRC ipython
    import functools
    import os.path
    import numpy as np
    import pandas as pd
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+CALL: concordance-def()

  #+RESULTS:
  :RESULTS:
  :END:

  #+CALL: load-data-defs()

  #+RESULTS:
  :RESULTS:
  :END:

  #+CALL: load-data()

* Mean phenotype definition

  Estimate the mean count per individual, per gene using non-zero counts only,
  then transform to \(log_2(\mathrm{CPM} + 1)\). 

  We still have to deal with the case where a gene is not detected in any cells
  in a particular individual. As a first pass, simply treat their mean
  expression as a true zero.

  #+BEGIN_SRC ipython
    vcf = (pd.read_table('/project2/gilad/singlecell-qtl/bulk/genotypes.vcf.gz', nrows=1)
           .rename(columns=lambda x: 'NA{}'.format(x) if x.startswith('1') else x))
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython
    mean = cpm(umi_qc.mask(umi_qc == 0)
               .groupby(annotations_qc['chip_id'].values, axis=1)
               .agg(np.mean)
               .filter(items=vcf.columns)
               .rename(columns=lambda x: x[2:])  # match original VCF
               .fillna(0),
               log2=True)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

* Variance phenotype definition

