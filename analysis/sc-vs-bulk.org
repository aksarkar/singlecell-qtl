#+TITLE: Single cell/bulk RNA-Seq concordance
#+AUTHOR: Abhishek Sarkar
#+EMAIL: aksarkar@uchicago.edu
#+OPTIONS: num:nil
#+SETUPFILE: ~/.emacs.d/org-templates/setup.org
#+PROPERTY: header-args:ipython+ :session kernel-aksarkar.json :results raw drawer :eval never-export :exports both :async t

* Setup

  #+NAME: ipython3
  #+BEGIN_SRC shell :dir (concat (file-name-as-directory (getenv "SCRATCH")) "singlecell") :var RESOURCES="--mem=16G --time 6:00:00 --partition=broadwl"
    sbatch $RESOURCES --job-name=ipython3 --output=ipython3.out
    #!/bin/bash
    source activate scqtl
    rm -f $HOME/.local/share/jupyter/runtime/kernel-aksarkar.json
    ipython3 kernel --ip=$(hostname -i) -f kernel-aksarkar.json
  #+END_SRC

  #+RESULTS: ipython3
  : Submitted batch job 40040751

  #+NAME: imports
  #+BEGIN_SRC ipython
    %matplotlib inline

    import io
    import matplotlib.pyplot as plt
    import numpy as np
    import pandas as pd
    import requests
    import scipy.stats as sst
  #+END_SRC

  #+RESULTS: imports
  :RESULTS:
  :END:

* Read the data

  #+BEGIN_SRC ipython
    def load_umi_data(min_cell_count=5):
      annotations = pd.read_table('/home/aksarkar/projects/singlecell-qtl/data/scqtl-annotation.txt')
      counts = pd.read_table('/home/aksarkar/projects/singlecell-qtl/data/scqtl-counts.txt.gz', index_col=0)
      keep_individuals = annotations['chip_id'].value_counts() > min_cell_count
      keep_cells = annotations.apply(lambda x: keep_individuals.loc[x['chip_id']], axis=1)
      annotations = annotations.loc[keep_cells.values]
      counts = counts.loc[:,keep_cells.values]
      return counts, annotations, keep_individuals

    def load_bulk_data(keep_individuals):
      counts = pd.read_table('/project2/gilad/data/iPSC/counts_RNAseq_iPSC.txt', header=0, index_col=0, sep=' ')
      counts.index = [k.split('.')[0] for k in counts.index]
      counts.columns = ['NA{}'.format(k) for k in counts.columns]
      counts = counts.filter(items=keep_individuals[keep_individuals].index)
      return counts
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython
    umi, annotations, keep_individuals = load_umi_data()
    bulk = load_bulk_data(keep_individuals)

    umi.shape, bulk.shape
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  : ((20327, 2261), (14034, 20))
  :END:

* Compute TPM

  #+BEGIN_SRC ipython
    def biomart(query):
      resp = requests.get('http://www.ensembl.org/biomart/martservice', params={'query': query.strip()})
      if resp.status_code != 200:
        raise RuntimeError
      with io.StringIO(resp.text) as f:
        return pd.read_table(f, header=None, index_col=0)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+NAME: query
  #+BEGIN_SRC xml :exports code
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE Query>
    <Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" >
      <Dataset name = "hsapiens_gene_ensembl" interface = "default" >
        <Attribute name = "ensembl_gene_id" />
        <Attribute name = "exon_chrom_start" />
        <Attribute name = "exon_chrom_end" />
      </Dataset>
    </Query>
  #+END_SRC
  
  #+BEGIN_SRC ipython :noweb no-export
    ensembl = biomart("""
      <<query>>
    """)
  #+END_SRC

  #+BEGIN_SRC ipython
    total_exon_length_kb = ensembl.groupby(level=0).apply(lambda x: (x[3] - x[2]).agg(np.sum) / 1e3)
    total_exon_length_kb.head()
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  #+BEGIN_EXAMPLE
  0
    ENSG00000000003     8.713
    ENSG00000000005     1.871
    ENSG00000000419     5.814
    ENSG00000000457    15.922
    ENSG00000000460    21.720
    dtype: float64
  #+END_EXAMPLE
  :END:

  #+BEGIN_SRC ipython
    def cpm(counts):
      return counts / counts.sum(axis=0) * 1e6

    def tpm(counts, lengths, log2=False):
      rpk = counts.add(1).rtruediv(lengths.loc[counts.index], axis='index')
      tpm = cpm(rpk)
      if log2:
        tpm = np.log(tpm) / np.log(2)
      return tpm
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython
    bulk_tpm = tpm(bulk, total_exon_length_kb, log2=True)
    pooled_tpm = tpm(umi.groupby(by=annotations['chip_id'].values, axis=1).agg(np.sum),
                     total_exon_length_kb, log2=True)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

* Plot bulk vs. pooled single cells

  #+BEGIN_SRC ipython
    def plot_concordance(merged, title, filename, ylabel=None):
      lim = [merged.min().min(), merged.max().max()]
      plt.clf()
      plt.scatter(merged['x'], merged['y'], alpha=0.25, color='black')
      plt.plot(lim, lim, color='red')
      ax = plt.gca()
      ax.set_xlim([merged['x'].min(), merged['x'].max()])
      ax.set_ylim([merged['y'].min(), merged['y'].max()])
      plt.title(title)
      plt.xlabel('scRNA-Seq $\log_2(\mathrm{TPM})$')
      if ylabel is None:
        ylabel = 'Bulk RNA-Seq $\log_2(\mathrm{TPM})$'
      plt.ylabel(ylabel)
      plt.savefig(filename)

    def plot_concordance_by_individual(umi, bulk, output_dir):
      for k, y in bulk.groupby(level=0, axis=1):
        merged = pd.DataFrame(umi.loc[:,k]).merge(y, left_index=True, right_index=True)
        merged.columns = ['x', 'y']
        plot_concordance(merged, k, '{}/{}.png'.format(output_dir, k))
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython :exports code :results none
    plot_concordance_by_individual(
      pooled_tpm,
      bulk_tpm,
      '/home/aksarkar/projects/singlecell-qtl/analysis/figure/sc-vs-bulk.org/normed')
  #+END_SRC

  file:figure/sc-vs-bulk.org/normed/NA18498.png
  file:figure/sc-vs-bulk.org/normed/NA18499.png
  file:figure/sc-vs-bulk.org/normed/NA18501.png
  file:figure/sc-vs-bulk.org/normed/NA18502.png
  file:figure/sc-vs-bulk.org/normed/NA18505.png
  file:figure/sc-vs-bulk.org/normed/NA18507.png
  file:figure/sc-vs-bulk.org/normed/NA18508.png
  file:figure/sc-vs-bulk.org/normed/NA18520.png
  file:figure/sc-vs-bulk.org/normed/NA18852.png
  file:figure/sc-vs-bulk.org/normed/NA18853.png
  file:figure/sc-vs-bulk.org/normed/NA18856.png
  file:figure/sc-vs-bulk.org/normed/NA18862.png
  file:figure/sc-vs-bulk.org/normed/NA18870.png
  file:figure/sc-vs-bulk.org/normed/NA19098.png
  file:figure/sc-vs-bulk.org/normed/NA19119.png
  file:figure/sc-vs-bulk.org/normed/NA19128.png
  file:figure/sc-vs-bulk.org/normed/NA19159.png
  file:figure/sc-vs-bulk.org/normed/NA19190.png
  file:figure/sc-vs-bulk.org/normed/NA19210.png
  file:figure/sc-vs-bulk.org/normed/NA19257.png

* Plot bulk vs. pooled subsets

  #+BEGIN_SRC ipython
    def plot_concordance_by_num_cells(individual, umi, annotations, lengths, bulk_tpm, output_dir):
      bulk_tpm = bulk_tpm.loc[:,individual].to_frame()
      umi = umi.loc[:,(annotations['chip_id'] == individual).values]
      for num_cells in [1, 10, 50, 100, 200]:
        pooled_tpm = tpm(umi.sample(n=num_cells, axis=1).sum(axis=1).to_frame(), lengths, log2=True)
        merged = pooled_tpm.merge(bulk_tpm, left_index=True, right_index=True)
        merged.columns = ['x', 'y']
        plot_concordance(
          merged,
          '{}, {} cell{}'.format(individual, num_cells, 's' if num_cells > 1 else ''),
          '{}/{}-{}.png'.format(output_dir, individual, num_cells))
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython :results none
    plot_concordance_by_num_cells(
      'NA18507',
      umi,
      annotations,
      total_exon_length_kb,
      bulk_tpm,
      '/home/aksarkar/projects/singlecell-qtl/analysis/figure/sc-vs-bulk.org/vs-cells/'
    )
  #+END_SRC

  file:figure/sc-vs-bulk.org/vs-cells/NA18507-1.png
  file:figure/sc-vs-bulk.org/vs-cells/NA18507-10.png
  file:figure/sc-vs-bulk.org/vs-cells/NA18507-50.png
  file:figure/sc-vs-bulk.org/vs-cells/NA18507-100.png
  file:figure/sc-vs-bulk.org/vs-cells/NA18507-200.png

* Plot pooled subsets vs. pooled subsets

  Ensure that pools don't overlap by randomly sampling double the cells and
  partitioning into two halves.

  #+BEGIN_SRC ipython
    def plot_concordance_pooled_subsets(individual, umi, annotations, lengths, output_dir):
      umi = umi.loc[:,(annotations['chip_id'] == individual).values]
      for num_cells in [1, 10, 50, 100]:
        sample = umi.sample(n=2 * num_cells, axis=1)
        pool1 = tpm(sample.iloc[:,:num_cells].sum(axis=1).to_frame(), lengths, log2=True)
        pool2 = tpm(sample.iloc[:,num_cells:].sum(axis=1).to_frame(), lengths, log2=True)
        merged = pool1.merge(pool2, left_index=True, right_index=True)
        merged.columns = ['x', 'y']
        plot_concordance(
          merged,
          '{}, {} cell{}'.format(individual, num_cells, 's' if num_cells > 1 else ''),
          '{}/{}-{}.png'.format(output_dir, individual, num_cells),
          'scRNA-Seq $\log_2(\mathrm{TPM})$')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython :results none
    plot_concordance_pooled_subsets(
      'NA18507',
      umi,
      annotations,
      total_exon_length_kb,
      '/home/aksarkar/projects/singlecell-qtl/analysis/figure/sc-vs-bulk.org/subsets/'
    )
  #+END_SRC

  file:figure/sc-vs-bulk.org/subsets/NA18507-1.png
  file:figure/sc-vs-bulk.org/subsets/NA18507-10.png
  file:figure/sc-vs-bulk.org/subsets/NA18507-50.png
  file:figure/sc-vs-bulk.org/subsets/NA18507-100.png
