#+TITLE: Single cell/bulk RNA-Seq concordance
#+AUTHOR: Abhishek Sarkar
#+EMAIL: aksarkar@uchicago.edu
#+OPTIONS: num:nil
#+SETUPFILE: ~/.emacs.d/org-templates/setup.org
#+PROPERTY: header-args:ipython+ :session kernel-aksarkar.json :results raw drawer :eval never-export :exports both :async t

* Setup

  #+NAME: ipython3
  #+BEGIN_SRC shell :dir (concat (file-name-as-directory (getenv "SCRATCH")) "singlecell") :var RESOURCES="--mem=16G --time 6:00:00 --partition=broadwl"
    sbatch $RESOURCES --job-name=ipython3 --output=ipython3.out
    #!/bin/bash
    source activate scqtl
    rm -f $HOME/.local/share/jupyter/runtime/kernel-aksarkar.json
    ipython3 kernel --ip=$(hostname -i) -f kernel-aksarkar.json
  #+END_SRC

  #+RESULTS: ipython3
  : Submitted batch job 40040751

  #+NAME: imports
  #+BEGIN_SRC ipython
    %matplotlib inline

    import io
    import matplotlib.pyplot as plt
    import numpy as np
    import pandas as pd
    import requests
    import scipy.stats as sst
  #+END_SRC

  #+RESULTS: imports
  :RESULTS:
  :END:

* Read the data

  #+BEGIN_SRC ipython
    def load_umi_data(min_cell_count=5):
      annotations = pd.read_table('/home/aksarkar/projects/singlecell-qtl/data/scqtl-annotation.txt')
      counts = pd.read_table('/home/aksarkar/projects/singlecell-qtl/data/scqtl-counts.txt.gz', index_col=0)
      keep_individuals = annotations['chip_id'].value_counts() > min_cell_count
      keep_cells = annotations.apply(lambda x: keep_individuals.loc[x['chip_id']], axis=1)
      annotations = annotations.loc[keep_cells.values]
      counts = counts.loc[:,keep_cells.values]
      return counts, annotations, keep_individuals

    def load_bulk_data(keep_individuals):
      counts = pd.read_table('/project2/gilad/data/iPSC/counts_RNAseq_iPSC.txt', header=0, index_col=0, sep=' ')
      counts.index = [k.split('.')[0] for k in counts.index]
      counts.columns = ['NA{}'.format(k) for k in counts.columns]
      counts = counts.filter(items=keep_individuals[keep_individuals].index)
      return counts
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython
    umi, annotations, keep_individuals = load_umi_data()
    bulk = load_bulk_data(keep_individuals)

    umi.shape, bulk.shape
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  : ((20327, 2261), (14034, 20))
  :END:

* Compute TPM

  #+BEGIN_SRC ipython
    def get_gene_lengths():
      query = """<?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE Query>
    <Query  virtualSchemaName = "default" formatter = "TSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" >
    <Dataset name = "hsapiens_gene_ensembl" interface = "default" >
      <Attribute name = "ensembl_gene_id" />
      <Attribute name = "start_position" />
      <Attribute name = "end_position" />
    </Dataset>
    </Query>"""
      resp = requests.get('http://www.ensembl.org/biomart/martservice', params={'query': query})
      if resp.status_code != 200:
        raise RuntimeError
      with io.StringIO(resp.text) as f:
        return pd.read_table(f, header=None, index_col=0).rename(columns={1: 'start', 2: 'end'})
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython
    ensembl = get_gene_lengths()
    ensembl.head()
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  #+BEGIN_EXAMPLE
                      start       end
    0                                  
    ENSG00000283891  55372940  55373034
    ENSG00000251931  59450673  59450772
    ENSG00000207766  41691585  41691678
    ENSG00000275323  54201473  54208260
    ENSG00000276678  10287413  10287482
  #+END_EXAMPLE
  :END:

  #+BEGIN_SRC ipython
    def cpm(counts):
      return counts / counts.sum(axis=0) * 1e6

    def tpm(counts, ensembl, log2=False):
      rpk = counts.add(1).rtruediv(ensembl.loc[counts.index].apply(lambda x: (x['end'] - x['start']) / 1e3, axis=1), axis='index')
      tpm = cpm(rpk)
      if log2:
        tpm = np.log(tpm) / np.log(2)
      return tpm
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython
    bulk_tpm = tpm(bulk, ensembl, log2=True)
    pooled_tpm = tpm(umi.groupby(by=annotations['chip_id'].values, axis=1).agg(np.sum), ensembl, log2=True)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

* Plot bulk vs. pooled single cells

  #+BEGIN_SRC ipython
    def plot_concordance(merged, title, filename):
      lim = [merged.min().min(), merged.max().max()]
      plt.clf()
      plt.scatter(merged['x'], merged['y'], alpha=0.25, color='black')
      plt.plot(lim, lim, color='red')
      ax = plt.gca()
      ax.set_xlim([merged['x'].min(), merged['x'].max()])
      ax.set_ylim([merged['y'].min(), merged['y'].max()])
      plt.title(title)
      plt.xlabel('scRNA-Seq $\log_2(\mathrm{TPM})$')
      plt.ylabel('Bulk RNA-Seq $\log_2(\mathrm{TPM})$')
      plt.savefig(filename)

    def plot_concordance_by_individual(umi, bulk, output_dir):
      for k, y in bulk.groupby(level=0, axis=1):
        merged = pd.DataFrame(umi.loc[:,k]).merge(y, left_index=True, right_index=True)
        merged.columns = ['x', 'y']
        plot_concordance(merged, k, '{}/{}.png'.format(output_dir, k))
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython :exports code :results none
    plot_concordance_by_individual(
      pooled_tpm,
      bulk_tpm
      '/home/aksarkar/projects/singlecell-qtl/analysis/figure/sc-vs-bulk.org/normed')
  #+END_SRC

  file:figure/sc-vs-bulk.org/normed/NA18498.png
  file:figure/sc-vs-bulk.org/normed/NA18499.png
  file:figure/sc-vs-bulk.org/normed/NA18501.png
  file:figure/sc-vs-bulk.org/normed/NA18502.png
  file:figure/sc-vs-bulk.org/normed/NA18505.png
  file:figure/sc-vs-bulk.org/normed/NA18507.png
  file:figure/sc-vs-bulk.org/normed/NA18508.png
  file:figure/sc-vs-bulk.org/normed/NA18520.png
  file:figure/sc-vs-bulk.org/normed/NA18852.png
  file:figure/sc-vs-bulk.org/normed/NA18853.png
  file:figure/sc-vs-bulk.org/normed/NA18856.png
  file:figure/sc-vs-bulk.org/normed/NA18862.png
  file:figure/sc-vs-bulk.org/normed/NA18870.png
  file:figure/sc-vs-bulk.org/normed/NA19098.png
  file:figure/sc-vs-bulk.org/normed/NA19119.png
  file:figure/sc-vs-bulk.org/normed/NA19128.png
  file:figure/sc-vs-bulk.org/normed/NA19159.png
  file:figure/sc-vs-bulk.org/normed/NA19190.png
  file:figure/sc-vs-bulk.org/normed/NA19210.png
  file:figure/sc-vs-bulk.org/normed/NA19257.png

* Plot bulk vs. pooled subsets

  #+BEGIN_SRC ipython
    def plot_concordance_by_num_cells(individual, umi, annotations, ensembl, bulk_tpm, output_dir):
      bulk_tpm = bulk_tpm.loc[:,individual].to_frame()
      umi = umi.loc[:,(annotations['chip_id'] == individual).values]
      for num_cells in np.concatenate((np.arange(1, 20), np.arange(25, umi.shape[1], 25))):
        pooled_tpm = tpm(umi.sample(n=num_cells, axis=1).sum(axis=1).to_frame(), ensembl, log2=True)
        merged = pooled_tpm.merge(bulk_tpm, left_index=True, right_index=True)
        merged.columns = ['x', 'y']
        plot_concordance(
          merged,
          '{}, {} cells'.format(individual, num_cells),
          '{}/{}-{}.png'.format(output_dir, individual, num_cells))
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython
    plot_concordance_by_num_cells(
      'NA18507',
      umi,
      annotations,
      ensembl,
      bulk_tpm,
      '/home/aksarkar/projects/singlecell-qtl/analysis/figure/sc-vs-bulk.org/vs-cells/'
    )
  #+END_SRC

  
  file:figure/sc-vs-bulk.org/vs-cells/NA18507-1.png
  file:figure/sc-vs-bulk.org/vs-cells/NA18507-10.png
  file:figure/sc-vs-bulk.org/vs-cells/NA18507-50.png
  file:figure/sc-vs-bulk.org/vs-cells/NA18507-100.png
  file:figure/sc-vs-bulk.org/vs-cells/NA18507-200.png

