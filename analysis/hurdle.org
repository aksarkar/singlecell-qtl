#+TITLE: Hurdle model estimation
#+SETUPFILE: setup.org

* Introduction

  The key idea of ~voom~ ([[http://genomebiology.com/2014/15/2/R29][Law et al 2014]]) is that the distribution of \(Y =
  \log_2(\mathrm{CPM} + 1)\) is approximately Gaussian. For simplicity,
  consider one gene in one cell.

  \[ R = \mbox{number of reads} \]

  Assuming \(R\) follows the NB2 negative binomial model (Hilbe 2012):

  \[ E[R] = \lambda \]
  \[ V[R] = \lambda + \phi \lambda^2 \]

  By the definition of CPM:

  \[ Y = \log_2(R) + \mathrm{const} \]

  By first order Taylor expansion:

  \[ E[Y] = \mu \approx \log_2 \lambda + \mathrm{const} \]

  By the delta method:

  \[ V[Y] = \sigma^2 \approx V[R] / \lambda^2 = 1/\lambda + \phi \]

  The key idea of ~mast~ ([[https://dx.doi.org/10.1186/s13059-015-0844-5][Finak et al 2015]]) is to model non-zero \(R\) using a
  Gaussian distribution, and model zero \(R\) using logistic regression. The
  key distinction between this approach and the [[file:zinb.org][zero-inflated
  negative binomial model]] is that zeroes are assumed to arise from only one
  process.

  This naturally suggests a Bayesian model which simultaneously calls mean and
  variance QTLs based on the likelihood:

  \[ Y \mid Y = 0 \sim \mathrm{Bernoulli}(1 - \mathrm{sigmoid}(AX\theta_m + \delta)) \]

  \[ Y \mid Y > 0 \sim N(AX\theta_m + \delta, \exp(-AX\theta_m - \delta) +
  \exp(AX\theta_v) + \sigma^2) \]

  where \(\delta\) is a known constant that depends on library size, \(A\) maps
  from cells to individuals, and \(X\) is the genotype matrix.

  The key issues are:

  1. *Is it possible to develop an individual-level model?* An alternative
     model would be to estimate a variance for each individual, and then plug
     into existing QTL mapping software. This approach is naturally suggested
     by the ~voom~ approximation, but it is not obvious that the approach will
     generalize to zero-inflated data.

     Fitting the proposed model will require writing new software as opposed to
     plugging into existing software. We previously built an efficient
     algorithm and inference engine to build these kind of models ([[https://www.biorxiv.org/content/early/2017/02/10/107623][Park et al
     2017]]), but it has one major issue: it is computationally expensive to
     perform statistical tests on the fitted models because the approximate
     Bayesian inferences underestimate the uncertainty in the estimated values.

  2. *Do we need to actually fit the dropout model?* ~mast~ conditions on the
     observed \(Y = 0\), not on a latent \(Z = 0\), which means we could simply
     do the same and ignore zeros.

     If we did so, then mean/variance QTL effect size estimation will be less
     robust for genes with high dropout. This might not be a problem depending
     on the stringency of gene filtering.

  3. *For a single gene, do we need to worry about mean QTLs in LD with
     variance QTLs?* We previously [[https://github.com/YPARK/fqtl][built multivariate mean/variance QTL models]]
     which could account for LD, and could share information between the mean
     and variance models.

     The fundamental problem is that if we assume that the mean and dispersion
     both have genetic components, then the mean is no longer independent of
     the dispersion.

     This actually could be derived without using the fact that both depend on
     the same genotypes if we use second-order Taylor expansion:

     \[ \mu \approx \log_2 \lambda + \frac{V[R]}{2 \lambda^2} \]

  4. *Do we need to share parameters between genes?* ~mast~ assumes genes are
     conditionally independent. But this is no longer true when nearby genes
     can be driven by overlapping (or correlated) /cis/-genotypes.

     We previously developed multiresponse QTL models which learned the target
     genes of causal variants, allowing the true target gene to explain away
     nearby correlated genes ([[https://www.biorxiv.org/content/early/2017/11/14/219428][Park et al 2017]]).

* Setup                                                            :noexport:

  #+BEGIN_SRC emacs-lisp
    (org-babel-lob-ingest "/home/aksarkar/projects/singlecell-qtl/analysis/sc-vs-bulk.org")
    (org-babel-lob-ingest "/home/aksarkar/projects/singlecell-qtl/analysis/qtl-mapping.org")
    (org-babel-lob-ingest "/home/aksarkar/.emacs.d/org-templates/library.org")
  #+END_SRC

  #+RESULTS:
  : 1

  #+CALL: ipython3(venv="scqtl") :dir /scratch/midway2/aksarkar/singlecell

  #+RESULTS:
  : Submitted batch job 41436690

  #+BEGIN_SRC ipython
    import edward as ed
    import functools
    import gzip
    import os.path
    import matplotlib.pyplot as plt
    import numpy as np
    import pandas as pd
    import pickle
    import tabix
    import tensorflow as tf
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+CALL: concordance-def()

  #+RESULTS:
  :RESULTS:
  :END:

  #+CALL: load-data-defs()

  #+RESULTS:
  :RESULTS:
  :END:

  #+CALL: load-data()

  #+RESULTS:
  :RESULTS:
  : ((20327, 2261), (34608, 15))
  :END:

  #+CALL: umi-qc()

  #+RESULTS:
  :RESULTS:
  : (15636, 1810)
  :END:

  #+CALL: onehot-qc()

  #+RESULTS:
  :RESULTS:
  :END:

  #+NAME: reset
  #+BEGIN_SRC ipython
    tf.reset_default_graph()
    ed.get_session().close()
  #+END_SRC

  #+RESULTS: reset
  :RESULTS:
  :END:

* Test case

  #+CALL: get-gene-info() :exports both

  #+RESULTS:
  :RESULTS:
  #+BEGIN_EXAMPLE
                    chr      start        end      name strand      source
    gene                                                                    
    ENSG00000000419  hs20   49551404   49575092      DPM1      -  H. sapiens
    ENSG00000000457   hs1  169818772  169863408     SCYL3      -  H. sapiens
    ENSG00000000460   hs1  169631245  169823221  C1orf112      +  H. sapiens
    ENSG00000000938   hs1   27938575   27961788       FGR      -  H. sapiens
    ENSG00000000971   hs1  196621008  196716634       CFH      +  H. sapiens
  #+END_EXAMPLE
  :END:

  #+BEGIN_SRC ipython
    gene_info.query('name == "ZSWIM7"')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  #+BEGIN_EXAMPLE
                    chr     start       end    name strand      source
    gene                                                                
    ENSG00000214941  hs17  15879874  15903031  ZSWIM7      -  H. sapiens
  #+END_EXAMPLE
  :END:

  #+BEGIN_SRC ipython
    with gzip.open('/project2/gilad/singlecell-qtl/bulk/genotypes.vcf.gz', 'rt') as f:
      header = next(f).split()
    vcf = tabix.open('/project2/gilad/singlecell-qtl/bulk/genotypes.vcf.gz')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython
    def _extract_genotypes(row, vcf, header, window):
      if row['strand'] == '+':
        start = row['start'] - window
        end = row['start']
      else:
        start = row['end']
        end = row['end'] + window
      result = pd.DataFrame(list(vcf.query('chr{}'.format(row['chr'][2:]), start, end)), columns=header).iloc[:,9:].astype(np.float32)
      return result
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython
    genotypes = _extract_genotypes(gene_info.loc['ENSG00000214941'], vcf=vcf, header=header, window=int(1e6)).rename(columns=lambda x: 'NA{}'.format(x))[sorted(annotations_qc['chip_id'].unique())]
    genotypes = genotypes.T.transform(lambda x: x - x.mean()).fillna(0)
    genotypes.shape
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  : (21, 2506)
  :END:

  #+BEGIN_SRC ipython
    data = {'onehot': onehot,
            'genotypes': genotypes.values,
            'counts': umi_qc.loc['ENSG00000214941'].values.astype(np.float32).reshape(-1, 1),
            'normalizers': -np.log(umi_qc.agg(np.sum)).values.reshape(-1, 1)}
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython
    with open('test_data.pkl', 'wb') as f:
      pickle.dump(data, f)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

* Edward sanity check                                              :noexport:

  #+CALL: reset()

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython
    m, _ = data['onehot'].shape
    n, p = data['genotypes'].shape

    x = tf.placeholder(tf.float32, [n, p])
    a = tf.placeholder(tf.float32, [m, n])
    beta = ed.models.Normal(loc=tf.zeros([p, 1]), scale=tf.ones([1]))
    y = ed.models.Normal(loc=tf.matmul(a, tf.matmul(x, beta)), scale=1.)

    q_beta = ed.models.NormalWithSoftplusScale(loc=tf.Variable(tf.zeros([p, 1])), scale=tf.Variable(tf.ones([1])))

    inf = ed.ReparameterizationKLqp(
      latent_vars={beta: q_beta},
      data={y: np.random.normal(size=(m, 1)).astype(np.float32),
            x: data['genotypes'],
            a: data['onehot']})
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython 
    inf.run(optimizer=tf.train.GradientDescentOptimizer(learning_rate=1e-6))
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  : 1000/1000 [100%] ██████████████████████████████ Elapsed: 1s | Loss: 11070.640
  :END:

* ML sanity check
  
  #+BEGIN_SRC ipython
    with open('test_data.pkl', 'rb') as f:
      data = pickle.load(f)

    data['log_cpm'] = np.log(data['counts'] + 1) + data['normalizers'] + 6 * np.log(10)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+CALL: reset()

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython
    with tf.Graph().as_default():
      m, n = data['onehot'].shape

      onehot = tf.placeholder(tf.float32, [m, n])
      genotypes = tf.placeholder(tf.float32, [n, 1])
      log_cpm = tf.placeholder(tf.float32, [m, 1])
      library_size = tf.placeholder(tf.float32, [m, 1])

      with tf.variable_scope('params', initializer=tf.zeros_initializer):
        mean_effect = tf.get_variable('mean', [1, 1])
        log_rate = tf.matmul(genotypes, mean_effect)
        cell_bias = library_size + 6 * tf.log(10.)
        mean = tf.matmul(onehot, log_rate) + cell_bias

        disp_effect = tf.get_variable('disp', [1, 1])
        disp = tf.matmul(genotypes, disp_effect)
        resid = tf.get_variable('resid', [1, 1])
        var = tf.exp(-mean) + tf.matmul(onehot, tf.exp(disp)) + tf.exp(resid)

      llik = .5 * tf.reduce_sum(-tf.log(var) - tf.log(tf.constant(2 * np.pi)) - tf.square(log_cpm - mean) / var) 

      opt = [mean_effect, disp_effect, tf.exp(resid)]

      train = tf.train.RMSPropOptimizer(learning_rate=1e-2).minimize(-llik)

      feed_dict = {genotypes: data['genotypes'][:,0:1],
                   onehot: data['onehot'],
                   library_size: data['normalizers'],
                   log_cpm: data['log_cpm']}

      with tf.Session() as sess:
        sess.run(tf.global_variables_initializer())
        curr_llik = float('-inf')
        for i in range(3000):
          _, update = sess.run([train, llik], feed_dict)
          if np.isclose(update, curr_llik):
            print('Converged after {} epochs'.format(i))
            break
          else:
            curr_llik = update
        estimates = sess.run(opt)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython
    curr_llik
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  : -3191.2041
  :END:

  #+BEGIN_SRC ipython
    pd.DataFrame(np.hstack(estimates), columns=['mean_effect', 'disp_effect', 'resid'])
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  #+BEGIN_EXAMPLE
     mean_effect  disp_effect    resid
    0     0.413716    -1.031514  0.87242
  #+END_EXAMPLE
  :END:

* Voom component

  #+CALL: reset()

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython
    with open('test_data.pkl', 'rb') as f:
      data = pickle.load(f)

    data['log_cpm'] = np.log(data['counts'] + 1) + data['normalizers'] + 6 * np.log(10)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython
    m, n = data['onehot'].shape
    _, p = data['genotypes'].shape

    onehot = tf.placeholder(tf.float32, [m, n])
    genotypes = tf.placeholder(tf.float32, [n, 1])
    library_size = tf.placeholder(tf.float32, [m, 1])

    ind_bias = ed.models.Normal(loc=tf.zeros([n, 1]), scale=tf.Variable(tf.ones([n, 1])))
    cell_bias = library_size + 6 * tf.log(10.)
    rate_effect = ed.models.Normal(loc=tf.zeros([1, 1]), scale=tf.ones([1, 1]))
    log_rate = tf.matmul(onehot, tf.matmul(genotypes, rate_effect) + ind_bias)
    mean = log_rate + cell_bias

    disp_effect = ed.models.Normal(loc=tf.zeros([1, 1]), scale=tf.ones([1, 1]))
    disp = tf.matmul(onehot, tf.matmul(genotypes, disp_effect))
    var = tf.exp(-log_rate) + tf.exp(disp) + tf.exp(tf.Variable(tf.zeros([1])))

    log_cpm = ed.models.Normal(loc=mean, scale=tf.sqrt(var))

    q_ind_bias = ed.models.Normal(loc=tf.Variable(tf.zeros([n, 1])), scale=tf.Variable(tf.ones([n, 1])))
    q_rate_effect = ed.models.Normal(loc=tf.Variable(tf.random_normal([1, 1])), scale=tf.Variable(tf.random_normal([1, 1])))
    q_disp_effect = ed.models.Normal(loc=tf.Variable(tf.zeros([1, 1])), scale=tf.Variable(tf.ones([1, 1])))

    inf = ed.ReparameterizationKLKLqp(
      latent_vars={
        rate_effect: q_rate_effect,
        ind_bias: q_ind_bias,
        disp_effect: q_disp_effect,
      },
      data={
        onehot: data['onehot'],
        genotypes: data['genotypes'][:,0:1],
        library_size: -data['normalizers'],
        log_cpm: data['log_cpm'],
      })
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython
    inf.run(n_samples=10, optimizer=tf.train.AdamOptimizer(learning_rate=5e-2))
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython
    res = pd.DataFrame(
      np.hstack(ed.get_session().run([q_rate_effect.mean(), q_rate_effect.variance(), q_disp_effect.mean(), q_disp_effect.variance()])),
      columns=['rate_effect_mean', 'rate_effect_var', 'disp_effect_mean', 'disp_effect_var'])
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:

  #+BEGIN_SRC ipython
    res
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  #+BEGIN_EXAMPLE
     rate_effect_mean  rate_effect_var  disp_effect_mean  disp_effect_var
    0         -0.373444         0.003591         -2.677538         6.434384
  #+END_EXAMPLE
  :END:
