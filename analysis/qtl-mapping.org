#+TITLE: QTL mapping pipeline
#+SETUPFILE: setup.org

* Introduction

  We take a modular approach to call QTLs:

  1. Estimate a mean and a dispersion for each individual
  2. Treat the mean/dispersion as continuous phenotypes and perform QTL mapping

  Here, we solve (2).

  1. [[*Reproduce bulk eQTL calls][We reproduce eQTLs]] called on the bulk RNA-Seq
  2. [[*Analysis using ZINB][We call mean/variance/CV/Fano QTLs]] using ZINB parameters
  3. [[*QTL overlap][We test replication/overlap]] between different QTL calls

* Setup                                                            :noexport:

  #+BEGIN_SRC emacs-lisp
    (org-babel-lob-ingest "/home/aksarkar/.emacs.d/org-templates/library.org")
  #+END_SRC

  #+RESULTS:
  : 1

  #+CALL: ipython3(memory="16G", venv="scqtl") :dir /scratch/midway2/aksarkar/singlecell

  #+RESULTS:
  : Submitted batch job 48837506

  #+BEGIN_SRC ipython
    %matplotlib inline
    %config InlineBackend.figure_formats = set(['retina'])

    import colorcet
    import gzip
    import matplotlib.pyplot as plt
    import numpy as np
    import os.path
    import pandas as pd
    import pathlib
    import pickle
    import rpy2.robjects.packages
    import rpy2.robjects.pandas2ri
    import rpy2.robjects.numpy2ri
    import scipy.special as sp
    import scipy.stats as st
    import sklearn.decomposition as skd
    import sklearn.metrics
    import sqlite3
    import tabix

    ashr = rpy2.robjects.packages.importr('ashr')
    edger = rpy2.robjects.packages.importr('edgeR')
    mashr = rpy2.robjects.packages.importr('mashr')

    pandas2ri = rpy2.robjects.pandas2ri
    numpy2ri = rpy2.robjects.numpy2ri.numpy2ri
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[1]:
  :END:

* Implementation

  #+NAME: r-wrappers
  #+BEGIN_SRC ipython
    def cpm(x):
      return pd.DataFrame(pandas2ri.ri2py(edger.cpm(numpy2ri(x.values), log=True)),
                          columns=x.columns,
                          index=x.index)

    def qqnorm(x):
      """Wrap around R qqnorm"""
      return np.asarray(rpy2.robjects.r['qqnorm'](numpy2ri(x))[0])

    def bh(x):
      """Wrap around p.adjust(..., method='fdr')"""
      return np.asarray(rpy2.robjects.r['p.adjust'](numpy2ri(x), method='fdr'))
  #+END_SRC

  #+RESULTS: r-wrappers
  :RESULTS:
  # Out[2]:
  :END:

  #+NAME: get-gene-info
  #+BEGIN_SRC ipython
    gene_info = (pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-genes.txt.gz')
                 .set_index('gene')
                 .query('source == "H. sapiens"')
                 .query('chr != "hsX"')
                 .query('chr != "hsY"')
                 .query('chr != "hsMT"'))
  #+END_SRC

  #+RESULTS: get-gene-info
  :RESULTS:
  # Out[3]:
  :END:

  #+NAME: write-gene-info
  #+BEGIN_SRC ipython
    with sqlite3.connect('/project2/mstephens/aksarkar/projects/singlecell-qtl/browser/browser.db') as conn:
      gene_info.to_sql('gene_info', conn, index=True, if_exists='replace')
  #+END_SRC

  #+RESULTS: write-gene-info
  :RESULTS:
  # Out[4]:
  :END:

  #+RESULTS:
  :RESULTS:
  # Out[45]:
  :END:

  #+NAME: write-pheno-def
  #+BEGIN_SRC ipython
    def qtltools_format(row, prefix='chr'):
      row['#Chr'] = '{}{}'.format(prefix, row['chr'][2:])
      row['gid'] = row.name
      row['pid'] = row.name
      # Important: qtltools expects TSS start/end
      if row['strand'] == '+':
        row['end'] = row['start']
      else:
        row['start'] = row['end']
      return row.loc[['#Chr', 'start', 'end', 'pid', 'gid', 'strand']]

    def write_pheno_file(pheno, gene_info, output_file, holdout=True, **kwargs):
      if holdout:
        genes = gene_info.loc[gene_info.apply(lambda x: bool(int(x['chr'][2:]) % 2), axis=1)]
      else:
        genes = gene_info
      (genes
       .apply(qtltools_format, **kwargs, axis=1)
       .merge(pheno, left_index=True, right_index=True)
       .to_csv(output_file,
               sep='\t',
               header=True,
               index=False,
               index_label=False))
  #+END_SRC

  #+RESULTS: write-pheno-def
  :RESULTS:
  # Out[4]:
  :END:

  #+NAME: tabix
  #+BEGIN_SRC sh :var input="test.bed" :var partition="broadwl" :dir /scratch/midway2/aksarkar/singlecell :eval never-export
    export input=$input
    sbatch --partition=$partition --wait
    #!/bin/bash
    module load bedtools
    bedtools sort -header -i $input | bgzip >$input.gz
    tabix -f -p bed $input.gz
  #+END_SRC

  #+NAME: qtltools
  #+BEGIN_SRC sh :var pheno="test" :var geno="geuvadis-chr1.vcf.gz" :var partition="broadwl" :var op="--permute 100000" :dir /scratch/midway2/aksarkar/singlecell :eval never-export :results output
    export pheno=$pheno
    export geno=$geno
    export op=$op
    sbatch --partition=$partition -a 1-100 -J $pheno-qtl --wait
    #!/bin/bash
    source activate scqtl
    qtltools cis --vcf $geno --bed $pheno.bed.gz $op --chunk $SLURM_ARRAY_TASK_ID 100 --out $pheno-qtl.$SLURM_ARRAY_TASK_ID.txt --seed 0
  #+END_SRC

  #+NAME: read-qtltools-def
  #+BEGIN_SRC ipython
    def _read_helper(pheno, columns):
      file_names = ['{}-qtl.{}.txt'.format(pheno, i) for i in range(1, 101)]
      res = (pd.concat([pd.read_table(f, header=None, sep=' ')
                         for f in file_names if os.path.exists(f) and
                         os.path.getsize(f) > 0])
              .rename(columns={i: x for i, x in enumerate(columns)})
              .dropna()
              .sort_values('p_beta'))
      res['p_adjust'] = bh(res['p_beta'])
      res['fdr_pass'] = res['p_adjust'] < 0.1
      return res


    def read_fastqtl_output(pheno):
      columns = ['gene', 'num_snps', 'a', 'b', 'dummy', 'id',
                 'distance', 'p', 'beta', 'p_empirical', 'p_beta']
      res = _read_helper(pheno, columns)
      # Drop the gene version number
      res['gene'] = res['gene'].apply(lambda x: x.split('.')[0])
      res['chr'] = res['id'].apply(lambda x: x.split('.')[1])
      res['pos'] = res['id'].apply(lambda x: x.split('.')[2])
      res['id'] = res['id'].apply(lambda x: x.split('.')[0])
      return res

    def read_qtltools_output(pheno):
      columns = ['gene', 'chr', 'start', 'end', 'strand', 'num_vars',
                 'distance', 'id', 'var_chr', 'var_start', 'var_end', 'df',
                 'dummy', 'a', 'b', 'p_nominal', 'beta', 'p_empirical', 'p_beta']
      res = _read_helper(pheno, columns)
      res['chr'] = res['var_chr']
      res['pos'] = res['var_start']
      res['id'] = res['id'].apply(lambda x: x.split('.')[0])
      return res

    def read_nominal_pass(f):
      isf = st.chi2(1).isf
      result = pd.read_table(f, sep=' ', header=None)
      result.columns = ['gene', 'chr', 'start', 'end', 'strand', 'n', 'distance', 'id', 'var_chr', 'var_start', 'var_end', 'p_nominal', 'beta', 'top']
      result['z'] = np.sign(result['beta']) * np.sqrt(isf(result['p_nominal']))
      return result
  #+END_SRC

  #+RESULTS: read-qtltools-def
  :RESULTS:
  # Out[5]:
  :END:

  #+RESULTS:
  :RESULTS:
  # Out[79]:
  :END:

  #+NAME: plot-approx-perm-def
  #+BEGIN_SRC ipython
    def plot_approx_permutation(df):
      plt.clf()
      plt.gcf().set_size_inches(6, 6)
      plt.scatter(df['p_empirical'], df['p_beta'], s=1, c='k')
      plt.plot([0, 1], [0, 1], c='r', ls='--')
      plt.xlabel('Empirical p-value')
      plt.ylabel('Approximate p-value')
  #+END_SRC

  #+RESULTS: plot-approx-perm-def
  :RESULTS:
  # Out[6]:
  :END:

  #+NAME: qqplot-def
  #+BEGIN_SRC ipython
    def qqplot(qtls):
      N = qtls.shape[0]
      # 95% bootstrap CI
      ci = -np.log10(np.percentile(np.sort(np.random.uniform(size=(100, N)), axis=1), [5, 95], axis=0))

      grid = -np.log10(np.arange(1, 1 + N) / N)
      plt.clf()
      plt.gcf().set_size_inches(6, 6)
      plt.scatter(grid, -np.log10(qtls['p_beta']), s=1, c='k')
      plt.plot([0, np.log10(qtls.shape[0])], [0, np.log10(qtls.shape[0])], c='r', ls='--')
      plt.plot(grid, ci[0], c='r', ls=':')
      plt.plot(grid, ci[1], c='r', ls=':')
      plt.xlabel('Expected $-\log_{10}(p)$')
      _ = plt.ylabel('Observed $-\log_{10}(p)$')
  #+END_SRC

  #+RESULTS: qqplot-def
  :RESULTS:
  # Out[7]:
  :END:

  #+NAME: replication-tests-def
  #+BEGIN_SRC ipython
    def parse_vcf_dosage(record):
      geno = [float(g) for g in record[9:]]
      return pd.Series(geno)

    def extract_qtl_gene_pair(qtl_gene_df, pheno_df, dosages):
      """Return aligned genotype and phenotype matrix for each QTL-gene pair in qtl_gene_df"""
      common_phenos, common_qtls = pheno_df.align(qtl_gene_df.set_index('gene'), join='inner', axis=0)
      # Important: assume individual IDs are prefixed by "NA". This isn't true in
      # the original VCF
      header = pd.read_table(dosages, skiprows=2, nrows=1, header=0).columns[9:]
      genotypes = tabix.open(dosages)
      X, Y = (common_qtls
              .apply(lambda x: parse_vcf_dosage(next(genotypes.query(x['chr'], int(x['var_start']) - 1, int(x['var_start'])))), axis=1)
              .rename(columns={i: ind for i, ind in enumerate(header)})
              .align(common_phenos, join='inner', axis=None))
      return X, Y

    def replication_tests(X, Y, C=None):
      """Return a DataFrame containing replication p-values

      X - centered dosage matrix (num_genes, num_individuals)
      Y - phenotype matrix (num_genes, num_individuals)
      C - confounder matrix (num_confounders, num_individuals)

      """
      p, n = X.shape
      assert Y.shape == (p, n)
      if C is not None:
        assert C.shape[1] == n
        C = np.array(C).T
        C = C - C.mean(axis=0)
        # Construct the annihilator matrix I - X X^+
        M = np.eye(n) - C.dot(np.linalg.pinv(C))
      result = []
      _sf = st.chi2(1).sf
      for (_, x), (name, y) in zip(X.iterrows(), Y.iterrows()):
        if np.isclose(x.std(), 0):
          print('Skipping {}'.format(name))
          continue
        x = x.values.copy().reshape(-1, 1)
        x -= x.mean()
        y = y.values.copy().ravel()
        y -= y.mean()
        if C is not None:
          y = M.dot(y)
          y -= y.mean()
        beta, rss, *_ = np.linalg.lstsq(x, y, rcond=-1)
        sigma2 = rss / y.shape[0]
        se = sigma2 / x.T.dot(x).ravel()
        pval = _sf(np.square(beta / se))
        result.append({'gene': name, 'beta': beta[0], 'se': se[0], 'p': pval.ravel()[0]})
      return pd.DataFrame.from_dict(result)

    def pairwise_replication(qtls, phenos, ticks, covars=None):
      if covars is not None:
        assert len(covars) == len(phenos)
      assert len(phenos) == len(ticks)
      repl_rate = np.ones((len(phenos), len(phenos)))
      for i, ki in enumerate(phenos):
        for j, kj in enumerate(phenos):
          if i == j:
            continue
          q, p = qtls[ki][0], qtls[kj][1]
          X, Y = extract_qtl_gene_pair(q[q['fdr_pass']], p,
                                       dosages='/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz')
          if X.empty:
            continue
          if covars is not None and covars[j] is not None:
            C = covars[j].align(X, axis='columns', join='inner')[0]
          else:
            C = None
          replication = q.merge(
            replication_tests(X, Y, C),
            on='gene',
            suffixes=['_1', '_2'])[['gene', 'id', 'beta_1', 'beta_2', 'p']]
          replication['fdr_pass'] = bh(replication['p']) < .1
          replication['replicated'] = replication.apply(lambda x: x['fdr_pass'] and x['beta_1'] * x['beta_2'] > 0, axis=1)
          repl_rate[i, j] = replication['replicated'].sum() / replication.shape[0]
      return pd.DataFrame(100 * repl_rate, columns=ticks, index=ticks)
  #+END_SRC

  #+RESULTS: replication-tests-def
  :RESULTS:
  # Out[8]:
  :END:

  #+NAME: bootstrap-def
  #+BEGIN_SRC ipython
    def bootstrap_se(X, Y, C=None, num_bootstraps=100, seed=0):
      np.random.seed(seed)
      beta = {}
      for i in range(num_bootstraps):
        b = np.random.choice(X.shape[1], size=X.shape[1], replace=True)
        if C is not None:
          beta[i] = replication_tests(X.iloc[:,b], Y.iloc[:,b], C.iloc[:,b]).set_index('gene')['beta']
        else:
          beta[i] = replication_tests(X.iloc[:,b], Y.iloc[:,b]).set_index('gene')['beta']
      return pd.DataFrame.from_dict(beta).agg(np.std, axis=1)
  #+END_SRC

  #+RESULTS: bootstrap-def
  :RESULTS:
  # Out[9]:
  :END:

  #+NAME: bootstrap-betahat-se-def
  #+BEGIN_SRC ipython
    def _fit_lm(x, y):
      n, p = x.shape
      assert y.shape == (n, 1)
      y -= y.mean()
      x -= x.mean(axis=0)
      beta = x.T.dot(y) / np.var(x, axis=0).values.reshape(-1, 1)
      return beta

    def estimate_beta_se(genes, dosages, gene_info, covars=None, window=100000, n_bootstrap=100, seed=0):
      """Estimate beta via OLS and SE via bootstrap

      genes - dataframe (num_genes, num_individuals)
      dosages - VCF file name
      gene_info - dataframe (see read_gene_info)
      covars - dataframe (num_covars, num_individuals)

      """
      with gzip.open(dosages, 'rt') as f:
        for line in f:
          if line.startswith('#CHROM'):
            header = line.split()[9:]
            break
      dosages = tabix.open(dosages)
      if covars is not None:
        covars, genes = covars.align(genes, axis='columns', join='inner')
        _, n = covars.shape
        covars = covars.values.T
        M = np.eye(n) - covars.dot(np.linalg.pinv(covars))
      result = []
      for gene, Y in genes.iterrows():
        if gene in gene_info.index:
          record = gene_info.loc[gene]
          if record['strand'] == '+':
            X = dosages.query('chr{}'.format(record['chr'][2:]), record['start'] - window, record['start'] + window)
          else:
            X = dosages.query('chr{}'.format(record['chr'][2:]), record['end'] - window, record['end'] + window)
          X = list(X)
          meta = [row[2] for row in X]
          X = pd.DataFrame([parse_vcf_dosage(row) for row in X])
          X.index = meta
          X.columns = header
          X, Y = X.align(Y, axis='columns', join='inner')
          if covars is not None:
            Y = M.dot(Y - Y.mean())
          X = X.transform(lambda x: x - x.mean(), axis=1)

          beta = [_fit_lm(X.T, Y.reshape(-1, 1))]
          np.random.seed(seed)
          for _ in range(n_bootstrap):
            B = np.random.choice(n, size=n, replace=True)
            beta.append(_fit_lm(X.iloc[:,B].T, Y[B].reshape(-1, 1)))
          result.append(pd.DataFrame({'gene': gene, 'snp': meta, 'beta': beta[0].values.ravel(), 'se': np.std(np.ma.masked_invalid(np.hstack(beta[1:])), axis=1)}))
      return pd.concat(result)
  #+END_SRC

  #+RESULTS: bootstrap-betahat-se-def
  :RESULTS:
  # Out[10]:
  :END:

* Preliminaries
** Test validity of approximate permutation test

   ~qtltools~ tries to calibrate false discovery rates using the following
   procedure:

   1. For each gene, permute the genotype data to estimate the null distribution
      of the p-values
   2. Fit a beta distribution to the permuted p-values via ML
   3. Compute the lower tail probability of the observed p-value, assuming it
      was generated from the fitted beta distribution
   4. Apply FDR correction on the set of lower tail probabilities (across all
      genes)

   Test whether the beta approximation is appropriate for our sample size by
   subsetting GEUVADIS. Take all genes on chromosome 1.

   #+BEGIN_SRC ipython
    geuvadis = []
    for chunk in pd.read_table('/project/compbio/geuvadis/analysis_results/GD462.GeneQuantRPKM.50FN.samplename.resk10.txt.gz', chunksize=100):
      geuvadis.append(chunk.query('Chr == "1"'))
    geuvadis = pd.concat(geuvadis)
    geuvadis = geuvadis.set_index(geuvadis['Gene_Symbol'].apply(lambda x: x.split('.')[0]))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[34]:
   :END:

   First, replicate the result in [[https://www.nature.com/articles/ncomms15452][Delaneau et al 2017]] by using all 462
   individuals from GEUVADIS.

   #+BEGIN_SRC ipython
    pd.Series(geuvadis.columns).sort_values().to_csv('/scratch/midway2/aksarkar/singlecell/geuvadis/geuvadis-subset.txt', header=None, index=None)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[35]:
   :END:

   Write out the phenotype file for ~qtltools~. Important: GEUVADIS VCFs code
   chromosome without ~chr~.

   #+BEGIN_SRC ipython
     write_pheno_file(geuvadis, gene_info, '/scratch/midway2/aksarkar/singlecell/geuvadis/test.bed', prefix='')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[39]:
   :END:

   Index the phenotype file. Important: ~#~ sorts before ~c~, but after ~1~.

   #+CALL: tabix() :dir /scratch/midway2/aksarkar/singlecell/geuvadis

   #+RESULTS:
   : Submitted batch job 44542169

   Perform SNP QC in ~plink~.

   #+NAME: geuvadis-qc
   #+BEGIN_SRC sh :eval never-export :dir /scratch/midway2/aksarkar/singlecell/geuvadis
     sbatch --partition=broadwl --mem=2G --wait
     #!/bin/bash
     plink --memory 2000 --geno 0.01 --maf 0.05 --keep-fam /scratch/midway2/aksarkar/singlecell/geuvadis-subset.txt --vcf /project/compbio/geuvadis/genotypes/GEUVADIS.chr1.PH1PH2_465.IMPFRQFILT_BIALLELIC_PH.annotv2.genotypes.vcf.gz --recode vcf-iid --out geuvadis-chr1
     bgzip -f geuvadis-chr1.vcf
     tabix -f -p vcf geuvadis-chr1.vcf.gz
   #+END_SRC

   #+RESULTS: geuvadis-qc
   : Submitted batch job 44541229

   Run ~qtltools~.

   #+CALL: qtltools() :dir /scratch/midway2/aksarkar/singlecell/geuvadis

   #+RESULTS:
   : Submitted batch job 44685856

   Read the results.

   #+BEGIN_SRC ipython
    geuvadis_qtls = read_qtltools_output('geuvadis/test')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[23]:
   :END:

   Check the beta approximation to the permutation p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/geuvadis-beta-approx.png
    plot_approx_permutation(geuvadis_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[41]:
   [[file:figure/qtl-mapping.org/geuvadis-beta-approx.png]]
   :END:

   Plot the QQ plot

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/geuvadis-qq.png
     qqplot(geuvadis_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[24]:
   [[file:figure/qtl-mapping.org/geuvadis-qq.png]]
   :END:

   Repeat the analysis after subsetting to 54 individuals.

   #+BEGIN_SRC ipython
    np.random.seed(0)
    subset = np.random.choice([x for x in geuvadis.columns], size=54, replace=False)
    pd.Series(subset).sort_values().to_csv('/scratch/midway2/aksarkar/singlecell/geuvadis-subset.txt', header=None, index=None)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[42]:
   :END:

   #+BEGIN_SRC ipython
     write_pheno_file(geuvadis[subset], gene_info, '/scratch/midway2/aksarkar/singlecell/geuvadis/test.bed', prefix='')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[44]:
   :END:

   #+CALL: tabix() :dir /scratch/midway2/aksarkar/singlecell/geuvadis

   #+RESULTS:
   : Submitted batch job 44544326

   #+CALL: geuvadis-qc() :dir /scratch/midway2/aksarkar/singlecell/geuvadis

   #+RESULTS:
   : Submitted batch job 44544018

   #+CALL: qtltools() :dir /scratch/midway2/aksarkar/singlecell/geuvadis

   #+RESULTS:
   : Submitted batch job 44544375

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/geuvadis-54-beta-approx.png
     geuvadis_54_qtls = read_qtltools_output('geuvadis/test')
     plot_approx_permutation(geuvadis_54_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[47]:
   [[file:figure/qtl-mapping.org/geuvadis-54-beta-approx.png]]
   :END:

** Reproduce bulk eQTL calls

   The iPSC bulk eQTLs were called in [[https://genome.cshlp.org/content/28/1/122.long][Banovich et al 2018]].

   #+BEGIN_EXAMPLE
     eQTLs in iPSCs and LCLs: We transformed expression levels to a standard normal
     within each individual. We next accounted for unknown confounders by removing
     principal components from the LCL (15 PCs) and iPSC (10 PCs) data. Genotypes
     were obtained using impute2 as described previously (Li et al. 2016). We only
     considered variants within 50 kb of genes. To identify association between
     genotype and gene expression, we used FastQTL (Ongen et al. 2016). After the
     initial regression, a variable number of permutations were performed to obtain
     a gene-wise adjusted P-value (Ongen et al. 2016). To identify significant
     eQTLs, we used Storey's q-value (Storey and Tibshirani 2003) on the adjusted
     P-values. Genes with a q-value less than 0.1 are considered significant.
   #+END_EXAMPLE

   *Important notes:*

   1. The text doesn't state how expression level was quantified (it was the
      ratio of mapped reads to total reads after correction by
      ~WASP~).

      ~WASP~ ([[https://www.nature.com/articles/nmeth.3582][de Geijin et al 2015]]) fits quartic polynomials \(f, g\) which
      predict the total read count per region \(T^*_{ij}\) from the observed
      read count \(x_{ij}\) and GC content \(w_j\) by maximizing the likelihood
      of the observed read counts:

      \[ x_{ij} \sim \mathrm{Pois}(T^*_{ij}) \]

      \[ T^*_{ij} = \exp\left(f\left(\sum_i x_{ij}\right)\right) g(w_j) \]

      [[*Recall bulk eQTLs from log CPM][Using log CPM]] (under the assumption that we never compare genes to each
      other) yields 1279 eQTLs (89%).

   2. ~fastqtl~ expects gene start/end, and only takes /cis/-SNPs around the
      start ignoring strand. The code uses GENCODE v19 exons to define the
      start/end.

      ~qtltools~ expects TSS and strand, but doesn't use strand information in
      /cis/-eQTL mapping. Using the start coordinate of the provided expression
      matrix as TSS yields 1265 eQTLs (87%).

   3. The methods section of [[https://www.nature.com/articles/nature10808][Degner et al 2012]] states data is standardized
      across individuals, and quantile normalized within individuals. The
      equation contradicts the text, but the code follows the text.

   4. The code analyzes 100kb windows, contradicting the text.

   5. Not every gene in the input appears in the output, and changing the number
      of chunks changes the number of genes lost.

   6. QTL-gene pairs passed the Benjamini-Hochberg procedure, not Storey's
      procedure.

   #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/singlecell/reproduce-yang
     sbatch --partition=broadwl -a 1-25
     #!/bin/bash
     source activate scqtl
     fastqtl -V YRI_SNPs_2_IPSC.txt.gen.gz -B fastqtl_qqnorm_RNAseq_run.fixed.txt.gz -C fasteqtl_PC_RNAseq_run.fixed.txt -O bulk-qtl.$SLURM_ARRAY_TASK_ID.txt --exclude-samples file_IPSC.excl --window 1e5 --permute 1000 10000 --chunk $SLURM_ARRAY_TASK_ID 25 --seed 1475098497
   #+END_SRC

   #+RESULTS:
   : Submitted batch job 44546060

   Subsample the individuals.

   #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/singlecell/reproduce-yang
     sbatch --partition=broadwl -a 1-25
     #!/bin/bash
     source activate scqtl
     awk 'NR < 6' file_IPSC.used | cat - file_IPSC.excl >subsample.excl
     fastqtl -V YRI_SNPs_2_IPSC.txt.gen.gz -B fastqtl_qqnorm_RNAseq_run.fixed.txt.gz -C fasteqtl_PC_RNAseq_run.fixed.txt -O bulk-qtl.$SLURM_ARRAY_TASK_ID.txt --exclude-samples subsample.excl --window 1e5 --permute 1000 10000 --chunk $SLURM_ARRAY_TASK_ID 25 --seed 1475098497
   #+END_SRC

   #+RESULTS:
   : Submitted batch job 47297158

   Read ~fastqtl~ output.

   #+BEGIN_SRC ipython
     bulk_qtls = read_fastqtl_output('reproduce-yang/bulk')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[101]:
   :END:

   Write out the summary stats with headers.

   #+BEGIN_SRC ipython
     bulk_qtls.to_csv('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-mapping/bulk.txt.gz', sep='\t', index=None, compression='gzip')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[21]:
   :END:

   Compare ~qtltools~ to ~fastqtl~. The input files need to be modified.

   #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/singlecell/reproduce-yang/
     sbatch --partition=broadwl --wait
     #!/bin/bash
     zcat fastqtl_qqnorm_RNAseq_run.fixed.txt.gz | awk -vOFS='\t' 'NR == 1 {$4 = "pid" OFS "gid" OFS "strand"; for (i = 5; i <= NF; i++) {$i = "NA"$i} print} NR > 1 {$4 = $4 OFS $4 OFS "+"; $3 = $2; print}' >test.bed
     awk 'NR == 1 {for (i = 2; i <= NF; i++) {$i = "NA"$i}} {print}' fasteqtl_PC_RNAseq_run.fixed.txt >bulk-covars.txt
   #+END_SRC

   #+RESULTS:
   : Submitted batch job 44979838

   Check whether the FDR is properly controlled by permuting.
   
   #+BEGIN_SRC ipython
     np.random.seed(0)
     permutation = bulk_expr.columns.values.copy()
     np.random.shuffle(permutation[5:])
     bulk_expr.columns = permutation

     covars = (pd.read_table('/scratch/midway2/aksarkar/singlecell/reproduce-yang/covars.txt', sep=' ')
               .rename(columns={k: v for k, v in zip(bulk_expr.columns, permutation)}))
     covars.to_csv('/scratch/midway2/aksarkar/singlecell/reproduce-yang/covars.txt', sep=' ', index=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[121]:
   :END:

   Fix the TSS by rewriting the phenotype file.

   #+BEGIN_SRC ipython
     bulk_expr = pd.read_table('/scratch/midway2/aksarkar/singlecell/reproduce-yang/test.bed', index_col=3)
     bulk_expr.index = [x.split('.')[0] for x in bulk_expr.index]
     write_pheno_file(bulk_expr.iloc[:,5:], gene_info, '/scratch/midway2/aksarkar/singlecell/reproduce-yang/test.bed', holdout=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[152]:
   :END:

   Index the phenotype file.

   #+CALL: tabix(input="test.bed") :dir /scratch/midway2/aksarkar/singlecell/reproduce-yang/

   #+RESULTS:
   : Submitted batch job 44683584

   Run ~qtltools~.

   #+CALL: qtltools(pheno="test", geno="/scratch/midway2/aksarkar/singlecell/reproduce-yang/yri-dosages.vcf.gz", op="--cov covars.txt --window 100000 --permute 10000") :dir /scratch/midway2/aksarkar/singlecell/reproduce-yang/

   #+RESULTS:
   : Submitted batch job 44683586

   Run ~qtltools~ on reprocessed dosages.

   #+CALL: qtltools(pheno="test", geno="/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz", op="--cov covars.txt --window 100000 --permute 10000") :dir /scratch/midway2/aksarkar/singlecell/reproduce-yang/

   #+RESULTS:
   : Submitted batch job 47427752

   Run ~qtltools~ on subsample.

   #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/singlecell/reproduce-yang/
     awk '{print "NA" $0}' subsample.excl >subsample-qtltools.excl
   #+END_SRC

   #+RESULTS:

   #+CALL: qtltools(pheno="test", geno="/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz", op="--cov covars.txt --exclude-samples subsample-qtltools.excl --window 100000 --permute 10000") :dir /scratch/midway2/aksarkar/singlecell/reproduce-yang/

   #+RESULTS:
   : Submitted batch job 47428279

   Read ~qtltools output~

   #+BEGIN_SRC ipython
     bulk_qtls = read_qtltools_output('reproduce-yang/test')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[24]:
   :END:

   Check the beta approximation.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/qqnorm-beta-approx.png
     plot_approx_permutation(bulk_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[134]:
   [[file:figure/qtl-mapping.org/qqnorm-beta-approx.png]]
   :END:

   Plot a QQ plot of adjusted p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/qqnorm-qq.png
     qqplot(bulk_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[135]:
   [[file:figure/qtl-mapping.org/qqnorm-qq.png]]
   :END:

   Take QTLs with \(\mathrm{FDR} < 0.1\).

   #+BEGIN_SRC ipython
     bulk_qtls['fdr_pass'].sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[25]:
   : 1136
   :END:

** Recall bulk eQTLs from log CPM

   Read the counts matrix.

   #+BEGIN_SRC ipython
     bulk_counts = (pd.read_table('/project2/gilad/singlecell-qtl/bulk/counts_RNAseq_iPSC.txt', sep=' ', index_col=0)
                    .rename(columns=lambda x: 'NA{}'.format(x))
                    .rename(index=lambda x: x.split('.')[0]))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[34]:
   :END:

   Throw out individuals.

   #+BEGIN_SRC ipython
     with open('/scratch/midway2/aksarkar/singlecell/reproduce-yang/file_IPSC.excl') as f:
       for line in f:
         k = 'NA{}'.format(line.strip())
         if k in bulk_counts:
           del bulk_counts[k]
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[35]:
   :END:

   Normalize the counts matrix by computing log CPM. Normalizing by length is
   unnecessary because we only ever compare counts for the same gene across
   individuals.

   #+BEGIN_SRC ipython
     bulk_log_cpm = (cpm(bulk_counts)
                     .transform(lambda x: (x - x.mean()) / x.std(), axis=1)
                     .apply(qqnorm, axis=0))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[36]:
   :END:

   Compute expression PCs.

   #+BEGIN_SRC ipython
     covars = pd.DataFrame(skd.PCA(n_components=10).fit(bulk_log_cpm).components_, columns=bulk_log_cpm.columns)
     covars.index.name = 'id'
     covars.to_csv('/scratch/midway2/aksarkar/singlecell/recall-bulk/log-cpm-covars.txt', sep='\t')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[37]:
   :END:

   Check whether the false discovery rate is properly controlled by permuting
   the data.

   Write the phenotype matrix in ~qtltools~ format.  Use the annotation data
   (ENSEMBL 75) in this repository to be consistent with the single cell
   data. *Important: this loses 1716 genes (are they pseudogenes?)*

   #+BEGIN_SRC ipython
     write_pheno_file(
       bulk_log_cpm,
       gene_info,
       holdout=False,
       output_file='/scratch/midway2/aksarkar/singlecell/recall-bulk/bulk-log-cpm.bed')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[38]:
   :END:

   Index the phenotype file.

   #+CALL: tabix(input="bulk-log-cpm.bed") :dir /scratch/midway2/aksarkar/singlecell/recall-bulk

   #+RESULTS:
   : Submitted batch job 44681764

   Ensure the dosage file follows the VCF standard. Add the prefix ~NA~ to sample IDs.

   #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/singlecell/reproduce-yang
     sbatch --partition=broadwl
     #!/bin/bash
     zcat YRI_SNPs_2_IPSC.txt.gen.gz | awk -vOFS='\t' 'BEGIN {print "##fileformat=VCFv4.2"; print "##FORMAT=<ID=DS,Number=1,Type=Float>"} NR == 1 {for (i = 10; i <= NF; i++) {$i = "NA"$i}} {print}' | bgzip >yri-dosages.vcf.gz
     tabix yri-dosages.vcf.gz
   #+END_SRC

   #+RESULTS:
   : Submitted batch job 44546926

   Run ~qtltools~

   #+CALL: qtltools(pheno="bulk-log-cpm", geno="/scratch/midway2/aksarkar/singlecell/reproduce-yang/yri-dosages.vcf.gz", op="--cov log-cpm-covars.txt --window 100000 --permute 10000") :dir /scratch/midway2/aksarkar/singlecell/recall-bulk

   #+RESULTS:
   : Submitted batch job 44681768

   Read the output. *Important: this loses 201 genes (is this a bug in
   ~qtltools~)?*

   #+BEGIN_SRC ipython
     bulk_cpm_qtls = read_qtltools_output('recall-bulk/bulk-log-cpm')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[137]:
   :END:

   Check the beta approximation.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/bulk-cpm-beta-approx.png
     plot_approx_permutation(bulk_cpm_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[40]:
   [[file:figure/qtl-mapping.org/bulk-cpm-beta-approx.png]]
   :END:

   Plot a QQ plot of adjusted p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/bulk-cpm-qq.png
     qqplot(bulk_cpm_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[138]:
   [[file:figure/qtl-mapping.org/bulk-cpm-qq.png]]
   :END:

   Take QTLs with \(\mathrm{FDR} < 0.1\).

   #+BEGIN_SRC ipython
     bulk_cpm_qtls['fdr_pass'].sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[139]:
   : 1276
   :END:

** Recall bulk eQTLs from log TPM

   We [[file:kallisto.org][reprocessed the bulk RNA-Seq data]] using ~kallisto~. Read the TPM
   matrix.

   #+BEGIN_SRC ipython
     bulk_log_tpm = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/kallisto/bulk-ipsc-tpm.txt.gz', header=None, sep=' ')
     bulk_log_tpm = np.log(bulk_log_tpm.pivot(columns=0, index=1, values=2) + 1)
     bulk_log_tpm.index = [x.split('.')[0] for x in bulk_log_tpm.index]
     # Important: need to throw out all zero rows because they blow up
     # standardization
     bulk_log_tpm = (bulk_log_tpm[bulk_log_tpm.apply(lambda x: x.sum() > 0, axis=1)]
                     .transform(lambda x: (x - x.mean()) / x.std(), axis=1)
                     .apply(qqnorm, axis=0))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[13]:
   :END:

   To quantify how much power we expect to lose going from 58 to 53 individuals
   (in our scRNA-Seq data), perform QTL mapping on a random subset of 53
   individuals.

   #+BEGIN_SRC ipython
     np.random.seed(0)
     keep_inds = np.random.choice(bulk_log_tpm.columns, size=53, replace=False)
     bulk_log_tpm = bulk_log_tpm.filter(items=keep_inds, axis='columns')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[12]:
   :END:

   Get the TSS information. Use the annotation data (ENSEMBL 75) in this
   repository to be consistent with the single cell data.

   Write the phenotype matrix in ~qtltools~ format. *Important: this loses 1034
   genes*

   #+BEGIN_SRC ipython
     write_pheno_file(
       bulk_log_tpm,
       gene_info,
       holdout=False,
       output_file='/scratch/midway2/aksarkar/singlecell/recall-bulk/bulk-log-tpm.bed')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[14]:
   :END:

   Index the phenotype file.

   #+CALL: tabix(input="bulk-log-tpm.bed") :dir /scratch/midway2/aksarkar/singlecell/recall-bulk

   #+RESULTS:
   : Submitted batch job 47427500

   Compute principal components.

   #+BEGIN_SRC ipython
    covars = pd.DataFrame(skd.PCA(n_components=6).fit(bulk_log_tpm).components_, columns=bulk_log_tpm.columns)
    covars.index.name = 'id'
    covars.to_csv('/scratch/midway2/aksarkar/singlecell/recall-bulk/log-tpm-covars.txt', sep='\t')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[15]:
   :END:

   Run ~qtltools~

   #+CALL: qtltools(pheno="bulk-log-tpm", geno="/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz", op="--cov log-tpm-covars.txt --window 100000 --permute 10000") :dir /scratch/midway2/aksarkar/singlecell/recall-bulk

   #+RESULTS:
   : Submitted batch job 47427616

   Read the output. *Important: this loses 201 genes (is this a bug in
   ~qtltools~)?*

   #+BEGIN_SRC ipython
     bulk_tpm_qtls = read_qtltools_output('recall-bulk/bulk-log-tpm')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[16]:
   :END:

   Check the beta approximation to the permuted p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/bulk-tpm-beta-approx.png
     plot_approx_permutation(bulk_tpm_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[17]:
   [[file:figure/qtl-mapping.org/bulk-tpm-beta-approx.png]]
   :END:

   Plot a QQ plot of the adjusted p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/bulk-log-tpm-qtl-qq.png
     qqplot(bulk_tpm_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[18]:
   [[file:figure/qtl-mapping.org/bulk-log-tpm-qtl-qq.png]]
   :END:

   Take QTLs with \(\mathrm{FDR} < 0.1\).

   #+BEGIN_SRC ipython
     bulk_tpm_qtls['fdr_pass'].sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[19]:
   : 683
   :END:

** Reprocess YRI dosages

   We have two individuals which weren't used in Banovich et al 2018, so we
   don't have their genotypes. Reprocess the IMPUTE2 output to get the correct
   dosage matrix.

   #+BEGIN_SRC sh :eval never :dir spudhead:/mnt/lustre/data/internal/genotypes/hg19/YRI/YRI_samples.txt
     rsync -au -f '+ */' -f '+ *.impute2.gz' -f '+ YRI_samples.txt' -f '- *' /mnt/lustre/data/internal/genotypes/hg19/YRI/ aksarkar@midway2.rcc.uchicago.edu:/scratch/midway2/aksarkar/singlecell/scqtl-mapping/
   #+END_SRC

   #+BEGIN_SRC ipython :eval never :tangle /project2/mstephens/aksarkar/projects/singlecell-qtl/code/reprocess-dosage.py
     import argparse
     import glob
     import gzip
     import numpy as np
     import pandas as pd
     import sqlite3

     def convert_impute2_vcf(file, chrom, outfile, min_maf=0.05, mask=None):
       for line in file:
         record = line.split()
         posterior = np.array([float(x) for x in record[5:]])
         dose = posterior.reshape(-1, 3).dot(np.arange(3))
         if mask is not None:
           dose = dose[mask]
         if min_maf <= dose.mean() / 2 <= 1 - min_maf:
           print(chrom, record[2], '{}.{}.{}'.format(record[1], chrom, record[2]),
                 record[3], record[4], '.', '.', '.', 'DS',
                 ,*['{:.3f}'.format(x) for x in dose], sep='\t', file=outfile)

     parser = argparse.ArgumentParser()
     parser.add_argument('-s', '--subset', help='Sample inclusion list', type=pd.read_table, default=None)
     parser.add_argument('-o', '--output', help='Output file', default='dosages.vcf')
     args = parser.parse_args()

     samples = pd.read_table('YRI_samples.txt', header=None, sep=' ')
     if args.subset is not None:
       mask = samples[0].isin(args.subset).values
       samples = samples.loc[mask.values.ravel(), 0]
     else:
       mask = None
       samples = samples.loc[:,0]
     with open(args.output, 'w') as f:
       print('##fileformat=VCFv4.2', file=f)
       print('##FORMAT=<ID=DS,Number=1,Type=Float>', file=f)
       print('#CHROM', 'POS', 'ID', 'REF', 'ALT', 'QUAL', 'FILTER', 'INFO', 'FORMAT', *samples, sep='\t', file=f)
       for c in range(1, 23):
         with gzip.open('chr{}.hg19.impute2.gz'.format(c), 'rt') as g:
           convert_impute2_vcf(g, 'chr{}'.format(c), outfile=f, mask=mask)
   #+END_SRC


   #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping
     sbatch --partition=broadwl -n1 -c28 --exclusive --mem=8G
     #!/bin/bash
     source activate scqtl
     python /project2/mstephens/aksarkar/projects/singlecell-qtl/code/reprocess-dosage.py -o yri-120-dosages.vcf
     bgzip --threads=28 yri-120-dosages.vcf
     tabix yri-120-dosages.vcf.gz
   #+END_SRC

   #+RESULTS:
   : Submitted batch job 47228636

* Analysis using sample moments                                    :noexport:

  The most obvious way to estimate means/variances to use as quantitative
  phenotypes is to use the sample moments of per cell log CPM.

  Care has to be taken in handling zero-observations. Simply ignoring them
  leads to loss of power due to the pseudocount introduced in computing log
  CPM. To see this, fix one individual, one gene, and let \(r\) denote the
  observed count. Then,

  \[ \log\mathrm{CPM} \propto \ln(r + \epsilon) - \ln\mathrm{const} \]

  Let \(\mu = \mathbb{E}[r\,]\), \(\sigma^2 = \mathbb{V}[r\,]\), expand to
  second-order, then take expectations over cells:

  \[ \mathbb{E}[\,\ln (r + \epsilon)\,] \approx \ln(\mu + \epsilon) -
   \frac{\sigma^2}{(\mu + \epsilon)^2} \]

  \[ \mathbb{V}[\,\ln (r + \epsilon)\,] \approx \frac{2 \sigma^2}{(\mu +
   \epsilon)^2} - \frac{\sigma^4}{(\mu + \epsilon)^4} \]

** Call eQTLs from pooled scRNA-Seq

   Read the QC filters.

   #+NAME: qc-filters
   #+BEGIN_SRC ipython
     annotation = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-annotation.txt')
     keep_samples = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/quality-single-cells.txt', index_col=0, header=None)
     keep_genes = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/genes-pass-filter.txt', index_col=0, header=None)
     annotation = annotation.loc[keep_samples.values.ravel()]
     keep_inds = annotation.groupby('chip_id').apply(lambda x: len(x) >= 50)
   #+END_SRC

   #+RESULTS: qc-filters
   :RESULTS:
   # Out[46]:
   :END:

   Read and pool the UMI data.

   #+BEGIN_SRC ipython
     pooled_counts = pd.concat(
       [(chunk
         .filter(items=keep_genes[keep_genes.values].index, axis='index')
         # Important: this can't be done by filter because sample names are
         # different in the QC file
         .loc[:,keep_samples.values.ravel()]
         .groupby(annotation['chip_id'].values, axis=1)
         .agg(np.sum))
        for chunk in
        pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-counts.txt.gz',
                      chunksize=1000, index_col=0)])
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[47]:
   :END:

   Normalize the pooled counts.

   #+BEGIN_SRC ipython
     pooled_cpm = (cpm(pooled_counts).loc[:,keep_inds]
                   .transform(lambda x: (x - x.mean()) / x.std(), axis=1)
                   .apply(qqnorm, axis=0))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[53]:
   :END:

   Compute principal components and write out the covariate file.

   #+BEGIN_SRC ipython
     covars = pd.DataFrame(skd.PCA(n_components=10).fit(pooled_cpm).components_, columns=pooled_cpm.columns)
     covars.index.name = 'id'
     covars.to_csv('/scratch/midway2/aksarkar/singlecell/scqtl-mapping/pooled-covars.txt', sep='\t')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[54]:
   :END:

   Write out the phenotype file.

   #+BEGIN_SRC ipython
     write_pheno_file(pooled_cpm, gene_info, holdout=False, output_file='/scratch/midway2/aksarkar/singlecell/scqtl-mapping/pooled.bed')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[55]:
   :END:

   Index the phenotype file.

   #+CALL: tabix(input="pooled.bed") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 46254057

   Run ~qtltools~

   #+CALL: qtltools(pheno="pooled", geno="/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz", op="--cov pooled-covars.txt --window 100000 --permute 10000") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 46254059

   Read the output. *Important: this loses 200 genes (is this a bug in
   ~qtltools~)?*

   #+BEGIN_SRC ipython
     pooled_qtls = read_qtltools_output('scqtl-mapping/pooled')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[56]:
   :END:

   Check the beta approximation.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/pooled-cpm-beta-approx.png
     plot_approx_permutation(pooled_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[57]:
   [[file:figure/qtl-mapping.org/pooled-cpm-beta-approx.png]]
   :END:

   Plot a QQ plot of the adjusted p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/pooled-qtl-qq.png
     qqplot(pooled_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[58]:
   [[file:figure/qtl-mapping.org/pooled-qtl-qq.png]]
   :END:

   Take QTLs with \(\mathrm{FDR} < 0.1\).

   #+BEGIN_SRC ipython
     pooled_qtls['fdr_pass'].sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[59]:
   : 257
   :END:

** Call mean-QTLs

   Throw out individuals with fewer than 50 cells.

   #+CALL: qc-filters()

   #+RESULTS:
   :RESULTS:
   # Out[60]:
   :END:

   Read the count matrix.

   #+NAME: read-umi
   #+BEGIN_SRC ipython
     umi = pd.concat(
       [(chunk
         .filter(items=keep_genes[keep_genes.values].index, axis='index')
         # Important: this can't be done by filter because sample names are
         # different in the QC file
         .loc[:,keep_samples.values.ravel()])
        for chunk in
        pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-counts.txt.gz',
                      chunksize=1000, index_col=0)])
   #+END_SRC

   #+RESULTS: read-umi
   :RESULTS:
   # Out[61]:
   :END:

   We previously noted that 50 cells was sufficient to reliably estimate the
   mean of single cell data. Therefore, throw out zeros from the analysis and
   require that at least 50 samples have non-zero count.

   #+BEGIN_SRC ipython
     num_non_zero = umi.groupby(annotation['chip_id'].values, axis=1).agg(lambda x: (x > 0).values.sum(axis=1))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[62]:
   :END:

   Derive a cutoff for the number of individuals with at least 50 non-zero
   observations per gene.

   #+BEGIN_SRC ipython
     num_individuals_pass = (num_non_zero > 50).agg(np.sum, axis=1)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[63]:
   :END:

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/num-individuals-pass.png
     plt.clf()
     n, b, _ = plt.hist(num_individuals_pass, color='k', bins=np.arange(0, 53, 2), histtype='step', cumulative=True, normed=True)
     plt.axhline(y=n[-2], c='r', ls=':', lw=1)
     plt.xlabel('Number of individuals with at least 50 non-zero observations')
     _ = plt.ylabel('Cumulative fraction of genes')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[64]:
   [[file:figure/qtl-mapping.org/num-individuals-pass.png]]
   :END:

   Compute the sample mean log CPM per individual, then normalize.

   #+BEGIN_SRC ipython
     sample_mean = (cpm(umi)
                    .mask(umi == 0)
                    .groupby(annotation['chip_id'].values, axis=1)
                    .agg(np.mean)
                    .loc[num_individuals_pass >= 50,keep_inds]
                    .transform(lambda x: (x - x.mean()) / x.std(), axis=1)
                    .apply(qqnorm, axis=0))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[65]:
   :END:

   Compute principal components and write out the covariate file.

   #+BEGIN_SRC ipython
    covars = pd.DataFrame(skd.PCA(n_components=10).fit(sample_mean).components_, columns=sample_mean.columns)
    covars.index.name = 'id'
    covars.to_csv('/scratch/midway2/aksarkar/singlecell/scqtl-mapping/sample-mean-covars.txt', sep='\t')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[66]:
   :END:

   Write out the [[https://qtltools.github.io/qtltools/pages/input_files.html][phenotype file]] for ~qtltools~. Hold out even chromosomes while
   optimizing the power to detect eQTLs.

   #+BEGIN_SRC ipython
     write_pheno_file(
       sample_mean,
       gene_info,
       output_file='/scratch/midway2/aksarkar/singlecell/scqtl-mapping/sample-mean.bed',
       holdout=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[67]:
   :END:

   Index the phenotype file.

   #+CALL: tabix(input="sample-mean.bed") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 46254454

   Run ~qtltools~.

   #+CALL: qtltools(pheno="sample-mean", geno="/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz", op="--cov sample-mean-covars.txt --window 100000 --permute 10000") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 46254485

   Read the output.

   #+BEGIN_SRC ipython
     sample_mean_qtls = read_qtltools_output('scqtl-mapping/sample-mean')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[68]:
   :END:

   Check the beta approximation to the permutation p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/sample-mean-qtl-beta-approx.png
     plot_approx_permutation(sample_mean_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[69]:
   [[file:figure/qtl-mapping.org/sample-mean-qtl-beta-approx.png]]
   :END:

   Plot a QQ plot of the adjusted p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/sample-mean-qtl-qq.png
     qqplot(sample_mean_qtls)
   #+end_SRC

   #+RESULTS:
   :RESULTS:
   # Out[70]:
   [[file:figure/qtl-mapping.org/sample-mean-qtl-qq.png]]
   :END:

   Take QTLs at FDR 10%.

   #+BEGIN_SRC ipython
    sample_mean_qtls['fdr_pass'].sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[71]:
   : 189
   :END:

** Call variance-QTLs

   Throw out individuals with fewer than 50 cells.

   #+CALL: qc-filters()

   #+RESULTS:
   :RESULTS:
   # Out[9]:
   :END:

   Read the UMI matrix.

   #+CALL: read-umi()

   #+RESULTS:
   :RESULTS:
   # Out[10]:
   :END:

   Compute the sample variance of log CPM per individual, then normalize.

   #+BEGIN_SRC ipython
     sample_var = (cpm(umi)
                   .mask(umi == 0)
                   .groupby(annotation['chip_id'].values, axis=1)
                   .agg(np.var)
                   .loc[num_individuals_pass >= 50,keep_inds]
                   .transform(lambda x: (x - x.mean()) / x.std(), axis=1)
                   .apply(qqnorm, axis=0))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[72]:
   :END:

   Compute principal components and write out the covariate file.

   #+BEGIN_SRC ipython
     covars = pd.DataFrame(skd.PCA(n_components=2).fit(sample_var).components_, columns=sample_var.columns)
     covars.index.name = 'id'
     covars.to_csv('/scratch/midway2/aksarkar/singlecell/scqtl-mapping/sample-var-covars.txt', sep='\t')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[73]:
   :END:

   Write out the [[https://qtltools.github.io/qtltools/pages/input_files.html][phenotype file]] for ~qtltools~. Hold out even chromosomes while
   optimizing the power to detect eQTLs.

   #+BEGIN_SRC ipython
     write_pheno_file(sample_var, gene_info, '/scratch/midway2/aksarkar/singlecell/scqtl-mapping/sample-var.bed', holdout=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[74]:
   :END:

   Index the phenotype file.

   #+CALL: tabix(input="sample-var.bed") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 46254632

   Run ~qtltools~.

   #+CALL: qtltools(pheno="sample-var", geno="/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz", op="--cov sample-var-covars.txt --window 100000 --permute 10000") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 46254663

   Read the output.

   #+BEGIN_SRC ipython
     sample_var_qtls = read_qtltools_output('scqtl-mapping/sample-var')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[75]:
   :END:

   Check the beta approximation to the permutation p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/sample-var-qtl-beta-approx.png
     plot_approx_permutation(sample_var_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[76]:
   [[file:figure/qtl-mapping.org/sample-var-qtl-beta-approx.png]]
   :END:

   Plot a QQ plot of the adjusted p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/sample-var-qtl-qq.png
     qqplot(sample_var_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[77]:
   [[file:figure/qtl-mapping.org/sample-var-qtl-qq.png]]
   :END:

   Take QTLs at FDR 10%.

   #+BEGIN_SRC ipython
     sample_var_qtls['fdr_pass'].sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[78]:
   : 1
   :END:

** Call CV-QTLs

   Throw out individuals with fewer than 50 cells.

   #+CALL: qc-filters()

   #+RESULTS:
   :RESULTS:
   # Out[9]:
   :END:

   Read the UMI matrix.

   #+CALL: read-umi()

   #+RESULTS:
   :RESULTS:
   # Out[10]:
   :END:

   Compute the sample CV of log CPM per individual, then normalize.

   #+BEGIN_SRC ipython
     sample_cv = (cpm(umi)
                  .mask(umi == 0)
                  .groupby(annotation['chip_id'].values, axis=1)
                  .agg(lambda x: np.std(x, axis=1) / (np.mean(x, axis=1) + 1e-8))
                  .loc[num_individuals_pass >= 50,keep_inds]
                  .transform(lambda x: (x - x.mean()) / x.std(), axis=1)
                  .apply(qqnorm, axis=0))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[79]:
   :END:

   Write out the [[https://qtltools.github.io/qtltools/pages/input_files.html][phenotype file]] for ~qtltools~. Hold out even chromosomes while
   optimizing the power to detect eQTLs.

   #+BEGIN_SRC ipython
     write_pheno_file(sample_cv, gene_info, '/scratch/midway2/aksarkar/singlecell/scqtl-mapping/sample-cv.bed', holdout=True)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[80]:
   :END:

   Index the phenotype file.

   #+CALL: tabix(input="sample-cv.bed") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 46254797

   Run ~qtltools~.

   #+CALL: qtltools(pheno="sample-cv", geno="/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz", op="--window 100000 --permute 10000") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 46254798

   Read the output.

   #+BEGIN_SRC ipython
    sample_cv_qtls = read_qtltools_output('scqtl-mapping/sample-cv')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[81]:
   :END:

   Check the beta approximation to the permutation p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/sample-cv-qtl-beta-approx.png
     plot_approx_permutation(sample_cv_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[82]:
   [[file:figure/qtl-mapping.org/sample-cv-qtl-beta-approx.png]]
   :END:

   Plot a QQ plot of the adjusted p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/sample-cv-qtl-qq.png
    qqplot(sample_cv_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[83]:
   [[file:figure/qtl-mapping.org/sample-cv-qtl-qq.png]]
   :END:

   Take QTLs at FDR 10%.

   #+BEGIN_SRC ipython
    sample_cv_qtls['fdr_pass'].sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[84]:
   : 3
   :END:

** Call Fano-QTLs

   Throw out individuals with fewer than 50 cells.

   #+CALL: qc-filters()

   #+RESULTS:
   :RESULTS:
   # Out[9]:
   :END:

   Read the UMI matrix.

   #+CALL: read-umi()

   #+RESULTS:
   :RESULTS:
   # Out[10]:
   :END:

   Fisher's index of dispersion is defined as \(V[x] / E[x]\). The Fano factor
   is Fisher's index of dispersion over a fixed window (in our case, the total
   number of reads).

   Compute the sample Fano factor of log CPM per individual, then normalize.

   #+BEGIN_SRC ipython
     sample_fano = (cpm(umi)
                    .mask(umi == 0)
                    .groupby(annotation['chip_id'].values, axis=1)
                    .agg(lambda x: np.var(x, axis=1) / (np.mean(x, axis=1)))
                    .loc[num_individuals_pass >= 50,keep_inds]
                    .transform(lambda x: (x - x.mean()) / x.std(), axis=1)
                    .apply(qqnorm, axis=0))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[85]:
   :END:

   Write out the [[https://qtltools.github.io/qtltools/pages/input_files.html][phenotype file]] for ~qtltools~. Hold out even chromosomes while
   optimizing the power to detect eQTLs.

   #+BEGIN_SRC ipython
     write_pheno_file(sample_fano, gene_info, '/scratch/midway2/aksarkar/singlecell/scqtl-mapping/sample_fano.bed', holdout=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[86]:
   :END:

   Index the phenotype file.

   #+CALL: tabix(input="sample_fano.bed") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 46254938

   Compute principal components and write out the covariate file.

   #+BEGIN_SRC ipython
     covars = pd.DataFrame(skd.PCA(n_components=2).fit(sample_fano).components_, columns=sample_fano.columns)
     covars.index.name = 'id'
     covars.to_csv('/scratch/midway2/aksarkar/singlecell/scqtl-mapping/sample-fano-covars.txt', sep='\t')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[87]:
   :END:

   Run ~qtltools~.

   #+CALL: qtltools(pheno="sample_fano", geno="/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz", op="--cov sample-fano-covars.txt --window 100000 --permute 10000") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 46254942

   Read the output.

   #+BEGIN_SRC ipython
     sample_fano_qtls = read_qtltools_output('scqtl-mapping/sample_fano')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[88]:
   :END:

   Check the beta approximation to the permutation p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/sample-fano-qtl-beta-approx.png
     plot_approx_permutation(sample_fano_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[89]:
   [[file:figure/qtl-mapping.org/sample-fano-qtl-beta-approx.png]]
   :END:

   Plot a QQ plot of the adjusted p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/sample-fano-qtl-qq.png
     qqplot(sample_fano_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[90]:
   [[file:figure/qtl-mapping.org/sample-fano-qtl-qq.png]]
   :END:

   Take QTLs at FDR 10%.

   #+BEGIN_SRC ipython
     sample_fano_qtls['fdr_pass'].sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[91]:
   : 1
   :END:

* Analysis using ZINB
** Call eQTLs

   Estimate the moments of latent gene expression. We have:

   \[ \mathbb{E}[\lambda_{ijk}] = (1 - \pi_{ik}) \mu_{ik} \]

   \[ \mathbb{V}[\lambda_{ijk}] = (1 - \pi_{ik}) \phi_{ik}^{-1} + \pi_{ik} (1 -
   \pi_{ik}) \mu_{ik}^2 \]

   #+NAME: point-gamma-moments
   #+BEGIN_SRC ipython
     log_mu = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-mu.txt.gz', index_col=0, sep=' ')
     log_phi = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-phi.txt.gz', index_col=0, sep=' ')
     logodds = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-logodds.txt.gz', index_col=0, sep=' ')
     for x in (log_mu, log_phi, logodds):
       del x['NA18498']

     # Important: log(sigmoid(x)) = -softplus(-x)
     mean_by_ind = np.exp(log_mu - np.log1p(np.exp(logodds)))
     variance_by_ind = np.exp(2 * log_mu + log_phi - np.log1p(np.exp(logodds))) + np.exp(-np.log1p(np.exp(logodds)) - np.log1p(np.exp(-logodds)) + 2 * log_mu)
   #+END_SRC

   #+RESULTS: point-gamma-moments
   :RESULTS:
   # Out[11]:
   :END:

   Normalize the mean matrix analagous to the bulk data.

   #+BEGIN_SRC ipython
     mean = (mean_by_ind
             .transform(lambda x: (x - x.mean()) / x.std(), axis=1)
             .apply(qqnorm, axis=0))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[12]:
   :END:

   Compute principal components of the mean matrix.

   #+BEGIN_SRC ipython
    covars = pd.DataFrame(skd.PCA(n_components=10).fit(mean).components_, columns=mean.columns)
    covars.index.name = 'id'
    covars.to_csv('/scratch/midway2/aksarkar/singlecell/scqtl-mapping/mean-covars.txt', sep='\t')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[13]:
   :END:

   Write out the [[https://qtltools.github.io/qtltools/pages/input_files.html][phenotype file]] for ~qtltools~. Hold out even chromosomes while
   optimizing the power to detect eQTLs.

   #+BEGIN_SRC ipython
     write_pheno_file(mean, gene_info, '/scratch/midway2/aksarkar/singlecell/scqtl-mapping/mean.bed', holdout=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[14]:
   :END:

   Index the phenotype file.

   #+CALL: tabix(input="mean.bed") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 47239121

   Run ~qtltools~.

   #+CALL: qtltools(pheno="mean", geno="/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz", op="--cov mean-covars.txt --window 100000 --permute 10000") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 47239327

   Read the output.

   #+BEGIN_SRC ipython
     mean_qtls = read_qtltools_output('scqtl-mapping/mean')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[16]:
   :END:

   Check the beta approximation to the permutation p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/mean-qtl-beta-approx.png
     plot_approx_permutation(mean_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[17]:
   [[file:figure/qtl-mapping.org/mean-qtl-beta-approx.png]]
   :END:

   Plot a QQ plot of the adjusted p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/mean-qtl-qq.png
     qqplot(mean_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[18]:
   [[file:figure/qtl-mapping.org/mean-qtl-qq.png]]
   :END:

   Take QTLs at FDR 10%.

   #+BEGIN_SRC ipython
     mean_qtls['fdr_pass'].sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[19]:
   : 241
   :END:

** Fit multiplicative model

   Estimate the moments of latent gene expression. We have:

   \[ \mathbb{E}[\lambda_{ijk}] = (1 - \pi_{ik}) \mu_{ik} \]

   \[ \mathbb{V}[\lambda_{ijk}] = (1 - \pi_{ik}) \phi_{ik}^{-1} + \pi_{ik} (1 -
   \pi_{ik}) \mu_{ik}^2 \]

   #+NAME: point-gamma-moments
   #+BEGIN_SRC ipython
     log_mu = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-mu.txt.gz', index_col=0, sep=' ')
     log_phi = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-phi.txt.gz', index_col=0, sep=' ')
     logodds = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-logodds.txt.gz', index_col=0, sep=' ')
     for x in (log_mu, log_phi, logodds):
       del x['NA18498']

     # Important: log(sigmoid(x)) = -softplus(-x)
     mean_by_ind = np.exp(log_mu - np.log1p(np.exp(logodds)))
     variance_by_ind = np.exp(2 * log_mu + log_phi - np.log1p(np.exp(logodds))) + np.exp(-np.log1p(np.exp(logodds)) - np.log1p(np.exp(-logodds)) + 2 * log_mu)
   #+END_SRC

   #+RESULTS: point-gamma-moments
   :RESULTS:
   # Out[52]:
   :END:

   Normalize the mean matrix analagous to the bulk data.

   #+BEGIN_SRC ipython
     multmean = (np.log(mean_by_ind)
             .transform(lambda x: (x - x.mean()) / x.std(), axis=1)
             .apply(qqnorm, axis=0))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[12]:
   :END:

   Compute principal components of the mean matrix.

   #+BEGIN_SRC ipython
    covars = pd.DataFrame(skd.PCA(n_components=10).fit(multmean).components_, columns=multmean.columns)
    covars.index.name = 'id'
    covars.to_csv('/scratch/midway2/aksarkar/singlecell/scqtl-mapping/multmean-covars.txt', sep='\t')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[13]:
   :END:

   Write out the [[https://qtltools.github.io/qtltools/pages/input_files.html][phenotype file]] for ~qtltools~. Hold out even chromosomes while
   optimizing the power to detect eQTLs.

   #+BEGIN_SRC ipython
     write_pheno_file(multmean, gene_info, '/scratch/midway2/aksarkar/singlecell/scqtl-mapping/multmean.bed', holdout=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[14]:
   :END:

   Index the phenotype file.

   #+CALL: tabix(input="multmean.bed") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 48837662

   Run ~qtltools~.

   #+CALL: qtltools(pheno="multmean", geno="/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz", op="--cov multmean-covars.txt --window 100000 --permute 10000") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 48837665

   Read the output.

   #+BEGIN_SRC ipython
     multmean_qtls = read_qtltools_output('scqtl-mapping/mean')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[15]:
   :END:

   Check the beta approximation to the permutation p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/multmean-qtl-beta-approx.png
     plot_approx_permutation(multmean_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[16]:
   [[file:figure/qtl-mapping.org/multmean-qtl-beta-approx.png]]
   :END:

   Plot a QQ plot of the adjusted p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/multmean-qtl-qq.png
     qqplot(multmean_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[17]:
   [[file:figure/qtl-mapping.org/multmean-qtl-qq.png]]
   :END:

   Take QTLs at FDR 10%.

   #+BEGIN_SRC ipython
     multmean_qtls['fdr_pass'].sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[18]:
   : 241
   :END:

** Call \phi-QTLs

   Normalize the phenotype matrix.

   #+BEGIN_SRC ipython
     log_phi = log_phi.transform(lambda x: (x - x.mean()) / x.std(), axis=1).apply(qqnorm, axis=1)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[64]:
   :END:

   Write out the phenotype file.

   #+BEGIN_SRC ipython
     write_pheno_file(log_phi, gene_info, holdout=False, output_file='/scratch/midway2/aksarkar/singlecell/scqtl-mapping/log_phi.bed')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[65]:
   :END:

   Index the phenotype file.

   #+CALL: tabix(input="log_phi.bed") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 47553002

   Run ~qtltools~.

   #+CALL: qtltools(pheno="log_phi", geno="/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz", op="--window 100000 --permute 10000") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 46547242

   Read the output.

   #+BEGIN_SRC ipython
    log_phi_qtls = read_qtltools_output('scqtl-mapping/log_phi')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[80]:
   :END:

   Check the beta approximation to the permutation p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/phi-qtl-beta-approx.png
    plot_approx_permutation(log_phi_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[81]:
   [[file:figure/qtl-mapping.org/phi-qtl-beta-approx.png]]
   :END:

   Plot a QQ plot of the adjusted p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/phi-qtl-qq.png
    qqplot(log_phi_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[82]:
   [[file:figure/qtl-mapping.org/phi-qtl-qq.png]]
   :END:

   Take QTLs at FDR 10%.

   #+BEGIN_SRC ipython
     log_phi_qtls['fdr_pass'].sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[83]:
   : 0
   :END:

** Call \pi-QTLs                                                   :noexport:

   For each gene \(k\), fit a linear model:

   \[ \mathrm{logit}(\pi_k) = X\beta + \epsilon \]

   Read the estimated parameters. Exclude individuals with fewer than 50 cells.

   #+BEGIN_SRC ipython
     logodds = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-logodds.txt.gz', index_col=0, sep=' ')
     del logodds['NA18498']
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[84]:
   :END:

   Normalize the log odds matrix.

   #+BEGIN_SRC ipython
     logodds = logodds.loc[(logodds.agg(np.std, axis=1) > 0).values]
     logodds = logodds.transform(lambda x: (x - x.mean()) / x.std(), axis=1).apply(qqnorm, axis=1)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[85]:
   :END:

   Write out the phenotype file.

   #+BEGIN_SRC ipython
     write_pheno_file(logodds, gene_info, holdout=False, output_file='/scratch/midway2/aksarkar/singlecell/scqtl-mapping/logodds.bed')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[86]:
   :END:

   Index the phenotype file.

   #+CALL: tabix(input="logodds.bed") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 46547348

   Run ~qtltools~.

   #+CALL: qtltools(pheno="logodds", geno="/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz", op="--window 100000 --permute 10000") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 46547349

   Read the output.

   #+BEGIN_SRC ipython
     logodds_qtls = read_qtltools_output('scqtl-mapping/logodds')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[87]:
   :END:

   Check the beta approximation to the permutation p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/logodds-qtl-beta-approx.png
     plot_approx_permutation(logodds_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[88]:
   [[file:figure/qtl-mapping.org/logodds-qtl-beta-approx.png]]
   :END:

   Plot a QQ plot of the adjusted p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/logodds-qtl-qq.png
     qqplot(logodds_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[89]:
   [[file:figure/qtl-mapping.org/logodds-qtl-qq.png]]
   :END:

   Take QTLs at FDR 10%.

   #+BEGIN_SRC ipython
     logodds_qtls['fdr_pass'].sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[90]:
   : 4
   :END:

** Call mean-QTLs                                                  :noexport:

   We have \(r_{ijk} \sim g_{ijk}(\cdot)\), where \(g\) is the ZINB density [[file:zinb.org][as
   previously defined]].

   Read the estimated parameters.

   #+BEGIN_SRC ipython
     log_mu = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-mu.txt.gz', index_col=0, sep=' ')
     log_phi = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-phi.txt.gz', index_col=0, sep=' ')
     logodds = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-logodds.txt.gz', index_col=0, sep=' ')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[93]:
   :END:

   Estimate the moments (on the scale of molecules).

   #+BEGIN_SRC ipython
     annotations = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-annotation.txt')
     annotations = annotations.loc[keep_samples.values.ravel()]
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[95]:
   :END:

   #+CALL: recode-impl()

   #+RESULTS:
   :RESULTS:
   # Out[97]:
   :END:

   #+BEGIN_SRC ipython
     onehot = recode(annotations, 'chip_id')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[98]:
   :END:

   #+CALL: zinb-moments()

   #+RESULTS:
   :RESULTS:
   # Out[99]:
   :END:

   #+CALL: zinb-mix-moments()

   #+RESULTS:
   :RESULTS:
   # Out[100]:
   :END:

   Normalize the mean matrix.

   #+BEGIN_SRC ipython
     mean = pd.DataFrame(mean_by_ind.T, index=log_mu.index, columns=log_mu.columns)
     del mean['NA18498']
     mean = mean.transform(lambda x: (x - x.mean()) / x.std(), axis=1).apply(qqnorm, axis=0)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[101]:
   :END:

   Compute principal components of the mean matrix.

   #+BEGIN_SRC ipython
     covars = pd.DataFrame(skd.PCA(n_components=10).fit(mean).components_, columns=mean.columns)
     covars.index.name = 'id'
     covars.to_csv('/scratch/midway2/aksarkar/singlecell/scqtl-mapping/mean-covars.txt', sep='\t')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[102]:
   :END:

   Write out the [[https://qtltools.github.io/qtltools/pages/input_files.html][phenotype file]] for ~qtltools~. Hold out even chromosomes while
   optimizing the power to detect eQTLs.

   #+BEGIN_SRC ipython
     write_pheno_file(mean, gene_info, '/scratch/midway2/aksarkar/singlecell/scqtl-mapping/mean.bed', holdout=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[103]:
   :END:

   Index the phenotype file.

   #+CALL: tabix(input="mean.bed") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 46547546

   Run ~qtltools~.

   #+CALL: qtltools(pheno="mean", geno="/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz", op="--cov mean-covars.txt --window 100000 --permute 10000") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 46547547

   Read the output.

   #+BEGIN_SRC ipython
     mean_qtls = read_qtltools_output('scqtl-mapping/mean')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[104]:
   :END:

   Check the beta approximation to the permutation p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/mean-qtl-beta-approx.png
     plot_approx_permutation(mean_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[105]:
   [[file:figure/qtl-mapping.org/mean-qtl-beta-approx.png]]
   :END:

   Plot a QQ plot of the adjusted p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/mean-qtl-qq.png
     qqplot(mean_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[106]:
   [[file:figure/qtl-mapping.org/mean-qtl-qq.png]]
   :END:

   Take QTLs at FDR 10%.

   #+BEGIN_SRC ipython
     mean_qtls['fdr_pass'].sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[107]:
   : 217
   :END:

** Call variance-QTLs

   Normalize the variance matrix. Restrict to genes with \(\ln\mu > 0.5\) in at
   least half the individuals.

   #+BEGIN_SRC ipython
     variance = (variance_by_ind
                 .transform(lambda x: (x - x.mean()) / x.std(), axis=1)
                 .apply(qqnorm, axis=0))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[81]:
   :END:

   Compute principal components of the variance matrix.

   #+BEGIN_SRC ipython
     covars = pd.DataFrame(skd.PCA(n_components=2).fit(variance).components_, columns=variance.columns)
     covars.index.name = 'id'
     covars.to_csv('/scratch/midway2/aksarkar/singlecell/scqtl-mapping/variance-covars.txt', sep='\t')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[82]:
   :END:

   Write out the [[https://qtltools.github.io/qtltools/pages/input_files.html][phenotype file]] for ~qtltools~.

   #+BEGIN_SRC ipython
     write_pheno_file(variance, gene_info, '/scratch/midway2/aksarkar/singlecell/scqtl-mapping/variance.bed', holdout=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[83]:
   :END:

   Index the phenotype file.

   #+CALL: tabix(input="variance.bed") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 47257064

   Run ~qtltools~.

   #+CALL: qtltools(pheno="variance", geno="/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz", op="--cov variance-covars.txt --window 100000 --permute 10000") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 47257067

   Read the output.

   #+BEGIN_SRC ipython
     variance_qtls = read_qtltools_output('scqtl-mapping/variance')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[84]:
   :END:

   Check the beta approximation to the permutation p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/variance-qtl-beta-approx.png
     plot_approx_permutation(variance_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[85]:
   [[file:figure/qtl-mapping.org/variance-qtl-beta-approx.png]]
   :END:

   Plot a QQ plot of the adjusted p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/variance-qtl-qq.png
     qqplot(variance_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[86]:
   [[file:figure/qtl-mapping.org/variance-qtl-qq.png]]
   :END:

   Take QTLs at FDR 10%.

   #+BEGIN_SRC ipython
     variance_qtls['fdr_pass'].sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[87]:
   : 14
   :END:

** Call CV-QTLs

   Estimate the coefficient of variation.

   #+BEGIN_SRC ipython
     cv = np.sqrt(variance_by_ind) / mean_by_ind
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[12]:
   :END:

   Normalize the CV matrix.

   #+BEGIN_SRC ipython
     cv = cv.transform(lambda x: (x - x.mean()) / x.std(), axis=1).apply(qqnorm, axis=0)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[13]:
   :END:

   Write out the [[https://qtltools.github.io/qtltools/pages/input_files.html][phenotype file]] for ~qtltools~. Hold out even chromosomes while
   optimizing the power to detect eQTLs.

   #+BEGIN_SRC ipython
     write_pheno_file(cv, gene_info, '/scratch/midway2/aksarkar/singlecell/scqtl-mapping/cv.bed', holdout=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[14]:
   :END:

   Index the phenotype file.

   #+CALL: tabix(input="cv.bed") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 47253627

   Run ~qtltools~.

   #+CALL: qtltools(pheno="cv", geno="/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz", op="--window 100000 --permute 10000") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 47253630

   Read the output.

   #+BEGIN_SRC ipython
     cv_qtls = read_qtltools_output('scqtl-mapping/cv')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[15]:
   :END:

   Check the beta approximation to the permutation p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/cv-qtl-beta-approx.png
     plot_approx_permutation(cv_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[16]:
   [[file:figure/qtl-mapping.org/cv-qtl-beta-approx.png]]
   :END:

   Plot a QQ plot of the adjusted p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/cv-qtl-qq.png
     qqplot(cv_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[17]:
   [[file:figure/qtl-mapping.org/cv-qtl-qq.png]]
   :END:

   Take QTLs at FDR 10%.

   #+BEGIN_SRC ipython
     cv_qtls['fdr_pass'].sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[18]:
   : 2
   :END:

** Call Fano-QTLs

   Estimate the coefficient of variation.

   #+BEGIN_SRC ipython
     fano = variance_by_ind / mean_by_ind
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[19]:
   :END:

   Normalize the Fano matrix.

   #+BEGIN_SRC ipython
     fano = fano.transform(lambda x: (x - x.mean()) / x.std(), axis=1).apply(qqnorm, axis=0)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[20]:
   :END:

   Write out the [[https://qtltools.github.io/qtltools/pages/input_files.html][phenotype file]] for ~qtltools~. Hold out even chromosomes while
   optimizing the power to detect eQTLs.

   #+BEGIN_SRC ipython
     write_pheno_file(fano, gene_info, '/scratch/midway2/aksarkar/singlecell/scqtl-mapping/fano.bed', holdout=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[21]:
   :END:

   Index the phenotype file.

   #+CALL: tabix(input="fano.bed") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 47253759

   Run ~qtltools~.

   #+CALL: qtltools(pheno="fano", geno="/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz", op="--window 100000 --permute 10000") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 47253761

   Read the output.

   #+BEGIN_SRC ipython
     fano_qtls = read_qtltools_output('scqtl-mapping/fano')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[22]:
   :END:

   Check the beta approximation to the permutation p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/fano-qtl-beta-approx.png
     plot_approx_permutation(fano_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[23]:
   [[file:figure/qtl-mapping.org/fano-qtl-beta-approx.png]]
   :END:

   Plot a QQ plot of the adjusted p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/fano-qtl-qq.png
     qqplot(fano_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[24]:
   [[file:figure/qtl-mapping.org/fano-qtl-qq.png]]
   :END:

   Take QTLs at FDR 10%.

   #+BEGIN_SRC ipython
     fano_qtls['fdr_pass'].sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[25]:
   : 0
   :END:

** Call dispersion QTLs via departure from genome-wide dispersion  :noexport:

   We previously showed that most genes have equal over-dispersion across the
   genome. Therefore, we define a new phenotype as the difference from this
   theoretical relationship and map QTLs for it.

   #+CALL: qc-filters()

   #+RESULTS:
   :RESULTS:
   # Out[258]:
   :END:

   #+BEGIN_SRC ipython
     resid = variance / (mean + 1e-8) - 1 - mean * 0.24
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[259]:
   :END:

   Normalize the resid matrix.

   #+BEGIN_SRC ipython
     resid = resid.transform(lambda x: (x - x.mean()) / x.std(), axis=1)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[233]:
   :END:

   Write out the [[https://qtltools.github.io/qtltools/pages/input_files.html][phenotype file]] for ~qtltools~. Hold out even chromosomes while
   optimizing the power to detect eQTLs.

   #+BEGIN_SRC ipython
     write_pheno_file(resid, gene_info, '/scratch/midway2/aksarkar/singlecell/scqtl-mapping/resid.bed', holdout=True)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[234]:
   :END:

   Index the phenotype file.

   #+CALL: tabix(input="resid.bed") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping
   #+RESULTS:
   : Submitted batch job 45801937

   Run ~qtltools~.

   #+CALL: qtltools(pheno="resid", geno="/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz", op="--window 100000 --permute 10000") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 45801942

   Read the output.

   #+BEGIN_SRC ipython
     resid_qtls = read_qtltools_output('scqtl-mapping/resid')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[235]:
   :END:

   Check the beta approximation to the permutation p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/resid-qtl-beta-approx.png
     plot_approx_permutation(resid_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[236]:
   [[file:figure/qtl-mapping.org/resid-qtl-beta-approx.png]]
   :END:

   Plot a QQ plot of the adjusted p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/resid-qtl-qq.png
     qqplot(resid_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[237]:
   [[file:figure/qtl-mapping.org/resid-qtl-qq.png]]
   :END:

   Take QTLs at FDR 10%.

   #+BEGIN_SRC ipython
     resid_qtls['fdr_pass'].sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[238]:
   : 0
   :END:

* Explain away variance QTLs
** Call variance-QTLs

   Regress out mean from variance.

   #+CALL: point-gamma-moments()

   #+RESULTS:
   :RESULTS:
   # Out[11]:
   :END:

   #+BEGIN_SRC ipython
     M = mean_by_ind.transform(lambda x: (x - x.mean()) / x.std(), axis=1)
     V = variance_by_ind.transform(lambda x: (x - x.mean()) / x.std(), axis=1)
     beta = (M * V).sum(axis=1) / M.shape[1]
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[12]:
   :END:

   Normalize the variance matrix.

   #+BEGIN_SRC ipython
     resid = ((V - M.mul(beta, axis='index'))
                 .transform(lambda x: (x - x.mean()) / x.std(), axis=1)
                 .apply(qqnorm, axis=0))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[13]:
   :END:

   Compute principal components of the resid matrix.

   #+BEGIN_SRC ipython
     covars = pd.DataFrame(skd.PCA(n_components=2).fit(resid).components_, columns=resid.columns)
     covars.index.name = 'id'
     covars.to_csv('/scratch/midway2/aksarkar/singlecell/scqtl-mapping/resid-covars.txt', sep='\t')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[14]:
   :END:

   Write out the [[https://qtltools.github.io/qtltools/pages/input_files.html][phenotype file]] for ~qtltools~.

   #+BEGIN_SRC ipython
     write_pheno_file(resid, gene_info, '/scratch/midway2/aksarkar/singlecell/scqtl-mapping/resid.bed', holdout=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[15]:
   :END:

   Index the phenotype file.

   #+CALL: tabix(input="resid.bed") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 47483170

   Run ~qtltools~.

   #+CALL: qtltools(pheno="resid", geno="/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz", op="--cov resid-covars.txt --window 100000 --permute 10000") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 47483181

   Read the output.

   #+BEGIN_SRC ipython
     resid_qtls = read_qtltools_output('scqtl-mapping/resid')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[16]:
   :END:

   Check the beta approximation to the permutation p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/resid-qtl-beta-approx.png
     plot_approx_permutation(resid_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[17]:
   [[file:figure/qtl-mapping.org/resid-qtl-beta-approx.png]]
   :END:

   Plot a QQ plot of the adjusted p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/resid-qtl-qq.png
     qqplot(resid_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[18]:
   [[file:figure/qtl-mapping.org/resid-qtl-qq.png]]
   :END:

   Take QTLs at FDR 10%.

   #+BEGIN_SRC ipython
     resid_qtls['fdr_pass'].sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[19]:
   : 0
   :END:

** Call CV-QTLs

   Estimate the coefficient of variation.

   #+BEGIN_SRC ipython
     cv = np.sqrt(variance_by_ind) / mean_by_ind
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[20]:
   :END:

   Regress out mean from variance.

   #+BEGIN_SRC ipython
     M = mean_by_ind.transform(lambda x: (x - x.mean()) / x.std(), axis=1)
     V = cv.transform(lambda x: (x - x.mean()) / x.std(), axis=1)
     beta = (M * V).sum(axis=1) / M.shape[1]
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[21]:
   :END:

   Normalize the CV matrix.

   #+BEGIN_SRC ipython
     cv_resid = ((V - M.mul(beta, axis='index'))
                 .transform(lambda x: (x - x.mean()) / x.std(), axis=1)
                 .apply(qqnorm, axis=0))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[22]:
   :END:

   Write out the [[https://qtltools.github.io/qtltools/pages/input_files.html][phenotype file]] for ~qtltools~. Hold out even chromosomes while
   optimizing the power to detect eQTLs.

   #+BEGIN_SRC ipython
     write_pheno_file(cv_resid, gene_info, '/scratch/midway2/aksarkar/singlecell/scqtl-mapping/cv_resid.bed', holdout=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[23]:
   :END:

   Index the phenotype file.

   #+CALL: tabix(input="cv_resid.bed") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 47483587

   Run ~qtltools~.

   #+CALL: qtltools(pheno="cv_resid", geno="/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz", op="--window 100000 --permute 10000") :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping

   #+RESULTS:
   : Submitted batch job 47483612

   Read the output.

   #+BEGIN_SRC ipython
     cv_resid_qtls = read_qtltools_output('scqtl-mapping/cv_resid')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[24]:
   :END:

   Check the beta approximation to the permutation p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/cv_resid-qtl-beta-approx.png
     plot_approx_permutation(cv_resid_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[25]:
   [[file:figure/qtl-mapping.org/cv_resid-qtl-beta-approx.png]]
   :END:

   Plot a QQ plot of the adjusted p-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/cv_resid-qtl-qq.png
     qqplot(cv_resid_qtls)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[26]:
   [[file:figure/qtl-mapping.org/cv_resid-qtl-qq.png]]
   :END:

   Take QTLs at FDR 10%.

   #+BEGIN_SRC ipython
     cv_resid_qtls['fdr_pass'].sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[27]:
   : 0
   :END:

* Write out the QTLs

  #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/singlecell/reproduce-yang
    cp covars.txt bulk-covars.txt
    cat test-qtl.*.txt | awk 'BEGIN {print "gene", "chr", "start", "end", "strand", "num_vars", "distance", "id", "var_chr", "var_start", "var_end", "df", "dummy", "a", "b", "p_nominal", "beta", "p_empirical", "p_beta"} {print}' | gzip >bulk.txt.gz
    cp test.bed.gz /project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-mapping/bulk.bed.gz
    cp bulk-covars.txt bulk.txt.gz /project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-mapping/
  #+END_SRC

  #+RESULTS:

  #+BEGIN_SRC sh :dir /scratch/midway2/aksarkar/singlecell/scqtl-mapping
    sbatch --partition=broadwl
    #!/bin/bash
    cat >.rsync-filter <<EOF
    + */
    + *.bed.gz
    + *.txt.gz
    + *covars*
    - *
    EOF
    function z { test $1-qtl.1.txt -nt $1.txt.gz && cat $1-qtl.*.txt | awk 'BEGIN {print "gene", "chr", "start", "end", "strand", "num_vars", "distance", "id", "var_chr", "var_start", "var_end", "df", "dummy", "a", "b", "p_nominal", "beta", "p_empirical", "p_beta"} {print}' | gzip >$1.txt.gz; }
    export -f z
    parallel -j1 z ::: cv fano mean multmean variance resid cv_resid
    rsync -FFau . /project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-mapping/
  #+END_SRC

  #+RESULTS:
  : Submitted batch job 48837869

* QTL overlap
** Replication rates

   Read the QTLs and normalized expression matrices.

   #+BEGIN_SRC ipython
     prefix = '/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-mapping/'
     qtls = {pheno: [pd.read_table('{}/{}.txt.gz'.format(prefix, pheno), sep=' '),
                     pd.read_table('{}/{}.bed.gz'.format(prefix, pheno)).set_index('pid').filter(like='NA', axis='columns')]
             for pheno in ['bulk', 'mean', 'multmean', 'variance', 'cv', 'fano']}
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[22]:
   :END:

  Read covariates.

  #+BEGIN_SRC ipython
    base = pathlib.Path('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-mapping/')
    covars = [pd.read_table(base / '{}-covars.txt'.format(f), sep='\s+', engine='python', index_col=0)
              for f in ('bulk', 'mean', 'multmean', 'variance')]
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[23]:
  :END:

   The bulk QTL gene names need to be munged.

   #+BEGIN_SRC ipython
     qtls['bulk'][0]['gene'] = qtls['bulk'][0]['gene'].apply(lambda x: x.split('.')[0])
     qtls['bulk'][1].index = [x.split('.')[0] for x in qtls['bulk'][1].index]
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[24]:
   :END:

   Compute the gene-level FDR filter.

   #+BEGIN_SRC ipython
     for k in qtls:
       qtls[k][0]['fdr_pass'] = bh(qtls[k][0]['p_beta']) < 0.1
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[28]:
   :END:

   Estimate replication rates for mean QTLs.

   #+BEGIN_SRC ipython
    pd.options.display.float_format = '{:.3g}'.format
    pairwise_replication(
      qtls,
      phenos=['bulk', 'mean', 'multmean'],
      ticks=['Bulk', 'Mean', 'log mean'],
      covars=covars[:3])
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[31]:
   #+BEGIN_EXAMPLE
     Bulk  Mean  log mean
     Bulk       100    80      79.4
     Mean        82   100       100
     log mean  83.5   100       100
   #+END_EXAMPLE
   :END:

   Estimate the rate at which variance QTLs replicate as mean QTLs (and vice versa).

   #+BEGIN_SRC ipython
    pairwise_replication(qtls,
                         phenos=['log_mu', 'variance', 'cv', 'fano'],
                         ticks=['$(1 - \pi)\mu$', 'Variance', 'CV', 'Fano'],
                         covars=[covars[2], covars[4], None, None])
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[140]:
   #+BEGIN_EXAMPLE
     $(1 - \pi)\mu$  Variance   CV  Fano
     $(1 - \pi)\mu$             100      99.6 78.6    91
     Variance                   100       100 73.5   100
     CV                         100       100  100   100
     Fano                       100       100 64.3   100
   #+END_EXAMPLE
   :END:

** Relationship of \(p\)-values, effect sizes, and expression levels

   Compute relative abundance per individual.

   #+BEGIN_SRC ipython
     log_mu = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design2/zi2-log-mu.txt.gz', index_col=0, sep=' ')
     logodds = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design2/zi2-logodds.txt.gz', index_col=0, sep=' ')

     abundance = log_mu - np.log1p(np.exp(logodds))
     abundance -= sp.logsumexp(abundance, axis=0)
     abundance /= np.log(2)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[144]:
   :END:

   Investigate whether variance QTL \(p\)-values are correlated with relative
   abundance.

   #+BEGIN_SRC ipython
     variance_qtls = qtls['variance'][0]
     thresh_pass = variance_qtls['p_beta'] < 1e-2
     var_qtl_abundance, var_qtl_stats = abundance.align(variance_qtls[thresh_pass].set_index('gene'), axis='index', join='inner')
     fdr_pass = var_qtl_stats['fdr_pass']
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[145]:
   :END:

   Count how many variance QTLs have \(p < 10^{-2}\)

   #+BEGIN_SRC ipython
     thresh_pass.sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[146]:
   : 301
   :END:

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/var-qtl-vs-log-mu.png
     plt.clf()
     plt.errorbar(x=var_qtl_abundance.mean(axis=1), y=-np.log10(var_qtl_stats['p_beta']), xerr=var_qtl_abundance.std(axis=1), fmt='none', label=None, lw=1, ecolor='.8', zorder=-1)
     plt.scatter(x=var_qtl_abundance[fdr_pass].mean(axis=1), y=-np.log10(var_qtl_stats[fdr_pass]['p_beta']), c='r', s=4, label='FDR 10%')
     plt.scatter(x=var_qtl_abundance[~fdr_pass].mean(axis=1), y=-np.log10(var_qtl_stats[~fdr_pass]['p_beta']), c='k', s=4, label='p < 0.01')
     plt.legend(loc='upper left', frameon=False)
     plt.xlabel('$\log_2(\mathrm{relative\ abundance})$')
     _ = plt.ylabel('Variance QTL $-\log_{10}(p)$')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[147]:
   [[file:figure/qtl-mapping.org/var-qtl-vs-log-mu.png]]
   :END:

   Make sure our effect sizes match ~qtltools~.

   #+BEGIN_SRC ipython
     variance = qtls['variance'][1]
     Xv, Yv = extract_qtl_gene_pair(variance_qtls[thresh_pass], variance, dosages='/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz')
     Cv = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-mapping/variance-covars.txt', index_col=0)
     Cv = Cv.align(Xv, axis='columns', join='inner')[0]
     my_var_qtl_stats = replication_tests(Xv, Yv, Cv)
     my_var_qtl_stats.merge(variance_qtls, on='gene').apply(lambda x: abs(x['beta_x'] - x['beta_y']), axis=1).describe()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[148]:
   #+BEGIN_EXAMPLE
     count        301
     mean      0.0766
     std       0.0711
     min     0.000178
     25%       0.0234
     50%       0.0543
     75%        0.102
     max        0.377
     dtype: float64
   #+END_EXAMPLE
   :END:

   Look at the gene with max difference in estimated effect size.

   #+BEGIN_SRC ipython
     my_var_qtl_stats.iloc[my_var_qtl_stats.merge(variance_qtls, on='gene').apply(lambda x: abs(x['beta_x'] - x['beta_y']), axis=1).idxmax()]
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[149]:
   #+BEGIN_EXAMPLE
     beta              -1.12
     gene    ENSG00000145425
     p              1.38e-18
     se                0.127
     Name: 230, dtype: object
   #+END_EXAMPLE
   :END:

   Estimate standard errors via the bootstrap.

   #+BEGIN_SRC ipython
     var_qtl_stats['bootstrap_se'] = bootstrap_se(Xv, Yv, Cv)
     var_qtl_stats['se'] = my_var_qtl_stats.set_index('gene')['se']
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[150]:
   :END:

   Investigate whether analytic SEs are reasonable:

   #+BEGIN_SRC ipython
     var_qtl_stats['se'].describe()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[151]:
   #+BEGIN_EXAMPLE
     count      301
     mean    0.0521
     std     0.0344
     min     0.0137
     25%     0.0271
     50%     0.0405
     75%     0.0669
     max      0.186
     Name: se, dtype: float64
   #+END_EXAMPLE
   :END:
  
   #+BEGIN_SRC ipython
     var_qtl_stats['bootstrap_se'].describe()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[152]:
   #+BEGIN_EXAMPLE
     count      301
     mean     0.225
     std     0.0848
     min      0.113
     25%       0.17
     50%      0.203
     75%      0.253
     max      0.628
     Name: bootstrap_se, dtype: float64
   #+END_EXAMPLE
   :END:

   Plot analytic SEs against bootstrap SEs.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/var-qtl-se.png
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     plt.scatter(var_qtl_stats['se'], var_qtl_stats['bootstrap_se'], s=1, c='k')
     plt.plot([0, 1], [0, 1], c='r', ls=':', lw=1)
     plt.xlim([0, 1])
     plt.ylim([0, 1])
     plt.xlabel('Analytic SE')
     _ = plt.ylabel('Bootstrap SE')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[153]:
   [[file:figure/qtl-mapping.org/var-qtl-se.png]]
   :END:

   Compute \(z\)-scores using the bootstrap SEs.

   #+BEGIN_SRC ipython
     var_qtl_stats['z'] = var_qtl_stats['beta'] / var_qtl_stats['bootstrap_se']
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[154]:
   :END:

   Compute a \(z\)-score from the estimated effect size and the \(p\)-value.

   #+BEGIN_SRC ipython
     var_qtl_stats['isf_z'] = np.sign(var_qtl_stats['beta']) * np.sqrt(st.chi2(1).isf(var_qtl_stats['p_nominal']))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[155]:
   :END:

   Plot bootstrap \(z\)-scores against inverse-transformed \(z\)-scores.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/bootstrap-z-vs-nominal-p-inverse-cdf.png
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     plt.scatter(var_qtl_stats['z'], var_qtl_stats['isf_z'], s=3, c='k')
     plt.axhline(y=0, c='k', lw=1)
     plt.axvline(x=0, c='k', lw=1)
     plt.plot([-15, 15], [-15, 15], c='r', ls=':', lw=1)
     plt.xlim([-15, 15])
     plt.ylim([-15, 15])
     plt.xlabel('Bootstrap $z$-score')
     _ = plt.ylabel('Inverse CDF $z$-score')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[156]:
   [[file:figure/qtl-mapping.org/bootstrap-z-vs-nominal-p-inverse-cdf.png]]
   :END:

   Investigate whether \(z\)-scores based on bootstrap SEs agree with
   permutation \(p\)-values.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/var-qtl-z.png
     plt.clf()
     plt.scatter(-np.log10(var_qtl_stats[fdr_pass]['p_beta']), var_qtl_stats[fdr_pass]['z'], c='r', label='FDR 10%', s=4)
     plt.scatter(-np.log10(var_qtl_stats[~fdr_pass]['p_beta']), var_qtl_stats[~fdr_pass]['z'], c='k', label='p < 0.01', s=4)
     plt.xlabel('Variance QTL $-\log_{10}(p)$')
     plt.ylabel('Variance QTL $z$-score')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[157]:
   : Text(0,0.5,'Variance QTL $z$-score')
   [[file:figure/qtl-mapping.org/var-qtl-z.png]]
   :END:

   Investigate whether variance QTL \(z\)-scores are correlated with relative
   abundance.

   #+BEGIN_SRC ipython
     var_qtl_abundance = var_qtl_abundance.align(var_qtl_stats, axis='index', join='inner')[0]
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[158]:
   :END:

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/var-qtl-z-vs-log-mu.png
     plt.clf()
     plt.errorbar(x=var_qtl_abundance.mean(axis=1), y=var_qtl_stats['z'], xerr=var_qtl_abundance.std(axis=1), fmt='none', label=None, lw=1, ecolor='.8', zorder=1)
     plt.scatter(x=var_qtl_abundance[fdr_pass].mean(axis=1), y=var_qtl_stats[fdr_pass]['z'], c='r', s=2, label='FDR 10%', zorder=2)
     plt.scatter(x=var_qtl_abundance[~fdr_pass].mean(axis=1), y=var_qtl_stats[~fdr_pass]['z'], c='k', s=2, label='p < 0.01', zorder=2)
     plt.legend(frameon=False)
     plt.axhline(y=0, c='k')
     plt.xlabel('$\log_2(\mathrm{relative\ abundance})$')
     _ = plt.ylabel('Variance QTL $z$-score')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[159]:
   [[file:figure/qtl-mapping.org/var-qtl-z-vs-log-mu.png]]
   :END:

   Investigate whether variance QTL \(z\)-scores are correlated with mean QTL
   \(z\)-scores.

   #+BEGIN_SRC ipython
     Xm, Ym = extract_qtl_gene_pair(variance_qtls[thresh_pass], qtls['log_mu'][1], dosages='/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz')
     Cm = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-mapping/log_mu-covars.txt')
     Cm = Cm.align(Xm, axis='columns', join='inner')[0]
     var_qtl_stats['mean_beta'] = replication_tests(Xm, Ym, Cm).set_index('gene')['beta']
     var_qtl_stats['mean_z'] = var_qtl_stats['mean_beta'] / bootstrap_se(Xm, Ym, Cm)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[166]:
   :END:

   Plot variance QTL \(z\)-scores against pooled QTL \(z\)-scores.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/var-qtl-vs-mean-qtl.png
     lim = [-12, 12]
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     plt.plot(lim, lim, c='r', ls=':', lw=1)
     plt.scatter(var_qtl_stats[fdr_pass]['z'], var_qtl_stats[fdr_pass]['mean_z'], c='r', s=3, label='FDR 10%')
     plt.scatter(var_qtl_stats[~fdr_pass]['z'], var_qtl_stats[~fdr_pass]['mean_z'], c='k', s=3, label='$p < 10^{-2}$')
     plt.legend(frameon=False, markerscale=2, loc=(-.01, .75))
     plt.axhline(y=0, c='k', lw=1)
     plt.axvline(x=0, c='k', lw=1)
     plt.xlim(lim)
     plt.ylim(lim)
     plt.xlabel('vQTL $z$-score')
     _ = plt.ylabel('eQTL $z$-score')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[179]:
   [[file:figure/qtl-mapping.org/var-qtl-vs-mean-qtl.png]]
   :END:

   Compute the same in the other direction.

   #+BEGIN_SRC ipython 
     mean_qtl_stats = qtls['log_mu'][0]
     mean_qtl_stats = mean_qtl_stats[mean_qtl_stats['fdr_pass']].copy()
     X, Y = extract_qtl_gene_pair(mean_qtl_stats, qtls['log_mu'][1], dosages='/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz')
     z = mean_qtl_stats.set_index('gene')['beta'] / bootstrap_se(X, Y, Cm)

     X, Y = extract_qtl_gene_pair(mean_qtl_stats, qtls['variance'][1], dosages='/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz')
     vz = replication_tests(X, Y, Cv).set_index('gene')['beta'] / bootstrap_se(X, Y, Cv)

     Xb, Yb = extract_qtl_gene_pair(mean_qtl_stats, qtls['bulk'][1], dosages='/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz')
     Cb = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-mapping/bulk-covars.txt', sep=r'\s+', engine='python')
     Cb = Cb.align(Xb, axis='columns', join='inner')[0]
     bulk_z = replication_tests(Xb, Yb, Cb).set_index('gene')['beta'] / bootstrap_se(Xb, Yb, Cb)

     mean_qtl_stats = mean_qtl_stats.set_index('gene')
     mean_qtl_stats['z'] = z
     mean_qtl_stats['var_z'] = vz
     mean_qtl_stats['bulk_z'] = bulk_z
     mean_qtl_stats['var_fdr_pass'] = mean_qtl_stats.index.isin(var_qtl_stats['fdr_pass'].index)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[180]:
   :END:

   Plot mean vs. variance \(z\)-scores at eQTL SNP-gene pairs.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/mean-qtl-vs-var-qtl.png
     lim = [-12, 12]
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     plt.plot(lim, lim, c='r', ls=':', lw=1)
     plt.scatter(mean_qtl_stats.loc[mean_qtl_stats['var_fdr_pass'], 'var_z'],
                 mean_qtl_stats.loc[mean_qtl_stats['var_fdr_pass'], 'z'], c='r',
                 s=3, label='vQTL')
     plt.scatter(mean_qtl_stats.loc[~mean_qtl_stats['var_fdr_pass'], 'var_z'],
                 mean_qtl_stats.loc[~mean_qtl_stats['var_fdr_pass'], 'z'], c='k',
                 s=3, label='Not vQTL')
     plt.legend(frameon=False, markerscale=2, loc=(-.01, .75))
     plt.axhline(y=0, c='k', lw=1)
     plt.axvline(x=0, c='k', lw=1)
     plt.xlim(lim)
     plt.ylim(lim)
     plt.xlabel('vQTL $z$-score')
     _ = plt.ylabel('eQTL $z$-score')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[184]:
   [[file:figure/qtl-mapping.org/mean-qtl-vs-var-qtl.png]]
   :END:

   Plot single cell eQTL \(z\)-scores against bulk eQTL \(z\)-scores.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/bulk-qtl-vs-mean-qtl.png
     lim = [-12, 12]
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     plt.plot(lim, lim, c='r', ls=':', lw=1)
     plt.scatter(mean_qtl_stats['z'], mean_qtl_stats['bulk_z'], c='k', s=3)
     plt.axhline(y=0, c='k', lw=1)
     plt.axvline(x=0, c='k', lw=1)
     plt.xlim(lim)
     plt.ylim(lim)
     plt.xlabel('Single cell eQTL $z$-score')
     _ = plt.ylabel('Bulk eQTL $z$-score')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[185]:
   [[file:figure/qtl-mapping.org/bulk-qtl-vs-mean-qtl.png]]
   :END:

** Joint distribution of summary statistics

   Read the nominal summary statistics.

   #+BEGIN_SRC ipython
     stats = {x: pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/power/{}.txt.gz'.format(x), index_col=0)
              for x in ('bulk', 'mean', 'variance')}
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[92]:
   :END:

   Compute \(z\)-scores.

   #+BEGIN_SRC ipython
     for k in stats:
       stats[k]['z'] = stats[k]['beta'] / stats[k]['se']
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[93]:
   :END:

   Munge the bulk gene names.

   #+BEGIN_SRC ipython
     stats['bulk']['gene'] = [x.split('.')[0] for x in stats['bulk']['gene']]
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[94]:
   :END:

   Munge the index names.

   #+BEGIN_SRC ipython
     for k in stats:
       stats[k].index.name = 'id'
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[95]:
   :END:

   Plot the joint distribution of bulk/mean \(z\)-scores.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/bulk-sc-mean-joint-z.png
     J = stats['mean'].reset_index().merge(stats['bulk'].reset_index(), on=['id', 'gene'])[['z_x', 'z_y']]
     plt.clf()
     plt.gcf().set_size_inches(3, 4)
     plt.hexbin(J['z_x'], J['z_y'], gridsize=30, extent=[-10, 10, -10, 10], bins='log', cmap=colorcet.cm['gray_r'])
     plt.gca().set_aspect('equal')
     plt.xlim(-10, 10)
     plt.ylim(-10, 10)
     plt.plot(plt.ylim(), plt.ylim(), c='r', ls=':', lw=1)
     cb = plt.colorbar(orientation='horizontal')
     cb.set_label('$\log_{10}$ number of SNP-gene pairs')
     plt.xlabel('Single cell eQTL $z$-score')
     plt.ylabel('Bulk eQTL $z$-score')
     plt.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[98]:
   [[file:figure/qtl-mapping.org/bulk-sc-mean-joint-z.png]]
   :END:

   Plot single cell eQTL \(z\)-scores against bulk eQTL \(z\)-scores.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/bulk-qtl-vs-mean-qtl.png
     J = (stats['mean']
          .reset_index()
          .merge(qtls['mean'][0][qtls['mean'][0]['fdr_pass']], on=['id', 'gene'])
          [['id', 'gene', 'beta_x', 'se']]
          .merge(stats['bulk'].reset_index(), on=['id', 'gene']))
     lim = [-12, 12]
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     plt.plot(lim, lim, c='r', ls=':', lw=1)
     plt.scatter(J['beta_x'] / J['se_x'], J['beta'] / J['se_y'], c='k', s=3)
     plt.axhline(y=0, c='k', lw=1)
     plt.axvline(x=0, c='k', lw=1)
     plt.xlim(lim)
     plt.ylim(lim)
     plt.xlabel('Single cell eQTL $z$-score')
     _ = plt.ylabel('Bulk eQTL $z$-score')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[99]:
   [[file:figure/qtl-mapping.org/bulk-qtl-vs-mean-qtl.png]]
   :END:

   Plot the joint distribution of mean/variance \(z\)-scores.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/sc-mean-variance-joint-z.png
     J = stats['mean'].reset_index().merge(stats['variance'].reset_index(), on=['id', 'gene'])[['z_x', 'z_y']]
     plt.clf()
     plt.gcf().set_size_inches(3, 4)
     plt.hexbin(J['z_x'], J['z_y'], gridsize=30, extent=[-10, 10, -10, 10], bins='log', cmap=colorcet.cm['gray_r'])
     plt.gca().set_aspect('equal')
     plt.xlim(-12, 12)
     plt.ylim(-12, 12)
     plt.plot(plt.ylim(), plt.ylim(), c='r', ls='--', lw=1)
     cb = plt.colorbar(orientation='horizontal')
     cb.set_label('$\log_{10}$ number of SNP-gene pairs')
     plt.xlabel('Single cell eQTL $z$-score')
     plt.ylabel('vQTL $z$-score')
     plt.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[60]:
   [[file:figure/qtl-mapping.org/sc-mean-variance-joint-z.png]]
   :END:

   Plot the significant SC vQTL \(z\)-scores, and their corresponding
   \(z\)-score for the mean.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/var-qtl-vs-mean-qtl.png
     J = (stats['variance']
          .reset_index()
          .merge(qtls['variance'][0][qtls['variance'][0]['fdr_pass']], on=['id', 'gene'])
          [['id', 'gene', 'beta_x', 'se']]
          .merge(stats['mean'].reset_index(), on=['id', 'gene']))
     lim = [-12, 12]
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     plt.plot(lim, lim, c='r', ls=':', lw=1)
     plt.scatter(J['beta_x'] / J['se_x'], J['beta'] / J['se_y'], c='k', s=3)
     plt.axhline(y=0, c='k', lw=1)
     plt.axvline(x=0, c='k', lw=1)
     plt.xlim(lim)
     plt.ylim(lim)
     plt.xlabel('vQTL $z$-score')
     _ = plt.ylabel('eQTL $z$-score')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[61]:
   [[file:figure/qtl-mapping.org/var-qtl-vs-mean-qtl.png]]
   :END:

   Plot the significant SC eQTL \(z\)-scores, and their corresponding
   \(z\)-score for the mean.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/mean-qtl-vs-var-qtl.png
     J = (stats['mean']
          .reset_index()
          .merge(qtls['mean'][0][qtls['mean'][0]['fdr_pass']], on=['id', 'gene'])
          [['id', 'gene', 'beta_x', 'se']]
          .merge(stats['variance'].reset_index(), on=['id', 'gene'])
          .merge(qtls['variance'][0], on=['id', 'gene'], suffixes=['_y', '_z'], how='left')
          .fillna(False))
     lim = [-12, 12]
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     plt.plot(lim, lim, c='r', ls=':', lw=1)
     colors = {True: 'r', False: 'k'}
     labels = {True: 'vQTL', False: 'not vQTL'}
     for k, g in J.groupby('fdr_pass'):
       plt.scatter(g['beta_x'] / g['se_x'], g['beta_y'] / g['se_y'], c=colors[k], s=3, label=labels[k])
     plt.legend(frameon=False, markerscale=2, handletextpad=0, loc=(-.01, .75))
     plt.axhline(y=0, c='k', lw=1)
     plt.axvline(x=0, c='k', lw=1)
     plt.xlim(lim)
     plt.ylim(lim)
     plt.ylabel('vQTL $z$-score')
     _ = plt.xlabel('eQTL $z$-score')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[90]:
   [[file:figure/qtl-mapping.org/mean-qtl-vs-var-qtl.png]]
   :END:

** Predicting mean QTLs from variance QTLs

   As we change the threshold for calling mean (variance) QTLs, track the
   precision and recall of variance (mean) QTLs.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/var-qtl-mean-qtl-prc.png
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     Y, P = qtls['mean'][0]['fdr_pass'].align(qtls['variance'][0]['p_beta'].dropna(), join='inner')
     p, r, _ = sklearn.metrics.precision_recall_curve(Y.astype(int), -np.log(P))
     auprc_mean_var = sklearn.metrics.average_precision_score(Y.astype(int), -np.log(P))
     plt.plot(r[::10], p[::10], lw=1, c='k', label='Variance')
     Y, P = qtls['variance'][0]['fdr_pass'].align(qtls['mean'][0]['p_beta'].dropna(), join='inner')
     p, r, _ = sklearn.metrics.precision_recall_curve(Y.astype(int), -np.log(P))
     auprc_var_mean = sklearn.metrics.average_precision_score(Y.astype(int), -np.log(P))
     plt.plot(r[::10], p[::10], lw=1, c='r', label='Mean')
     plt.legend(frameon=False)
     plt.xlabel('Recall of QTLs at FDR 10%')
     _ = plt.ylabel('Precision of QTLs at FDR 10%')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[168]:
   [[file:figure/qtl-mapping.org/var-qtl-mean-qtl-prc.png]]
   :END:

   Tabulate the AUPRC.

   #+BEGIN_SRC ipython
     auprc_mean_var, auprc_var_mean
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[112]:
   : (0.5212419583724434, 0.6044457996921822)
   :END:

   Track sensitivity and specificity of mean QTLs.

   #+BEGIN_SRC ipython :ipyfile figure/qtl-mapping.org/var-qtl-mean-qtl-roc.png
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     Y, P = qtls['mean'][0]['fdr_pass'].align(qtls['variance'][0]['p_beta'].dropna(), join='inner')
     fpr, tpr, _ = sklearn.metrics.roc_curve(Y.astype(int), -np.log(P))
     auroc_mean_var = sklearn.metrics.roc_auc_score(Y.astype(int), -np.log(P))
     plt.plot(fpr[::10], tpr[::10], lw=1, c='k', label='Variance')
     Y, P = qtls['variance'][0]['fdr_pass'].align(qtls['mean'][0]['p_beta'].dropna(), join='inner')
     fpr, tpr, _ = sklearn.metrics.roc_curve(Y.astype(int), -np.log(P))
     auroc_var_mean = sklearn.metrics.roc_auc_score(Y.astype(int), -np.log(P))
     plt.plot(fpr[::10], tpr[::10], lw=1, c='r', label='Mean')
     plt.legend(frameon=False)
     plt.xlabel('False positive rate of QTLs at FDR 10%')
     _ = plt.ylabel('True positive rate of QTLs at FDR 10%')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[169]:
   [[file:figure/qtl-mapping.org/var-qtl-mean-qtl-roc.png]]
   :END:

   Tabulate the AUROC.

   #+BEGIN_SRC ipython
     auroc_mean_var, auroc_var_mean
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[110]:
   : (0.8968614143396433, 0.9555166119581557)
   :END:

   Find the threshold at which 90% of eQTLs are recovered.

   #+BEGIN_SRC ipython
     Y, P = qtls['variance'][0].set_index('gene')['fdr_pass'].align(qtls['mean'][0].set_index('gene')['p_beta'].dropna(), join='inner')
     fpr, tpr, thresh = sklearn.metrics.roc_curve(Y.astype(int), -np.log(P))
     np.exp(-thresh[np.where(tpr <= 0.9)].min())
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[166]:
   : 0.05222859999999999
   :END:

   Find the vQTLs which are not predictive of eQTLs.

   #+BEGIN_SRC ipython
     true_negatives = Y[np.logical_and(Y, -np.log(P) < thresh[np.where(tpr <= 0.9)].min())].to_frame().merge(gene_info, left_index=True, right_index=True)[['name']]
     true_negatives
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[167]:
   #+BEGIN_EXAMPLE
     name
     gene
     ENSG00000122574      WIPF3
     ENSG00000112367       FIG4
     ENSG00000121481       RNF2
     ENSG00000214194  LINC00998
     ENSG00000133935    C14orf1
     ENSG00000243725       TTC4
     ENSG00000132849      INADL
     ENSG00000171130   ATP6V0E2
     ENSG00000129518       EAPP
     ENSG00000182400   TRAPPC6B
     ENSG00000182117      NOP10
     ENSG00000068024      HDAC4
     ENSG00000169714       CNBP
     ENSG00000133030      MPRIP
     ENSG00000108528   SLC25A11
   #+END_EXAMPLE
   :END:

  Extract the QTLs for the browser.

  #+BEGIN_SRC ipython
    X, Y = extract_qtl_gene_pair(qtls['cv'][0][qtls['cv'][0]['fdr_pass']], qtls['cv'][1], '/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz')
    log_mu = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design2/zi2-log-mu.txt.gz', index_col=0, sep=' ')
    log_phi = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design2/zi2-log-phi.txt.gz', index_col=0, sep=' ')
    logodds = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design2/zi2-logodds.txt.gz', index_col=0, sep=' ')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[235]:
  :END:

  #+CALL: zinb-moments()

  #+RESULTS:
  :RESULTS:
  # Out[236]:
  :END:

  #+CALL: zinb-mix-moments()

  #+RESULTS:
  :RESULTS:
  # Out[237]:
  :END:

  #+BEGIN_SRC ipython
    mean = pd.DataFrame(mean_by_ind.T, index=log_mu.index, columns=log_mu.columns)
    variance = pd.DataFrame(var_by_ind.T, index=log_mu.index, columns=log_mu.columns)
    fano = variance / mean
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[238]:
  :END:

  #+BEGIN_SRC ipython
    with sqlite3.connect('/project2/mstephens/aksarkar/projects/singlecell-qtl/browser/browser.db') as conn:
      (qtls['cv'][0][qtls['cv'][0]['fdr_pass']]
       .set_index('gene')
       .merge(gene_info, left_index=True, right_index=True)
       .reset_index()[['gene', 'name', 'id', 'p_beta', 'beta']]
       .to_sql('cv_qtls', conn, index=False, if_exists='replace'))
      conn.execute('create index ix_cv_qtls on cv_qtls("gene");')

      (X.reset_index()
       .melt(id_vars='index', var_name='ind')
       .rename(columns={'index': 'gene'})
       .to_sql('cv_qtl_geno', conn, index=False, if_exists='replace'))
      conn.execute('create index ix_cv_qtl_geno on cv_qtl_geno("gene", "ind");')

      (Y.reset_index()
       .melt(id_vars='index', var_name='ind')
       .rename(columns={'index': 'gene', 'value': 'cv'})
       .merge(
         log_mu.reset_index().melt(id_vars='gene', var_name='ind').rename(columns={'value': 'log_mu'})
       )
       .merge(
         log_phi.reset_index().melt(id_vars='gene', var_name='ind').rename(columns={'value': 'log_phi'})
       )
       .merge(
         logodds.reset_index().melt(id_vars='gene', var_name='ind').rename(columns={'value': 'logodds'})     
       )
       .merge(
         mean.reset_index().melt(id_vars='gene', var_name='ind').rename(columns={'value': 'mean'})
       )
       .merge(
         variance.reset_index().melt(id_vars='gene', var_name='ind').rename(columns={'value': 'variance'})
       )
       .merge(
         fano.reset_index().melt(id_vars='gene', var_name='ind').rename(columns={'value': 'fano'})     
       )
       .to_sql('params', conn, index=False, if_exists='replace'))
      conn.execute('create index ix_params on params("gene", "ind");')


      (umi.loc[qtls['cv'][0].loc[qtls['cv'][0]['fdr_pass'], 'gene']]
       .reset_index()
       .melt(id_vars='gene', var_name='sample')
       .to_sql('umi', conn, index=False, if_exists='replace'))
      conn.execute('create index ix_umi on umi("gene", "ind");')

      annotations['sample'] = annotations.apply(lambda x: '{chip_id}.{experiment:08d}.{well}'.format(**dict(x)), axis=1)
      annotations['size'] = annotations['mol_hs']
      (annotations.loc[keep_samples.values.ravel(), ['sample', 'chip_id', 'size']]
       .to_sql('annotation', conn, con=conn, if_exists='replace'))
      conn.execute('create index ix_annotation on annotation(chip_id, sample);')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[204]:
  :END:

