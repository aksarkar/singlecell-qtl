<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2018-12-18 Tue 10:25 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>QTL mapping pipeline</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Abhishek Sarkar">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<link rel="stylesheet" type="text/css" href="site_libs/htmlize.css"/>
<style type="text/css">body {width: 60em; margin:auto} pre.src {overflow:auto}</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">QTL mapping pipeline</h1>

<div id="outline-container-org6f28457" class="outline-2">
<h2 id="org6f28457">Introduction</h2>
<div class="outline-text-2" id="text-org6f28457">
<p>
We take a modular approach to call QTLs:
</p>

<ol class="org-ol">
<li>Estimate a mean and a dispersion for each individual</li>
<li>Treat the mean/dispersion as continuous phenotypes and perform QTL mapping</li>
</ol>

<p>
Here, we solve (2).
</p>

<ol class="org-ol">
<li><a href="#orge8c78d5">We reproduce eQTLs</a> called on the bulk RNA-Seq</li>
<li><a href="#orgb470e33">We call mean/variance/CV/Fano QTLs</a> using ZINB parameters</li>
<li>We call QTLs using <a href="#org36807e9">counts</a> and <a href="#orgcbb0c05">log CPM</a></li>
<li>We <a href="#orga31f8af">explain away variance QTLs</a></li>
<li><a href="#orge536d76">We test replication/overlap</a> between different QTL calls</li>
</ol>
</div>
</div>

<div id="outline-container-orgf169aa2" class="outline-2">
<h2 id="orgf169aa2">Implementation</h2>
<div class="outline-text-2" id="text-orgf169aa2">
<div class="org-src-container">
<pre class="src src-ipython" id="org2ef7055"><span class="org-keyword">def</span> <span class="org-function-name">cpm</span>(x):
  <span class="org-keyword">return</span> pd.DataFrame(pandas2ri.ri2py(edger.cpm(numpy2ri(x.values), log=<span class="org-constant">True</span>)),
                      columns=x.columns,
                      index=x.index)

<span class="org-keyword">def</span> <span class="org-function-name">qqnorm</span>(x):
  <span class="org-doc">"""Wrap around R qqnorm"""</span>
  <span class="org-keyword">return</span> np.asarray(rpy2.robjects.r[<span class="org-string">'qqnorm'</span>](numpy2ri(x))[0])

<span class="org-keyword">def</span> <span class="org-function-name">bh</span>(x):
  <span class="org-doc">"""Wrap around p.adjust(..., method='fdr')"""</span>
  <span class="org-keyword">return</span> np.asarray(rpy2.robjects.r[<span class="org-string">'p.adjust'</span>](numpy2ri(x), method=<span class="org-string">'fdr'</span>))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython" id="orgfd6423d"><span class="org-variable-name">gene_info</span> = (pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-genes.txt.gz'</span>)
             .set_index(<span class="org-string">'gene'</span>)
             .query(<span class="org-string">'source == "H. sapiens"'</span>)
             .query(<span class="org-string">'chr != "hsX"'</span>)
             .query(<span class="org-string">'chr != "hsY"'</span>)
             .query(<span class="org-string">'chr != "hsMT"'</span>))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython" id="orgfaccdf9"><span class="org-keyword">with</span> sqlite3.connect(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/browser/browser.db'</span>) <span class="org-keyword">as</span> conn:
  gene_info.to_sql(<span class="org-string">'gene_info'</span>, conn, index=<span class="org-constant">True</span>, if_exists=<span class="org-string">'replace'</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython" id="org76609da"><span class="org-keyword">def</span> <span class="org-function-name">qtltools_format</span>(row, prefix=<span class="org-string">'chr'</span>):
  <span class="org-variable-name">row</span>[<span class="org-string">'#Chr'</span>] = <span class="org-string">'{}{}'</span>.<span class="org-builtin">format</span>(prefix, row[<span class="org-string">'chr'</span>][2:])
  <span class="org-variable-name">row</span>[<span class="org-string">'gid'</span>] = row.name
  <span class="org-variable-name">row</span>[<span class="org-string">'pid'</span>] = row.name
  <span class="org-comment-delimiter"># </span><span class="org-comment">Important: qtltools expects TSS start/end</span>
  <span class="org-keyword">if</span> row[<span class="org-string">'strand'</span>] == <span class="org-string">'+'</span>:
    <span class="org-variable-name">row</span>[<span class="org-string">'end'</span>] = row[<span class="org-string">'start'</span>]
  <span class="org-keyword">else</span>:
    <span class="org-variable-name">row</span>[<span class="org-string">'start'</span>] = row[<span class="org-string">'end'</span>]
  <span class="org-keyword">return</span> row.loc[[<span class="org-string">'#Chr'</span>, <span class="org-string">'start'</span>, <span class="org-string">'end'</span>, <span class="org-string">'pid'</span>, <span class="org-string">'gid'</span>, <span class="org-string">'strand'</span>]]

<span class="org-keyword">def</span> <span class="org-function-name">write_pheno_file</span>(pheno, gene_info, output_file, holdout=<span class="org-constant">True</span>, **kwargs):
  <span class="org-keyword">if</span> holdout:
    <span class="org-variable-name">genes</span> = gene_info.loc[gene_info.<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: <span class="org-builtin">bool</span>(<span class="org-builtin">int</span>(x[<span class="org-string">'chr'</span>][2:]) % 2), axis=1)]
  <span class="org-keyword">else</span>:
    <span class="org-variable-name">genes</span> = gene_info
  (genes
   .<span class="org-builtin">apply</span>(qtltools_format, **kwargs, axis=1)
   .merge(pheno, left_index=<span class="org-constant">True</span>, right_index=<span class="org-constant">True</span>)
   .to_csv(output_file,
           sep=<span class="org-string">'\t'</span>,
           header=<span class="org-constant">True</span>,
           index=<span class="org-constant">False</span>,
           index_label=<span class="org-constant">False</span>))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh" id="org3dca1d4"><span class="org-builtin">export</span> <span class="org-variable-name">input</span>=$<span class="org-variable-name">input</span>
sbatch --partition=$<span class="org-variable-name">partition</span> --wait
<span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/bash</span>
module load bedtools
bedtools sort -header -i $<span class="org-variable-name">input</span> | bgzip &gt;$<span class="org-variable-name">input</span>.gz
tabix -f -p bed $<span class="org-variable-name">input</span>.gz
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh" id="orgf1a9d44"><span class="org-builtin">export</span> <span class="org-variable-name">pheno</span>=$<span class="org-variable-name">pheno</span>
<span class="org-builtin">export</span> <span class="org-variable-name">geno</span>=$<span class="org-variable-name">geno</span>
<span class="org-builtin">export</span> <span class="org-variable-name">op</span>=$<span class="org-variable-name">op</span>
sbatch --partition=$<span class="org-variable-name">partition</span> -a 1-100 -J $<span class="org-variable-name">pheno</span>-qtl --wait
<span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/bash</span>
<span class="org-builtin">source</span> activate scqtl
qtltools cis --vcf $<span class="org-variable-name">geno</span> --bed $<span class="org-variable-name">pheno</span>.bed.gz $<span class="org-variable-name">op</span> --chunk $<span class="org-variable-name">SLURM_ARRAY_TASK_ID</span> 100 --out $<span class="org-variable-name">pheno</span>-qtl.$<span class="org-variable-name">SLURM_ARRAY_TASK_ID</span>.txt --seed 0
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython" id="org68d9536"><span class="org-keyword">def</span> <span class="org-function-name">_read_helper</span>(pheno, columns):
  <span class="org-variable-name">file_names</span> = [<span class="org-string">'{}-qtl.{}.txt'</span>.<span class="org-builtin">format</span>(pheno, i) <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1, 101)]
  <span class="org-variable-name">res</span> = (pd.concat([pd.read_table(f, header=<span class="org-constant">None</span>, sep=<span class="org-string">' '</span>)
                     <span class="org-keyword">for</span> f <span class="org-keyword">in</span> file_names <span class="org-keyword">if</span> os.path.exists(f) <span class="org-keyword">and</span>
                     os.path.getsize(f) &gt; 0])
          .rename(columns={i: x <span class="org-keyword">for</span> i, x <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(columns)})
          .dropna()
          .sort_values(<span class="org-string">'p_beta'</span>))
  <span class="org-variable-name">res</span>[<span class="org-string">'p_adjust'</span>] = bh(res[<span class="org-string">'p_beta'</span>])
  <span class="org-variable-name">res</span>[<span class="org-string">'fdr_pass'</span>] = res[<span class="org-string">'p_adjust'</span>] &lt; 0.1
  <span class="org-keyword">return</span> res


<span class="org-keyword">def</span> <span class="org-function-name">read_fastqtl_output</span>(pheno):
  <span class="org-variable-name">columns</span> = [<span class="org-string">'gene'</span>, <span class="org-string">'num_snps'</span>, <span class="org-string">'a'</span>, <span class="org-string">'b'</span>, <span class="org-string">'dummy'</span>, <span class="org-string">'id'</span>,
             <span class="org-string">'distance'</span>, <span class="org-string">'p'</span>, <span class="org-string">'beta'</span>, <span class="org-string">'p_empirical'</span>, <span class="org-string">'p_beta'</span>]
  <span class="org-variable-name">res</span> = _read_helper(pheno, columns)
  <span class="org-comment-delimiter"># </span><span class="org-comment">Drop the gene version number</span>
  <span class="org-variable-name">res</span>[<span class="org-string">'gene'</span>] = res[<span class="org-string">'gene'</span>].<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: x.split(<span class="org-string">'.'</span>)[0])
  <span class="org-variable-name">res</span>[<span class="org-string">'chr'</span>] = res[<span class="org-string">'id'</span>].<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: x.split(<span class="org-string">'.'</span>)[1])
  <span class="org-variable-name">res</span>[<span class="org-string">'pos'</span>] = res[<span class="org-string">'id'</span>].<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: x.split(<span class="org-string">'.'</span>)[2])
  <span class="org-variable-name">res</span>[<span class="org-string">'id'</span>] = res[<span class="org-string">'id'</span>].<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: x.split(<span class="org-string">'.'</span>)[0])
  <span class="org-keyword">return</span> res

<span class="org-keyword">def</span> <span class="org-function-name">read_qtltools_output</span>(pheno):
  <span class="org-variable-name">columns</span> = [<span class="org-string">'gene'</span>, <span class="org-string">'chr'</span>, <span class="org-string">'start'</span>, <span class="org-string">'end'</span>, <span class="org-string">'strand'</span>, <span class="org-string">'num_vars'</span>,
             <span class="org-string">'distance'</span>, <span class="org-string">'id'</span>, <span class="org-string">'var_chr'</span>, <span class="org-string">'var_start'</span>, <span class="org-string">'var_end'</span>, <span class="org-string">'df'</span>,
             <span class="org-string">'dummy'</span>, <span class="org-string">'a'</span>, <span class="org-string">'b'</span>, <span class="org-string">'p_nominal'</span>, <span class="org-string">'beta'</span>, <span class="org-string">'p_empirical'</span>, <span class="org-string">'p_beta'</span>]
  <span class="org-variable-name">res</span> = _read_helper(pheno, columns)
  <span class="org-variable-name">res</span>[<span class="org-string">'chr'</span>] = res[<span class="org-string">'var_chr'</span>]
  <span class="org-variable-name">res</span>[<span class="org-string">'pos'</span>] = res[<span class="org-string">'var_start'</span>]
  <span class="org-variable-name">res</span>[<span class="org-string">'id'</span>] = res[<span class="org-string">'id'</span>].<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: x.split(<span class="org-string">'.'</span>)[0])
  <span class="org-keyword">return</span> res

<span class="org-keyword">def</span> <span class="org-function-name">read_nominal_pass</span>(f):
  <span class="org-variable-name">isf</span> = st.chi2(1).isf
  <span class="org-variable-name">result</span> = pd.read_table(f, sep=<span class="org-string">' '</span>, header=<span class="org-constant">None</span>)
  <span class="org-variable-name">result.columns</span> = [<span class="org-string">'gene'</span>, <span class="org-string">'chr'</span>, <span class="org-string">'start'</span>, <span class="org-string">'end'</span>, <span class="org-string">'strand'</span>, <span class="org-string">'n'</span>, <span class="org-string">'distance'</span>, <span class="org-string">'id'</span>, <span class="org-string">'var_chr'</span>, <span class="org-string">'var_start'</span>, <span class="org-string">'var_end'</span>, <span class="org-string">'p_nominal'</span>, <span class="org-string">'beta'</span>, <span class="org-string">'top'</span>]
  <span class="org-variable-name">result</span>[<span class="org-string">'z'</span>] = np.sign(result[<span class="org-string">'beta'</span>]) * np.sqrt(isf(result[<span class="org-string">'p_nominal'</span>]))
  <span class="org-keyword">return</span> result
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython" id="orgccd9fc5"><span class="org-keyword">def</span> <span class="org-function-name">plot_approx_permutation</span>(df):
  plt.clf()
  plt.gcf().set_size_inches(6, 6)
  plt.scatter(df[<span class="org-string">'p_empirical'</span>], df[<span class="org-string">'p_beta'</span>], s=1, c=<span class="org-string">'k'</span>)
  plt.plot([0, 1], [0, 1], c=<span class="org-string">'r'</span>, ls=<span class="org-string">'--'</span>)
  plt.xlabel(<span class="org-string">'Empirical p-value'</span>)
  plt.ylabel(<span class="org-string">'Approximate p-value'</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython" id="org0674fcc"><span class="org-keyword">def</span> <span class="org-function-name">qqplot</span>(qtls):
  <span class="org-variable-name">N</span> = qtls.shape[0]
  <span class="org-comment-delimiter"># </span><span class="org-comment">95% bootstrap CI</span>
  <span class="org-variable-name">ci</span> = -np.log10(np.percentile(np.sort(np.random.uniform(size=(100, N)), axis=1), [5, 95], axis=0))

  <span class="org-variable-name">grid</span> = -np.log10(np.arange(1, 1 + N) / N)
  plt.clf()
  plt.gcf().set_size_inches(6, 6)
  plt.scatter(grid, -np.log10(qtls[<span class="org-string">'p_beta'</span>]), s=1, c=<span class="org-string">'k'</span>)
  plt.plot([0, np.log10(qtls.shape[0])], [0, np.log10(qtls.shape[0])], c=<span class="org-string">'r'</span>, ls=<span class="org-string">'--'</span>)
  plt.plot(grid, ci[0], c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>)
  plt.plot(grid, ci[1], c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>)
  plt.xlabel(<span class="org-string">'Expected $-\log_{10}(p)$'</span>)
  <span class="org-variable-name">_</span> = plt.ylabel(<span class="org-string">'Observed $-\log_{10}(p)$'</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython" id="orgaaa3624"><span class="org-keyword">def</span> <span class="org-function-name">parse_vcf_dosage</span>(record):
  <span class="org-variable-name">geno</span> = [<span class="org-builtin">float</span>(g) <span class="org-keyword">for</span> g <span class="org-keyword">in</span> record[9:]]
  <span class="org-keyword">return</span> pd.Series(geno)

<span class="org-keyword">def</span> <span class="org-function-name">extract_qtl_gene_pair</span>(qtl_gene_df, pheno_df, dosages):
  <span class="org-doc">"""Return aligned genotype and phenotype matrix for each QTL-gene pair in qtl_gene_df"""</span>
  <span class="org-variable-name">common_phenos</span>, <span class="org-variable-name">common_qtls</span> = pheno_df.align(qtl_gene_df.set_index(<span class="org-string">'gene'</span>), join=<span class="org-string">'inner'</span>, axis=0)
  <span class="org-comment-delimiter"># </span><span class="org-comment">Important: assume individual IDs are prefixed by "NA". This isn't true in</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">the original VCF</span>
  <span class="org-variable-name">header</span> = pd.read_table(dosages, skiprows=2, nrows=1, header=0).columns[9:]
  <span class="org-variable-name">genotypes</span> = tabix.<span class="org-builtin">open</span>(dosages)
  <span class="org-variable-name">X</span>, <span class="org-variable-name">Y</span> = (common_qtls
          .<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: parse_vcf_dosage(<span class="org-builtin">next</span>(genotypes.query(x[<span class="org-string">'chr'</span>], <span class="org-builtin">int</span>(x[<span class="org-string">'var_start'</span>]) - 1, <span class="org-builtin">int</span>(x[<span class="org-string">'var_start'</span>])))), axis=1)
          .rename(columns={i: ind <span class="org-keyword">for</span> i, ind <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(header)})
          .align(common_phenos, join=<span class="org-string">'inner'</span>, axis=<span class="org-constant">None</span>))
  <span class="org-keyword">return</span> X, Y

<span class="org-keyword">def</span> <span class="org-function-name">replication_tests</span>(X, Y, C=<span class="org-constant">None</span>):
  <span class="org-doc">"""Return a DataFrame containing replication p-values</span>

<span class="org-doc">  X - centered dosage matrix (num_genes, num_individuals)</span>
<span class="org-doc">  Y - phenotype matrix (num_genes, num_individuals)</span>
<span class="org-doc">  C - confounder matrix (num_confounders, num_individuals)</span>

<span class="org-doc">  """</span>
  <span class="org-variable-name">p</span>, <span class="org-variable-name">n</span> = X.shape
  <span class="org-keyword">assert</span> Y.shape == (p, n)
  <span class="org-keyword">if</span> C <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
    <span class="org-keyword">assert</span> C.shape[1] == n
    <span class="org-variable-name">C</span> = np.array(C).T
    <span class="org-variable-name">C</span> = C - C.mean(axis=0)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Construct the annihilator matrix I - X X^+</span>
    <span class="org-variable-name">M</span> = np.eye(n) - C.dot(np.linalg.pinv(C))
  <span class="org-variable-name">result</span> = []
  <span class="org-variable-name">_sf</span> = st.chi2(1).sf
  <span class="org-keyword">for</span> (_, x), (name, y) <span class="org-keyword">in</span> <span class="org-builtin">zip</span>(X.iterrows(), Y.iterrows()):
    <span class="org-keyword">if</span> np.isclose(x.std(), 0):
      <span class="org-keyword">print</span>(<span class="org-string">'Skipping {}'</span>.<span class="org-builtin">format</span>(name))
      <span class="org-keyword">continue</span>
    <span class="org-variable-name">x</span> = x.values.copy().reshape(-1, 1)
    <span class="org-variable-name">x</span> -= x.mean()
    <span class="org-variable-name">y</span> = y.values.copy().ravel()
    <span class="org-variable-name">y</span> -= y.mean()
    <span class="org-keyword">if</span> C <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
      <span class="org-variable-name">y</span> = M.dot(y)
      <span class="org-variable-name">y</span> -= y.mean()
    beta, rss, *<span class="org-variable-name">_</span> = np.linalg.lstsq(x, y, rcond=-1)
    <span class="org-variable-name">sigma2</span> = rss / y.shape[0]
    <span class="org-variable-name">se</span> = sigma2 / x.T.dot(x).ravel()
    <span class="org-variable-name">pval</span> = _sf(np.square(beta / se))
    result.append({<span class="org-string">'gene'</span>: name, <span class="org-string">'beta'</span>: beta[0], <span class="org-string">'se'</span>: se[0], <span class="org-string">'p'</span>: pval.ravel()[0]})
  <span class="org-keyword">return</span> pd.DataFrame.from_dict(result)

<span class="org-keyword">def</span> <span class="org-function-name">pairwise_replication</span>(qtls, phenos, ticks, covars=<span class="org-constant">None</span>):
  <span class="org-keyword">if</span> covars <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
    <span class="org-keyword">assert</span> <span class="org-builtin">len</span>(covars) == <span class="org-builtin">len</span>(phenos)
  <span class="org-keyword">assert</span> <span class="org-builtin">len</span>(phenos) == <span class="org-builtin">len</span>(ticks)
  <span class="org-variable-name">repl_rate</span> = np.ones((<span class="org-builtin">len</span>(phenos), <span class="org-builtin">len</span>(phenos)))
  <span class="org-keyword">for</span> i, ki <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(phenos):
    <span class="org-keyword">for</span> j, kj <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(phenos):
      <span class="org-keyword">if</span> i == j:
        <span class="org-keyword">continue</span>
      <span class="org-variable-name">q</span>, <span class="org-variable-name">p</span> = qtls[ki][0], qtls[kj][1]
      <span class="org-variable-name">X</span>, <span class="org-variable-name">Y</span> = extract_qtl_gene_pair(q[q[<span class="org-string">'fdr_pass'</span>]], p,
                                   dosages=<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz'</span>)
      <span class="org-keyword">if</span> X.empty:
        <span class="org-keyword">continue</span>
      <span class="org-keyword">if</span> covars <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span> <span class="org-keyword">and</span> covars[j] <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
        <span class="org-variable-name">C</span> = covars[j].align(X, axis=<span class="org-string">'columns'</span>, join=<span class="org-string">'inner'</span>)[0]
      <span class="org-keyword">else</span>:
        <span class="org-variable-name">C</span> = <span class="org-constant">None</span>
      <span class="org-variable-name">replication</span> = q.merge(
        replication_tests(X, Y, C),
        on=<span class="org-string">'gene'</span>,
        suffixes=[<span class="org-string">'_1'</span>, <span class="org-string">'_2'</span>])[[<span class="org-string">'gene'</span>, <span class="org-string">'id'</span>, <span class="org-string">'beta_1'</span>, <span class="org-string">'beta_2'</span>, <span class="org-string">'p'</span>]]
      <span class="org-variable-name">replication</span>[<span class="org-string">'fdr_pass'</span>] = bh(replication[<span class="org-string">'p'</span>]) &lt; .1
      <span class="org-variable-name">replication</span>[<span class="org-string">'replicated'</span>] = replication.<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: x[<span class="org-string">'fdr_pass'</span>] <span class="org-keyword">and</span> x[<span class="org-string">'beta_1'</span>] * x[<span class="org-string">'beta_2'</span>] &gt; 0, axis=1)
      <span class="org-variable-name">repl_rate</span>[i, j] = replication[<span class="org-string">'replicated'</span>].<span class="org-builtin">sum</span>() / replication.shape[0]
  <span class="org-keyword">return</span> pd.DataFrame(100 * repl_rate, columns=ticks, index=ticks)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython" id="orgfc2b3de"><span class="org-keyword">def</span> <span class="org-function-name">bootstrap_se</span>(X, Y, C=<span class="org-constant">None</span>, num_bootstraps=100, seed=0):
  np.random.seed(seed)
  <span class="org-variable-name">beta</span> = {}
  <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(num_bootstraps):
    <span class="org-variable-name">b</span> = np.random.choice(X.shape[1], size=X.shape[1], replace=<span class="org-constant">True</span>)
    <span class="org-keyword">if</span> C <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
      <span class="org-variable-name">beta</span>[i] = replication_tests(X.iloc[:,b], Y.iloc[:,b], C.iloc[:,b]).set_index(<span class="org-string">'gene'</span>)[<span class="org-string">'beta'</span>]
    <span class="org-keyword">else</span>:
      <span class="org-variable-name">beta</span>[i] = replication_tests(X.iloc[:,b], Y.iloc[:,b]).set_index(<span class="org-string">'gene'</span>)[<span class="org-string">'beta'</span>]
  <span class="org-keyword">return</span> pd.DataFrame.from_dict(beta).agg(np.std, axis=1)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython" id="org7616bf3"><span class="org-keyword">def</span> <span class="org-function-name">_fit_lm</span>(x, y):
  <span class="org-variable-name">n</span>, <span class="org-variable-name">p</span> = x.shape
  <span class="org-keyword">assert</span> y.shape == (n, 1)
  <span class="org-variable-name">y</span> -= y.mean()
  <span class="org-variable-name">x</span> -= x.mean(axis=0)
  <span class="org-variable-name">beta</span> = x.T.dot(y) / np.var(x, axis=0).values.reshape(-1, 1)
  <span class="org-keyword">return</span> beta

<span class="org-keyword">def</span> <span class="org-function-name">estimate_beta_se</span>(genes, dosages, gene_info, covars=<span class="org-constant">None</span>, window=100000, n_bootstrap=100, seed=0):
  <span class="org-doc">"""Estimate beta via OLS and SE via bootstrap</span>

<span class="org-doc">  genes - dataframe (num_genes, num_individuals)</span>
<span class="org-doc">  dosages - VCF file name</span>
<span class="org-doc">  gene_info - dataframe (see read_gene_info)</span>
<span class="org-doc">  covars - dataframe (num_covars, num_individuals)</span>

<span class="org-doc">  """</span>
  <span class="org-keyword">with</span> gzip.<span class="org-builtin">open</span>(dosages, <span class="org-string">'rt'</span>) <span class="org-keyword">as</span> f:
    <span class="org-keyword">for</span> line <span class="org-keyword">in</span> f:
      <span class="org-keyword">if</span> line.startswith(<span class="org-string">'#CHROM'</span>):
        <span class="org-variable-name">header</span> = line.split()[9:]
        <span class="org-keyword">break</span>
  <span class="org-variable-name">dosages</span> = tabix.<span class="org-builtin">open</span>(dosages)
  <span class="org-keyword">if</span> covars <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
    <span class="org-variable-name">covars</span>, <span class="org-variable-name">genes</span> = covars.align(genes, axis=<span class="org-string">'columns'</span>, join=<span class="org-string">'inner'</span>)
    <span class="org-variable-name">_</span>, <span class="org-variable-name">n</span> = covars.shape
    <span class="org-variable-name">covars</span> = covars.values.T
    <span class="org-variable-name">M</span> = np.eye(n) - covars.dot(np.linalg.pinv(covars))
  <span class="org-variable-name">result</span> = []
  <span class="org-keyword">for</span> gene, Y <span class="org-keyword">in</span> genes.iterrows():
    <span class="org-keyword">if</span> gene <span class="org-keyword">in</span> gene_info.index:
      <span class="org-variable-name">record</span> = gene_info.loc[gene]
      <span class="org-keyword">if</span> record[<span class="org-string">'strand'</span>] == <span class="org-string">'+'</span>:
        <span class="org-variable-name">X</span> = dosages.query(<span class="org-string">'chr{}'</span>.<span class="org-builtin">format</span>(record[<span class="org-string">'chr'</span>][2:]), record[<span class="org-string">'start'</span>] - window, record[<span class="org-string">'start'</span>] + window)
      <span class="org-keyword">else</span>:
        <span class="org-variable-name">X</span> = dosages.query(<span class="org-string">'chr{}'</span>.<span class="org-builtin">format</span>(record[<span class="org-string">'chr'</span>][2:]), record[<span class="org-string">'end'</span>] - window, record[<span class="org-string">'end'</span>] + window)
      <span class="org-variable-name">X</span> = <span class="org-builtin">list</span>(X)
      <span class="org-variable-name">meta</span> = [row[2] <span class="org-keyword">for</span> row <span class="org-keyword">in</span> X]
      <span class="org-variable-name">X</span> = pd.DataFrame([parse_vcf_dosage(row) <span class="org-keyword">for</span> row <span class="org-keyword">in</span> X])
      <span class="org-variable-name">X.index</span> = meta
      <span class="org-variable-name">X.columns</span> = header
      <span class="org-variable-name">X</span>, <span class="org-variable-name">Y</span> = X.align(Y, axis=<span class="org-string">'columns'</span>, join=<span class="org-string">'inner'</span>)
      <span class="org-keyword">if</span> covars <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
        <span class="org-variable-name">Y</span> = M.dot(Y - Y.mean())
      <span class="org-variable-name">X</span> = X.transform(<span class="org-keyword">lambda</span> x: x - x.mean(), axis=1)

      <span class="org-variable-name">beta</span> = [_fit_lm(X.T, Y.reshape(-1, 1))]
      np.random.seed(seed)
      <span class="org-keyword">for</span> _ <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n_bootstrap):
        <span class="org-variable-name">B</span> = np.random.choice(n, size=n, replace=<span class="org-constant">True</span>)
        beta.append(_fit_lm(X.iloc[:,B].T, Y[B].reshape(-1, 1)))
      result.append(pd.DataFrame({<span class="org-string">'gene'</span>: gene, <span class="org-string">'snp'</span>: meta, <span class="org-string">'beta'</span>: beta[0].values.ravel(), <span class="org-string">'se'</span>: np.std(np.ma.masked_invalid(np.hstack(beta[1:])), axis=1)}))
  <span class="org-keyword">return</span> pd.concat(result)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb4b1ce7" class="outline-2">
<h2 id="orgb4b1ce7">Preliminaries</h2>
<div class="outline-text-2" id="text-orgb4b1ce7">
</div>
<div id="outline-container-org839a099" class="outline-3">
<h3 id="org839a099">Test validity of approximate permutation test</h3>
<div class="outline-text-3" id="text-org839a099">
<p>
<code>qtltools</code> tries to calibrate false discovery rates using the following
procedure:
</p>

<ol class="org-ol">
<li>For each gene, permute the genotype data to estimate the null distribution
of the p-values</li>
<li>Fit a beta distribution to the permuted p-values via ML</li>
<li>Compute the lower tail probability of the observed p-value, assuming it
was generated from the fitted beta distribution</li>
<li>Apply FDR correction on the set of lower tail probabilities (across all
genes)</li>
</ol>

<p>
Test whether the beta approximation is appropriate for our sample size by
subsetting GEUVADIS. Take all genes on chromosome 1.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">geuvadis</span> = []
<span class="org-keyword">for</span> chunk <span class="org-keyword">in</span> pd.read_table(<span class="org-string">'/project/compbio/geuvadis/analysis_results/GD462.GeneQuantRPKM.50FN.samplename.resk10.txt.gz'</span>, chunksize=100):
  geuvadis.append(chunk.query(<span class="org-string">'Chr == "1"'</span>))
<span class="org-variable-name">geuvadis</span> = pd.concat(geuvadis)
<span class="org-variable-name">geuvadis</span> = geuvadis.set_index(geuvadis[<span class="org-string">'Gene_Symbol'</span>].<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: x.split(<span class="org-string">'.'</span>)[0]))
</pre>
</div>

<p>
First, replicate the result in <a href="https://www.nature.com/articles/ncomms15452">Delaneau et al 2017</a> by using all 462
individuals from GEUVADIS.
</p>

<div class="org-src-container">
<pre class="src src-ipython">pd.Series(geuvadis.columns).sort_values().to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/geuvadis/geuvadis-subset.txt'</span>, header=<span class="org-constant">None</span>, index=<span class="org-constant">None</span>)
</pre>
</div>

<p>
Write out the phenotype file for <code>qtltools</code>. Important: GEUVADIS VCFs code
chromosome without <code>chr</code>.
</p>

<div class="org-src-container">
<pre class="src src-ipython">write_pheno_file(geuvadis, gene_info, <span class="org-string">'/scratch/midway2/aksarkar/singlecell/geuvadis/test.bed'</span>, prefix=<span class="org-string">''</span>)
</pre>
</div>

<p>
Index the phenotype file. Important: <code>#</code> sorts before <code>c</code>, but after <code>1</code>.
</p>

<pre class="example">
Submitted batch job 44542169

</pre>

<p>
Perform SNP QC in <code>plink</code>.
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org444b276">sbatch --partition=broadwl --mem=2G --wait
<span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/bash</span>
plink --memory 2000 --geno 0.01 --maf 0.05 --keep-fam /scratch/midway2/aksarkar/singlecell/geuvadis-subset.txt --vcf /project/compbio/geuvadis/genotypes/GEUVADIS.chr1.PH1PH2_465.IMPFRQFILT_BIALLELIC_PH.annotv2.genotypes.vcf.gz --recode vcf-iid --out geuvadis-chr1
bgzip -f geuvadis-chr1.vcf
tabix -f -p vcf geuvadis-chr1.vcf.gz
</pre>
</div>

<pre class="example">
Submitted batch job 44541229

</pre>

<p>
Run <code>qtltools</code>.
</p>

<pre class="example">
Submitted batch job 44685856

</pre>

<p>
Read the results.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">geuvadis_qtls</span> = read_qtltools_output(<span class="org-string">'geuvadis/test'</span>)
</pre>
</div>

<p>
Check the beta approximation to the permutation p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_approx_permutation(geuvadis_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/geuvadis-beta-approx.png" alt="geuvadis-beta-approx.png">
</p>
</div>

<p>
Plot the QQ plot
</p>

<div class="org-src-container">
<pre class="src src-ipython">qqplot(geuvadis_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/geuvadis-qq.png" alt="geuvadis-qq.png">
</p>
</div>

<p>
Repeat the analysis after subsetting to 54 individuals.
</p>

<div class="org-src-container">
<pre class="src src-ipython">np.random.seed(0)
<span class="org-variable-name">subset</span> = np.random.choice([x <span class="org-keyword">for</span> x <span class="org-keyword">in</span> geuvadis.columns], size=54, replace=<span class="org-constant">False</span>)
pd.Series(subset).sort_values().to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/geuvadis-subset.txt'</span>, header=<span class="org-constant">None</span>, index=<span class="org-constant">None</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">write_pheno_file(geuvadis[subset], gene_info, <span class="org-string">'/scratch/midway2/aksarkar/singlecell/geuvadis/test.bed'</span>, prefix=<span class="org-string">''</span>)
</pre>
</div>

<pre class="example">
Submitted batch job 44544326

</pre>

<pre class="example">
Submitted batch job 44544018

</pre>

<pre class="example">
Submitted batch job 44544375

</pre>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">geuvadis_54_qtls</span> = read_qtltools_output(<span class="org-string">'geuvadis/test'</span>)
plot_approx_permutation(geuvadis_54_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/geuvadis-54-beta-approx.png" alt="geuvadis-54-beta-approx.png">
</p>
</div>
</div>
</div>

<div id="outline-container-orge8c78d5" class="outline-3">
<h3 id="orge8c78d5">Reproduce bulk eQTL calls</h3>
<div class="outline-text-3" id="text-orge8c78d5">
<p>
The iPSC bulk eQTLs were called in <a href="https://genome.cshlp.org/content/28/1/122.long">Banovich et al 2018</a>.
</p>

<pre class="example">
eQTLs in iPSCs and LCLs: We transformed expression levels to a standard normal
within each individual. We next accounted for unknown confounders by removing
principal components from the LCL (15 PCs) and iPSC (10 PCs) data. Genotypes
were obtained using impute2 as described previously (Li et al. 2016). We only
considered variants within 50 kb of genes. To identify association between
genotype and gene expression, we used FastQTL (Ongen et al. 2016). After the
initial regression, a variable number of permutations were performed to obtain
a gene-wise adjusted P-value (Ongen et al. 2016). To identify significant
eQTLs, we used Storey's q-value (Storey and Tibshirani 2003) on the adjusted
P-values. Genes with a q-value less than 0.1 are considered significant.
</pre>

<p>
<b>Important notes:</b>
</p>

<ol class="org-ol">
<li><p>
The text doesn't state how expression level was quantified (it was the
ratio of mapped reads to total reads after correction by
<code>WASP</code>).
</p>

<p>
<code>WASP</code> (<a href="https://www.nature.com/articles/nmeth.3582">de Geijin et al 2015</a>) fits quartic polynomials \(f, g\) which
predict the total read count per region \(T^*_{ij}\) from the observed
read count \(x_{ij}\) and GC content \(w_j\) by maximizing the likelihood
of the observed read counts:
</p>

<p>
\[ x_{ij} \sim \mathrm{Pois}(T^*_{ij}) \]
</p>

<p>
\[ T^*_{ij} = \exp\left(f\left(\sum_i x_{ij}\right)\right) g(w_j) \]
</p>

<p>
<a href="#org58e4fcb">Using log CPM</a> (under the assumption that we never compare genes to each
other) yields 1279 eQTLs (89%).
</p></li>

<li><p>
<code>fastqtl</code> expects gene start/end, and only takes <i>cis</i>-SNPs around the
start ignoring strand. The code uses GENCODE v19 exons to define the
start/end.
</p>

<p>
<code>qtltools</code> expects TSS and strand, but doesn't use strand information in
<i>cis</i>-eQTL mapping. Using the start coordinate of the provided expression
matrix as TSS yields 1265 eQTLs (87%).
</p></li>

<li>The methods section of <a href="https://www.nature.com/articles/nature10808">Degner et al 2012</a> states data is standardized
across individuals, and quantile normalized within individuals. The
equation contradicts the text, but the code follows the text.</li>

<li>The code analyzes 100kb windows, contradicting the text.</li>

<li>Not every gene in the input appears in the output, and changing the number
of chunks changes the number of genes lost.</li>

<li>QTL-gene pairs passed the Benjamini-Hochberg procedure, not Storey's
procedure.</li>
</ol>

<div class="org-src-container">
<pre class="src src-sh">sbatch --partition=broadwl -a 1-25
<span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/bash</span>
<span class="org-builtin">source</span> activate scqtl
fastqtl -V YRI_SNPs_2_IPSC.txt.gen.gz -B fastqtl_qqnorm_RNAseq_run.fixed.txt.gz -C fasteqtl_PC_RNAseq_run.fixed.txt -O bulk-qtl.$<span class="org-variable-name">SLURM_ARRAY_TASK_ID</span>.txt --exclude-samples file_IPSC.excl --window 1e5 --permute 1000 10000 --chunk $<span class="org-variable-name">SLURM_ARRAY_TASK_ID</span> 25 --seed 1475098497
</pre>
</div>

<pre class="example">
Submitted batch job 44546060

</pre>

<p>
Subsample the individuals.
</p>

<div class="org-src-container">
<pre class="src src-sh">sbatch --partition=broadwl -a 1-25
<span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/bash</span>
<span class="org-builtin">source</span> activate scqtl
awk <span class="org-string">'NR &lt; 6'</span> file_IPSC.used | cat - file_IPSC.excl &gt;subsample.excl
fastqtl -V YRI_SNPs_2_IPSC.txt.gen.gz -B fastqtl_qqnorm_RNAseq_run.fixed.txt.gz -C fasteqtl_PC_RNAseq_run.fixed.txt -O bulk-qtl.$<span class="org-variable-name">SLURM_ARRAY_TASK_ID</span>.txt --exclude-samples subsample.excl --window 1e5 --permute 1000 10000 --chunk $<span class="org-variable-name">SLURM_ARRAY_TASK_ID</span> 25 --seed 1475098497
</pre>
</div>

<pre class="example">
Submitted batch job 47297158

</pre>

<p>
Read <code>fastqtl</code> output.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">bulk_qtls</span> = read_fastqtl_output(<span class="org-string">'reproduce-yang/bulk'</span>)
</pre>
</div>

<p>
Write out the summary stats with headers.
</p>

<div class="org-src-container">
<pre class="src src-ipython">bulk_qtls.to_csv(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-mapping/bulk.txt.gz'</span>, sep=<span class="org-string">'\t'</span>, index=<span class="org-constant">None</span>, compression=<span class="org-string">'gzip'</span>)
</pre>
</div>

<p>
Compare <code>qtltools</code> to <code>fastqtl</code>. The input files need to be modified.
</p>

<div class="org-src-container">
<pre class="src src-sh">sbatch --partition=broadwl --wait
<span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/bash</span>
zcat fastqtl_qqnorm_RNAseq_run.fixed.txt.gz | awk -vOFS=<span class="org-string">'\t'</span> <span class="org-string">'NR == 1 {$4 = "pid" OFS "gid" OFS "strand"; for (i = 5; i &lt;= NF; i++) {$i = "NA"$i} print} NR &gt; 1 {$4 = $4 OFS $4 OFS "+"; $3 = $2; print}'</span> &gt;test.bed
awk <span class="org-string">'NR == 1 {for (i = 2; i &lt;= NF; i++) {$i = "NA"$i}} {print}'</span> fasteqtl_PC_RNAseq_run.fixed.txt &gt;bulk-covars.txt
</pre>
</div>

<pre class="example">
Submitted batch job 44979838

</pre>

<p>
Check whether the FDR is properly controlled by permuting.
</p>

<div class="org-src-container">
<pre class="src src-ipython">np.random.seed(0)
<span class="org-variable-name">permutation</span> = bulk_expr.columns.values.copy()
np.random.shuffle(permutation[5:])
<span class="org-variable-name">bulk_expr.columns</span> = permutation

<span class="org-variable-name">covars</span> = (pd.read_table(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/reproduce-yang/covars.txt'</span>, sep=<span class="org-string">' '</span>)
          .rename(columns={k: v <span class="org-keyword">for</span> k, v <span class="org-keyword">in</span> <span class="org-builtin">zip</span>(bulk_expr.columns, permutation)}))
covars.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/reproduce-yang/covars.txt'</span>, sep=<span class="org-string">' '</span>, index=<span class="org-constant">False</span>)
</pre>
</div>

<p>
Fix the TSS by rewriting the phenotype file.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">bulk_expr</span> = pd.read_table(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/reproduce-yang/test.bed'</span>, index_col=3)
<span class="org-variable-name">bulk_expr.index</span> = [x.split(<span class="org-string">'.'</span>)[0] <span class="org-keyword">for</span> x <span class="org-keyword">in</span> bulk_expr.index]
write_pheno_file(bulk_expr.iloc[:,5:], gene_info, <span class="org-string">'/scratch/midway2/aksarkar/singlecell/reproduce-yang/test.bed'</span>, holdout=<span class="org-constant">False</span>)
</pre>
</div>

<p>
Index the phenotype file.
</p>

<pre class="example">
Submitted batch job 44683584

</pre>

<p>
Run <code>qtltools</code>.
</p>

<pre class="example">
Submitted batch job 44683586

</pre>

<p>
Run <code>qtltools</code> on reprocessed dosages.
</p>

<pre class="example">
Submitted batch job 47427752

</pre>

<p>
Run <code>qtltools</code> on subsample.
</p>

<div class="org-src-container">
<pre class="src src-sh">awk <span class="org-string">'{print "NA" $0}'</span> subsample.excl &gt;subsample-qtltools.excl
</pre>
</div>

<pre class="example">
Submitted batch job 47428279

</pre>

<p>
Read <code>qtltools output</code>
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">bulk_qtls</span> = read_qtltools_output(<span class="org-string">'reproduce-yang/test'</span>)
</pre>
</div>

<p>
Check the beta approximation.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_approx_permutation(bulk_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/qqnorm-beta-approx.png" alt="qqnorm-beta-approx.png">
</p>
</div>

<p>
Plot a QQ plot of adjusted p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qqplot(bulk_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/qqnorm-qq.png" alt="qqnorm-qq.png">
</p>
</div>

<p>
Take QTLs with \(\mathrm{FDR} < 0.1\).
</p>

<div class="org-src-container">
<pre class="src src-ipython">bulk_qtls[<span class="org-string">'fdr_pass'</span>].<span class="org-builtin">sum</span>()
</pre>
</div>

<pre class="example">
1136

</pre>
</div>
</div>

<div id="outline-container-org58e4fcb" class="outline-3">
<h3 id="org58e4fcb">Recall bulk eQTLs from log CPM</h3>
<div class="outline-text-3" id="text-org58e4fcb">
<p>
Read the counts matrix.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">bulk_counts</span> = (pd.read_table(<span class="org-string">'/project2/gilad/singlecell-qtl/bulk/counts_RNAseq_iPSC.txt'</span>, sep=<span class="org-string">' '</span>, index_col=0)
               .rename(columns=<span class="org-keyword">lambda</span> x: <span class="org-string">'NA{}'</span>.<span class="org-builtin">format</span>(x))
               .rename(index=<span class="org-keyword">lambda</span> x: x.split(<span class="org-string">'.'</span>)[0]))
</pre>
</div>

<p>
Throw out individuals.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">with</span> <span class="org-builtin">open</span>(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/reproduce-yang/file_IPSC.excl'</span>) <span class="org-keyword">as</span> f:
  <span class="org-keyword">for</span> line <span class="org-keyword">in</span> f:
    <span class="org-variable-name">k</span> = <span class="org-string">'NA{}'</span>.<span class="org-builtin">format</span>(line.strip())
    <span class="org-keyword">if</span> k <span class="org-keyword">in</span> bulk_counts:
      <span class="org-keyword">del</span> bulk_counts[k]
</pre>
</div>

<p>
Normalize the counts matrix by computing log CPM. Normalizing by length is
unnecessary because we only ever compare counts for the same gene across
individuals.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">bulk_log_cpm</span> = (cpm(bulk_counts)
                .transform(<span class="org-keyword">lambda</span> x: (x - x.mean()) / x.std(), axis=1)
                .<span class="org-builtin">apply</span>(qqnorm, axis=0))
</pre>
</div>

<p>
Compute expression PCs.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">covars</span> = pd.DataFrame(skd.PCA(n_components=10).fit(bulk_log_cpm).components_, columns=bulk_log_cpm.columns)
<span class="org-variable-name">covars.index.name</span> = <span class="org-string">'id'</span>
covars.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/recall-bulk/log-cpm-covars.txt'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<p>
Check whether the false discovery rate is properly controlled by permuting
the data.
</p>

<p>
Write the phenotype matrix in <code>qtltools</code> format.  Use the annotation data
(ENSEMBL 75) in this repository to be consistent with the single cell
data. <b>Important: this loses 1716 genes (are they pseudogenes?)</b>
</p>

<div class="org-src-container">
<pre class="src src-ipython">write_pheno_file(
  bulk_log_cpm,
  gene_info,
  holdout=<span class="org-constant">False</span>,
  output_file=<span class="org-string">'/scratch/midway2/aksarkar/singlecell/recall-bulk/bulk-log-cpm.bed'</span>)
</pre>
</div>

<p>
Index the phenotype file.
</p>

<pre class="example">
Submitted batch job 44681764

</pre>

<p>
Ensure the dosage file follows the VCF standard. Add the prefix <code>NA</code> to sample IDs.
</p>

<div class="org-src-container">
<pre class="src src-sh">sbatch --partition=broadwl
<span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/bash</span>
zcat YRI_SNPs_2_IPSC.txt.gen.gz | awk -vOFS=<span class="org-string">'\t'</span> <span class="org-string">'BEGIN {print "##fileformat=VCFv4.2"; print "##FORMAT=&lt;ID=DS,Number=1,Type=Float&gt;"} NR == 1 {for (i = 10; i &lt;= NF; i++) {$i = "NA"$i}} {print}'</span> | bgzip &gt;yri-dosages.vcf.gz
tabix yri-dosages.vcf.gz
</pre>
</div>

<pre class="example">
Submitted batch job 44546926

</pre>

<p>
Run <code>qtltools</code>
</p>

<pre class="example">
Submitted batch job 44681768

</pre>

<p>
Read the output. <b>Important: this loses 201 genes (is this a bug in
<code>qtltools</code>)?</b>
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">bulk_cpm_qtls</span> = read_qtltools_output(<span class="org-string">'recall-bulk/bulk-log-cpm'</span>)
</pre>
</div>

<p>
Check the beta approximation.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_approx_permutation(bulk_cpm_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/bulk-cpm-beta-approx.png" alt="bulk-cpm-beta-approx.png">
</p>
</div>

<p>
Plot a QQ plot of adjusted p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qqplot(bulk_cpm_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/bulk-cpm-qq.png" alt="bulk-cpm-qq.png">
</p>
</div>

<p>
Take QTLs with \(\mathrm{FDR} < 0.1\).
</p>

<div class="org-src-container">
<pre class="src src-ipython">bulk_cpm_qtls[<span class="org-string">'fdr_pass'</span>].<span class="org-builtin">sum</span>()
</pre>
</div>

<pre class="example">
1276

</pre>
</div>
</div>

<div id="outline-container-orgf632212" class="outline-3">
<h3 id="orgf632212">Recall bulk eQTLs from log TPM</h3>
<div class="outline-text-3" id="text-orgf632212">
<p>
We <a href="kallisto.html">reprocessed the bulk RNA-Seq data</a> using <code>kallisto</code>. Read the TPM
matrix.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">bulk_log_tpm</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/kallisto/bulk-ipsc-tpm.txt.gz'</span>, header=<span class="org-constant">None</span>, sep=<span class="org-string">' '</span>)
<span class="org-variable-name">bulk_log_tpm</span> = np.log(bulk_log_tpm.pivot(columns=0, index=1, values=2) + 1)
<span class="org-variable-name">bulk_log_tpm.index</span> = [x.split(<span class="org-string">'.'</span>)[0] <span class="org-keyword">for</span> x <span class="org-keyword">in</span> bulk_log_tpm.index]
<span class="org-comment-delimiter"># </span><span class="org-comment">Important: need to throw out all zero rows because they blow up</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">standardization</span>
<span class="org-variable-name">bulk_log_tpm</span> = (bulk_log_tpm[bulk_log_tpm.<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: x.<span class="org-builtin">sum</span>() &gt; 0, axis=1)]
                .transform(<span class="org-keyword">lambda</span> x: (x - x.mean()) / x.std(), axis=1)
                .<span class="org-builtin">apply</span>(qqnorm, axis=0))
</pre>
</div>

<p>
To quantify how much power we expect to lose going from 58 to 53 individuals
(in our scRNA-Seq data), perform QTL mapping on a random subset of 53
individuals.
</p>

<div class="org-src-container">
<pre class="src src-ipython">np.random.seed(0)
<span class="org-variable-name">keep_inds</span> = np.random.choice(bulk_log_tpm.columns, size=53, replace=<span class="org-constant">False</span>)
<span class="org-variable-name">bulk_log_tpm</span> = bulk_log_tpm.<span class="org-builtin">filter</span>(items=keep_inds, axis=<span class="org-string">'columns'</span>)
</pre>
</div>

<p>
Get the TSS information. Use the annotation data (ENSEMBL 75) in this
repository to be consistent with the single cell data.
</p>

<p>
Write the phenotype matrix in <code>qtltools</code> format. <b>Important: this loses 1034
genes</b>
</p>

<div class="org-src-container">
<pre class="src src-ipython">write_pheno_file(
  bulk_log_tpm,
  gene_info,
  holdout=<span class="org-constant">False</span>,
  output_file=<span class="org-string">'/scratch/midway2/aksarkar/singlecell/recall-bulk/bulk-log-tpm.bed'</span>)
</pre>
</div>

<p>
Index the phenotype file.
</p>

<pre class="example">
Submitted batch job 47427500

</pre>

<p>
Compute principal components.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">covars</span> = pd.DataFrame(skd.PCA(n_components=6).fit(bulk_log_tpm).components_, columns=bulk_log_tpm.columns)
<span class="org-variable-name">covars.index.name</span> = <span class="org-string">'id'</span>
covars.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/recall-bulk/log-tpm-covars.txt'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<p>
Run <code>qtltools</code>
</p>

<pre class="example">
Submitted batch job 47427616

</pre>

<p>
Read the output. <b>Important: this loses 201 genes (is this a bug in
<code>qtltools</code>)?</b>
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">bulk_tpm_qtls</span> = read_qtltools_output(<span class="org-string">'recall-bulk/bulk-log-tpm'</span>)
</pre>
</div>

<p>
Check the beta approximation to the permuted p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_approx_permutation(bulk_tpm_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/bulk-tpm-beta-approx.png" alt="bulk-tpm-beta-approx.png">
</p>
</div>

<p>
Plot a QQ plot of the adjusted p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qqplot(bulk_tpm_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/bulk-log-tpm-qtl-qq.png" alt="bulk-log-tpm-qtl-qq.png">
</p>
</div>

<p>
Take QTLs with \(\mathrm{FDR} < 0.1\).
</p>

<div class="org-src-container">
<pre class="src src-ipython">bulk_tpm_qtls[<span class="org-string">'fdr_pass'</span>].<span class="org-builtin">sum</span>()
</pre>
</div>

<pre class="example">
683

</pre>
</div>
</div>

<div id="outline-container-org3420ec0" class="outline-3">
<h3 id="org3420ec0">Reprocess YRI dosages</h3>
<div class="outline-text-3" id="text-org3420ec0">
<p>
We have two individuals which weren't used in Banovich et al 2018, so we
don't have their genotypes. Reprocess the IMPUTE2 output to get the correct
dosage matrix.
</p>

<div class="org-src-container">
<pre class="src src-sh">rsync -au -f <span class="org-string">'+ */'</span> -f <span class="org-string">'+ *.impute2.gz'</span> -f <span class="org-string">'+ YRI_samples.txt'</span> -f <span class="org-string">'- *'</span> /mnt/lustre/data/internal/genotypes/hg19/YRI/ aksarkar@midway2.rcc.uchicago.edu:/scratch/midway2/aksarkar/singlecell/scqtl-mapping/
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">import</span> argparse
<span class="org-keyword">import</span> glob
<span class="org-keyword">import</span> gzip
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> pandas <span class="org-keyword">as</span> pd
<span class="org-keyword">import</span> sqlite3

<span class="org-keyword">def</span> <span class="org-function-name">convert_impute2_vcf</span>(<span class="org-builtin">file</span>, chrom, outfile, min_maf=0.05, mask=<span class="org-constant">None</span>):
  <span class="org-keyword">for</span> line <span class="org-keyword">in</span> <span class="org-builtin">file</span>:
    <span class="org-variable-name">record</span> = line.split()
    <span class="org-variable-name">posterior</span> = np.array([<span class="org-builtin">float</span>(x) <span class="org-keyword">for</span> x <span class="org-keyword">in</span> record[5:]])
    <span class="org-variable-name">dose</span> = posterior.reshape(-1, 3).dot(np.arange(3))
    <span class="org-keyword">if</span> mask <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
      <span class="org-variable-name">dose</span> = dose[mask]
    <span class="org-keyword">if</span> min_maf &lt;= dose.mean() / 2 &lt;= 1 - min_maf:
      <span class="org-keyword">print</span>(chrom, record[2], <span class="org-string">'{}.{}.{}'</span>.<span class="org-builtin">format</span>(record[1], chrom, record[2]),
            record[3], record[4], <span class="org-string">'.'</span>, <span class="org-string">'.'</span>, <span class="org-string">'.'</span>, <span class="org-string">'DS'</span>,
            *[<span class="org-string">'{:.3f}'</span>.<span class="org-builtin">format</span>(x) <span class="org-keyword">for</span> x <span class="org-keyword">in</span> dose], sep=<span class="org-string">'\t'</span>, <span class="org-builtin">file</span>=outfile)

<span class="org-variable-name">parser</span> = argparse.ArgumentParser()
parser.add_argument(<span class="org-string">'-s'</span>, <span class="org-string">'--subset'</span>, <span class="org-builtin">help</span>=<span class="org-string">'Sample inclusion list'</span>, <span class="org-builtin">type</span>=pd.read_table, default=<span class="org-constant">None</span>)
parser.add_argument(<span class="org-string">'-o'</span>, <span class="org-string">'--output'</span>, <span class="org-builtin">help</span>=<span class="org-string">'Output file'</span>, default=<span class="org-string">'dosages.vcf'</span>)
<span class="org-variable-name">args</span> = parser.parse_args()

<span class="org-variable-name">samples</span> = pd.read_table(<span class="org-string">'YRI_samples.txt'</span>, header=<span class="org-constant">None</span>, sep=<span class="org-string">' '</span>)
<span class="org-keyword">if</span> args.subset <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
  <span class="org-variable-name">mask</span> = samples[0].isin(args.subset).values
  <span class="org-variable-name">samples</span> = samples.loc[mask.values.ravel(), 0]
<span class="org-keyword">else</span>:
  <span class="org-variable-name">mask</span> = <span class="org-constant">None</span>
  <span class="org-variable-name">samples</span> = samples.loc[:,0]
<span class="org-keyword">with</span> <span class="org-builtin">open</span>(args.output, <span class="org-string">'w'</span>) <span class="org-keyword">as</span> f:
  <span class="org-keyword">print</span>(<span class="org-string">'##fileformat=VCFv4.2'</span>, <span class="org-builtin">file</span>=f)
  <span class="org-keyword">print</span>(<span class="org-string">'##FORMAT=&lt;ID=DS,Number=1,Type=Float&gt;'</span>, <span class="org-builtin">file</span>=f)
  <span class="org-keyword">print</span>(<span class="org-string">'#CHROM'</span>, <span class="org-string">'POS'</span>, <span class="org-string">'ID'</span>, <span class="org-string">'REF'</span>, <span class="org-string">'ALT'</span>, <span class="org-string">'QUAL'</span>, <span class="org-string">'FILTER'</span>, <span class="org-string">'INFO'</span>, <span class="org-string">'FORMAT'</span>, *samples, sep=<span class="org-string">'\t'</span>, <span class="org-builtin">file</span>=f)
  <span class="org-keyword">for</span> c <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1, 23):
    <span class="org-keyword">with</span> gzip.<span class="org-builtin">open</span>(<span class="org-string">'chr{}.hg19.impute2.gz'</span>.<span class="org-builtin">format</span>(c), <span class="org-string">'rt'</span>) <span class="org-keyword">as</span> g:
      convert_impute2_vcf(g, <span class="org-string">'chr{}'</span>.<span class="org-builtin">format</span>(c), outfile=f, mask=mask)
</pre>
</div>


<div class="org-src-container">
<pre class="src src-sh">sbatch --partition=broadwl -n1 -c28 --exclusive --mem=8G
<span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/bash</span>
<span class="org-builtin">source</span> activate scqtl
python /project2/mstephens/aksarkar/projects/singlecell-qtl/code/reprocess-dosage.py -o yri-120-dosages.vcf
bgzip --threads=28 yri-120-dosages.vcf
tabix yri-120-dosages.vcf.gz
</pre>
</div>

<pre class="example">
Submitted batch job 47228636

</pre>
</div>
</div>
</div>

<div id="outline-container-org36807e9" class="outline-2">
<h2 id="org36807e9">Analysis using counts</h2>
<div class="outline-text-2" id="text-org36807e9">
<p>
One obvious way to estimate means/variances to use as quantitative
phenotypes is to use the sample means/variances of the counts.
</p>
</div>

<div id="outline-container-org1e40348" class="outline-3">
<h3 id="org1e40348">Call eQTLs from pooled scRNA-Seq</h3>
<div class="outline-text-3" id="text-org1e40348">
<p>
Read the QC filters.
</p>

<div class="org-src-container">
<pre class="src src-ipython" id="orge34b9ab"><span class="org-variable-name">annotation</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-annotation.txt'</span>)
<span class="org-variable-name">keep_samples</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/quality-single-cells.txt'</span>, index_col=0, header=<span class="org-constant">None</span>)
<span class="org-variable-name">keep_genes</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/genes-pass-filter.txt'</span>, index_col=0, header=<span class="org-constant">None</span>)
<span class="org-variable-name">annotation</span> = annotation.loc[keep_samples.values.ravel()]
<span class="org-variable-name">keep_inds</span> = annotation.groupby(<span class="org-string">'chip_id'</span>).<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: <span class="org-builtin">len</span>(x) &gt;= 50)
</pre>
</div>

<p>
Read and pool the UMI data.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">pooled_counts</span> = pd.concat(
  [(chunk
    .<span class="org-builtin">filter</span>(items=keep_genes[keep_genes.values].index, axis=<span class="org-string">'index'</span>)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Important: this can't be done by filter because sample names are</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">different in the QC file</span>
    .loc[:,keep_samples.values.ravel()]
    .groupby(annotation[<span class="org-string">'chip_id'</span>].values, axis=1)
    .agg(np.<span class="org-builtin">sum</span>))
   <span class="org-keyword">for</span> chunk <span class="org-keyword">in</span>
   pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-counts.txt.gz'</span>,
                 chunksize=1000, index_col=0)])
</pre>
</div>

<p>
Normalize the pooled counts.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">pooled_counts</span> = (pooled_counts.loc[:,keep_inds]
              .transform(<span class="org-keyword">lambda</span> x: (x - x.mean()) / x.std(), axis=1)
              .<span class="org-builtin">apply</span>(qqnorm, axis=0))
</pre>
</div>

<p>
Compute principal components and write out the covariate file.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">covars</span> = pd.DataFrame(skd.PCA(n_components=10).fit(pooled_counts).components_, columns=pooled_counts.columns)
<span class="org-variable-name">covars.index.name</span> = <span class="org-string">'id'</span>
covars.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/counts/pooled-covars.txt'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<p>
Write out the phenotype file.
</p>

<div class="org-src-container">
<pre class="src src-ipython">write_pheno_file(pooled_counts, gene_info, holdout=<span class="org-constant">False</span>, output_file=<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/counts/pooled.bed'</span>)
</pre>
</div>

<p>
Index the phenotype file.
</p>

<pre class="example">
Submitted batch job 55769711

</pre>

<p>
Run <code>qtltools</code>
</p>

<p>
Read the output. <b>Important: this loses 200 genes (is this a bug in
<code>qtltools</code>)?</b>
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">pooled_qtls</span> = read_qtltools_output(<span class="org-string">'scqtl-mapping/counts/pooled'</span>)
</pre>
</div>

<p>
Check the beta approximation.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_approx_permutation(pooled_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/counts/pooled-beta-approx.png" alt="pooled-beta-approx.png">
</p>
</div>

<p>
Plot a QQ plot of the adjusted p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qqplot(pooled_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/counts/pooled-qtl-qq.png" alt="pooled-qtl-qq.png">
</p>
</div>

<p>
Take QTLs with \(\mathrm{FDR} < 0.1\).
</p>

<div class="org-src-container">
<pre class="src src-ipython">pooled_qtls[<span class="org-string">'fdr_pass'</span>].<span class="org-builtin">sum</span>()
</pre>
</div>

<pre class="example">
231

</pre>
</div>
</div>

<div id="outline-container-orgc6d4a8c" class="outline-3">
<h3 id="orgc6d4a8c">Call mean-QTLs</h3>
<div class="outline-text-3" id="text-orgc6d4a8c">
<p>
Read the count matrix.
</p>

<div class="org-src-container">
<pre class="src src-ipython" id="orgbaa030a"><span class="org-variable-name">umi</span> = pd.concat(
  [(chunk
    .<span class="org-builtin">filter</span>(items=keep_genes[keep_genes.values].index, axis=<span class="org-string">'index'</span>)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Important: this can't be done by filter because sample names are</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">different in the QC file</span>
    .loc[:,keep_samples.values.ravel()])
   <span class="org-keyword">for</span> chunk <span class="org-keyword">in</span>
   pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-counts.txt.gz'</span>,
                 chunksize=1000, index_col=0)])
</pre>
</div>

<p>
Compute the sample mean per individual, then normalize.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">sample_mean</span> = (umi
               .groupby(annotation[<span class="org-string">'chip_id'</span>].values, axis=1)
               .agg(np.mean)
               .transform(<span class="org-keyword">lambda</span> x: (x - x.mean()) / x.std(), axis=1)
               .<span class="org-builtin">apply</span>(qqnorm, axis=0))
</pre>
</div>

<p>
Compute principal components and write out the covariate file.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">covars</span> = pd.DataFrame(skd.PCA(n_components=10).fit(sample_mean).components_, columns=sample_mean.columns)
<span class="org-variable-name">covars.index.name</span> = <span class="org-string">'id'</span>
covars.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/counts/sample-mean-covars.txt'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<p>
Write out the <a href="https://qtltools.github.io/qtltools/pages/input_files.html">phenotype file</a> for <code>qtltools</code>. Hold out even chromosomes while
optimizing the power to detect eQTLs.
</p>

<div class="org-src-container">
<pre class="src src-ipython">write_pheno_file(
  sample_mean,
  gene_info,
  output_file=<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/counts/sample-mean.bed'</span>,
  holdout=<span class="org-constant">False</span>)
</pre>
</div>

<p>
Index the phenotype file.
</p>

<pre class="example">
Submitted batch job 55770738

</pre>

<p>
Run <code>qtltools</code>.
</p>

<pre class="example">
Submitted batch job 55770741

</pre>

<p>
Read the output.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">sample_mean_qtls</span> = read_qtltools_output(<span class="org-string">'scqtl-mapping/counts/sample-mean'</span>)
</pre>
</div>

<p>
Check the beta approximation to the permutation p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_approx_permutation(sample_mean_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/counts/sample-mean-qtl-beta-approx.png" alt="sample-mean-qtl-beta-approx.png">
</p>
</div>

<p>
Plot a QQ plot of the adjusted p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qqplot(sample_mean_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/counts/sample-mean-qtl-qq.png" alt="sample-mean-qtl-qq.png">
</p>
</div>

<p>
Take QTLs at FDR 10%.
</p>

<div class="org-src-container">
<pre class="src src-ipython">sample_mean_qtls[<span class="org-string">'fdr_pass'</span>].<span class="org-builtin">sum</span>()
</pre>
</div>

<pre class="example">
268

</pre>
</div>
</div>

<div id="outline-container-orga0a6e81" class="outline-3">
<h3 id="orga0a6e81">Call variance-QTLs</h3>
<div class="outline-text-3" id="text-orga0a6e81">
<p>
Read the UMI matrix.
</p>

<p>
Compute the sample variance per individual, then normalize.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">sample_var</span> = (umi
              .groupby(annotation[<span class="org-string">'chip_id'</span>].values, axis=1)
              .agg(np.var)
              .transform(<span class="org-keyword">lambda</span> x: (x - x.mean()) / x.std(), axis=1)
              .<span class="org-builtin">apply</span>(qqnorm, axis=0))
</pre>
</div>

<p>
Compute principal components and write out the covariate file.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">covars</span> = pd.DataFrame(skd.PCA(n_components=2).fit(sample_var).components_, columns=sample_var.columns)
<span class="org-variable-name">covars.index.name</span> = <span class="org-string">'id'</span>
covars.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/counts/sample-var-covars.txt'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<p>
Write out the <a href="https://qtltools.github.io/qtltools/pages/input_files.html">phenotype file</a> for <code>qtltools</code>. Hold out even chromosomes while
optimizing the power to detect eQTLs.
</p>

<div class="org-src-container">
<pre class="src src-ipython">write_pheno_file(sample_var, gene_info, <span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/counts/sample-var.bed'</span>, holdout=<span class="org-constant">False</span>)
</pre>
</div>

<p>
Index the phenotype file.
</p>

<pre class="example">
Submitted batch job 55770997

</pre>

<p>
Run <code>qtltools</code>.
</p>

<pre class="example">
Submitted batch job 55771003

</pre>

<p>
Read the output.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">sample_var_qtls</span> = read_qtltools_output(<span class="org-string">'scqtl-mapping/counts/sample-var'</span>)
</pre>
</div>

<p>
Check the beta approximation to the permutation p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_approx_permutation(sample_var_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/counts/sample-var-qtl-beta-approx.png" alt="sample-var-qtl-beta-approx.png">
</p>
</div>

<p>
Plot a QQ plot of the adjusted p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qqplot(sample_var_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/counts/sample-var-qtl-qq.png" alt="sample-var-qtl-qq.png">
</p>
</div>

<p>
Take QTLs at FDR 10%.
</p>

<div class="org-src-container">
<pre class="src src-ipython">sample_var_qtls[<span class="org-string">'fdr_pass'</span>].<span class="org-builtin">sum</span>()
</pre>
</div>

<pre class="example">
94

</pre>
</div>
</div>

<div id="outline-container-org9272ecc" class="outline-3">
<h3 id="org9272ecc">Call CV-QTLs</h3>
<div class="outline-text-3" id="text-org9272ecc">
<p>
Compute the sample CV per individual per gene, then normalize.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">sample_cv</span> = (umi
             .groupby(annotation[<span class="org-string">'chip_id'</span>].values, axis=1)
             .agg(<span class="org-keyword">lambda</span> x: np.std(x, axis=1) / (np.mean(x, axis=1) + 1e-8))
             .transform(<span class="org-keyword">lambda</span> x: (x - x.mean()) / x.std(), axis=1)
             .<span class="org-builtin">apply</span>(qqnorm, axis=0))
</pre>
</div>

<p>
Write out the <a href="https://qtltools.github.io/qtltools/pages/input_files.html">phenotype file</a> for <code>qtltools</code>. Hold out even chromosomes while
optimizing the power to detect eQTLs.
</p>

<div class="org-src-container">
<pre class="src src-ipython">write_pheno_file(sample_cv, gene_info, <span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/counts/sample-cv.bed'</span>, holdout=<span class="org-constant">False</span>)
</pre>
</div>

<p>
Index the phenotype file.
</p>

<pre class="example">
Submitted batch job 55771641

</pre>

<p>
Run <code>qtltools</code>.
</p>

<pre class="example">
Submitted batch job 55771671

</pre>

<p>
Read the output.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">sample_cv_qtls</span> = read_qtltools_output(<span class="org-string">'scqtl-mapping/counts/sample-cv'</span>)
</pre>
</div>

<p>
Check the beta approximation to the permutation p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_approx_permutation(sample_cv_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/counts/sample-cv-qtl-beta-approx.png" alt="sample-cv-qtl-beta-approx.png">
</p>
</div>

<p>
Plot a QQ plot of the adjusted p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qqplot(sample_cv_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/counts/sample-cv-qtl-qq.png" alt="sample-cv-qtl-qq.png">
</p>
</div>

<p>
Take QTLs at FDR 10%.
</p>

<div class="org-src-container">
<pre class="src src-ipython">sample_cv_qtls[<span class="org-string">'fdr_pass'</span>].<span class="org-builtin">sum</span>()
</pre>
</div>

<pre class="example">
4

</pre>
</div>
</div>

<div id="outline-container-orgc1c6439" class="outline-3">
<h3 id="orgc1c6439">Call Fano-QTLs</h3>
<div class="outline-text-3" id="text-orgc1c6439">
<p>
Read the UMI matrix.
</p>

<p>
Compute the sample Fano factor per individual per gene, then normalize.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">sample_fano</span> = (umi
               .groupby(annotation[<span class="org-string">'chip_id'</span>].values, axis=1)
               .agg(<span class="org-keyword">lambda</span> x: np.var(x, axis=1) / (1e-8 + np.mean(x, axis=1)))
               .transform(<span class="org-keyword">lambda</span> x: (x - x.mean()) / x.std(), axis=1)
               .<span class="org-builtin">apply</span>(qqnorm, axis=0))
</pre>
</div>

<p>
Write out the <a href="https://qtltools.github.io/qtltools/pages/input_files.html">phenotype file</a> for <code>qtltools</code>. Hold out even chromosomes while
optimizing the power to detect eQTLs.
</p>

<div class="org-src-container">
<pre class="src src-ipython">write_pheno_file(sample_fano, gene_info, <span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/counts/sample_fano.bed'</span>, holdout=<span class="org-constant">False</span>)
</pre>
</div>

<p>
Index the phenotype file.
</p>

<pre class="example">
Submitted batch job 55771840

</pre>

<p>
Compute principal components and write out the covariate file.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">covars</span> = pd.DataFrame(skd.PCA(n_components=2).fit(sample_fano).components_, columns=sample_fano.columns)
<span class="org-variable-name">covars.index.name</span> = <span class="org-string">'id'</span>
covars.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/counts/sample-fano-covars.txt'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<p>
Run <code>qtltools</code>.
</p>

<pre class="example">
Submitted batch job 55771844

</pre>

<p>
Read the output.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">sample_fano_qtls</span> = read_qtltools_output(<span class="org-string">'scqtl-mapping/counts/sample_fano'</span>)
</pre>
</div>

<p>
Check the beta approximation to the permutation p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_approx_permutation(sample_fano_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/counts/sample-fano-qtl-beta-approx.png" alt="sample-fano-qtl-beta-approx.png">
</p>
</div>

<p>
Plot a QQ plot of the adjusted p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qqplot(sample_fano_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/counts/sample-fano-qtl-qq.png" alt="sample-fano-qtl-qq.png">
</p>
</div>

<p>
Take QTLs at FDR 10%.
</p>

<div class="org-src-container">
<pre class="src src-ipython">sample_fano_qtls[<span class="org-string">'fdr_pass'</span>].<span class="org-builtin">sum</span>()
</pre>
</div>

<pre class="example">
11

</pre>
</div>
</div>
</div>

<div id="outline-container-orgcbb0c05" class="outline-2">
<h2 id="orgcbb0c05">Analysis using log CPM</h2>
<div class="outline-text-2" id="text-orgcbb0c05">
<p>
The most obvious way to estimate means/variances to use as quantitative
phenotypes is to use the sample moments of per cell log CPM.
</p>

<p>
Care has to be taken in handling zero-observations. Simply ignoring them
leads to loss of power due to the pseudocount introduced in computing log
CPM. To see this, fix one individual, one gene, and let \(r\) denote the
observed count. Then,
</p>

<p>
\[ \log\mathrm{CPM} \propto \ln(r + \epsilon) - \ln\mathrm{const} \]
</p>

<p>
Let \(\mu = \mathbb{E}[r\,]\), \(\sigma^2 = \mathbb{V}[r\,]\), expand to
second-order, then take expectations over cells:
</p>

<p>
\[ \mathbb{E}[\,\ln (r + \epsilon)\,] \approx \ln(\mu + \epsilon) -
   \frac{\sigma^2}{(\mu + \epsilon)^2} \]
</p>

<p>
\[ \mathbb{V}[\,\ln (r + \epsilon)\,] \approx \frac{2 \sigma^2}{(\mu +
   \epsilon)^2} - \frac{\sigma^4}{(\mu + \epsilon)^4} \]
</p>
</div>

<div id="outline-container-org3e27a23" class="outline-3">
<h3 id="org3e27a23">Call eQTLs from pooled scRNA-Seq</h3>
<div class="outline-text-3" id="text-org3e27a23">
<p>
Read the QC filters.
</p>

<div class="org-src-container">
<pre class="src src-ipython" id="orgd06b584"><span class="org-variable-name">annotation</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-annotation.txt'</span>)
<span class="org-variable-name">keep_samples</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/quality-single-cells.txt'</span>, index_col=0, header=<span class="org-constant">None</span>)
<span class="org-variable-name">keep_genes</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/genes-pass-filter.txt'</span>, index_col=0, header=<span class="org-constant">None</span>)
<span class="org-variable-name">annotation</span> = annotation.loc[keep_samples.values.ravel()]
<span class="org-variable-name">keep_inds</span> = annotation.groupby(<span class="org-string">'chip_id'</span>).<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: <span class="org-builtin">len</span>(x) &gt;= 50)
</pre>
</div>

<p>
Read and pool the UMI data.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">pooled_counts</span> = pd.concat(
  [(chunk
    .<span class="org-builtin">filter</span>(items=keep_genes[keep_genes.values].index, axis=<span class="org-string">'index'</span>)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Important: this can't be done by filter because sample names are</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">different in the QC file</span>
    .loc[:,keep_samples.values.ravel()]
    .groupby(annotation[<span class="org-string">'chip_id'</span>].values, axis=1)
    .agg(np.<span class="org-builtin">sum</span>))
   <span class="org-keyword">for</span> chunk <span class="org-keyword">in</span>
   pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-counts.txt.gz'</span>,
                 chunksize=1000, index_col=0)])
</pre>
</div>

<p>
Normalize the pooled counts.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">pooled_cpm</span> = (cpm(pooled_counts).loc[:,keep_inds]
              .transform(<span class="org-keyword">lambda</span> x: (x - x.mean()) / x.std(), axis=1)
              .<span class="org-builtin">apply</span>(qqnorm, axis=0))
</pre>
</div>

<p>
Compute principal components and write out the covariate file.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">covars</span> = pd.DataFrame(skd.PCA(n_components=10).fit(pooled_cpm).components_, columns=pooled_cpm.columns)
<span class="org-variable-name">covars.index.name</span> = <span class="org-string">'id'</span>
covars.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/counts/pooled-covars.txt'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<p>
Write out the phenotype file.
</p>

<div class="org-src-container">
<pre class="src src-ipython">write_pheno_file(pooled_cpm, gene_info, holdout=<span class="org-constant">False</span>, output_file=<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/counts/pooled.bed'</span>)
</pre>
</div>

<p>
Index the phenotype file.
</p>

<pre class="example">
Submitted batch job 55767633

</pre>

<p>
Run <code>qtltools</code>
</p>

<p>
Read the output. <b>Important: this loses 200 genes (is this a bug in
<code>qtltools</code>)?</b>
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">pooled_qtls</span> = read_qtltools_output(<span class="org-string">'scqtl-mapping/counts/pooled'</span>)
</pre>
</div>

<p>
Check the beta approximation.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_approx_permutation(pooled_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/counts/pooled-beta-approx.png" alt="pooled-beta-approx.png">
</p>
</div>

<p>
Plot a QQ plot of the adjusted p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qqplot(pooled_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/counts/pooled-qtl-qq.png" alt="pooled-qtl-qq.png">
</p>
</div>

<p>
Take QTLs with \(\mathrm{FDR} < 0.1\).
</p>

<div class="org-src-container">
<pre class="src src-ipython">pooled_qtls[<span class="org-string">'fdr_pass'</span>].<span class="org-builtin">sum</span>()
</pre>
</div>

<pre class="example">
261

</pre>
</div>
</div>

<div id="outline-container-orgf414a21" class="outline-3">
<h3 id="orgf414a21">Call mean-QTLs</h3>
<div class="outline-text-3" id="text-orgf414a21">
<p>
Throw out individuals with fewer than 50 cells.
</p>

<p>
Read the count matrix.
</p>

<div class="org-src-container">
<pre class="src src-ipython" id="org1ac3664"><span class="org-variable-name">umi</span> = pd.concat(
  [(chunk
    .<span class="org-builtin">filter</span>(items=keep_genes[keep_genes.values].index, axis=<span class="org-string">'index'</span>)
    <span class="org-comment-delimiter"># </span><span class="org-comment">Important: this can't be done by filter because sample names are</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">different in the QC file</span>
    .loc[:,keep_samples.values.ravel()])
   <span class="org-keyword">for</span> chunk <span class="org-keyword">in</span>
   pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-counts.txt.gz'</span>,
                 chunksize=1000, index_col=0)])
</pre>
</div>

<p>
We previously noted that 50 cells was sufficient to reliably estimate the
mean of single cell data. Therefore, throw out zeros from the analysis and
require that at least 50 samples have non-zero count.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">num_non_zero</span> = umi.groupby(annotation[<span class="org-string">'chip_id'</span>].values, axis=1).agg(<span class="org-keyword">lambda</span> x: (x &gt; 0).values.<span class="org-builtin">sum</span>(axis=1))
</pre>
</div>

<p>
Derive a cutoff for the number of individuals with at least 50 non-zero
observations per gene.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">num_individuals_pass</span> = (num_non_zero &gt; 50).agg(np.<span class="org-builtin">sum</span>, axis=1)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
<span class="org-variable-name">n</span>, <span class="org-variable-name">b</span>, <span class="org-variable-name">_</span> = plt.hist(num_individuals_pass, color=<span class="org-string">'k'</span>, bins=np.arange(0, 53, 2), histtype=<span class="org-string">'step'</span>, cumulative=<span class="org-constant">True</span>, normed=<span class="org-constant">True</span>)
plt.axhline(y=n[-2], c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
plt.xlabel(<span class="org-string">'Number of individuals with at least 50 non-zero observations'</span>)
<span class="org-variable-name">_</span> = plt.ylabel(<span class="org-string">'Cumulative fraction of genes'</span>)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/counts/num-individuals-pass.png" alt="num-individuals-pass.png">
</p>
</div>

<p>
Compute the sample mean log CPM per individual, then normalize.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">sample_mean</span> = (cpm(umi)
               .mask(umi == 0)
               .groupby(annotation[<span class="org-string">'chip_id'</span>].values, axis=1)
               .agg(np.mean)
               .loc[num_individuals_pass &gt;= 50,keep_inds]
               .transform(<span class="org-keyword">lambda</span> x: (x - x.mean()) / x.std(), axis=1)
               .<span class="org-builtin">apply</span>(qqnorm, axis=0))
</pre>
</div>

<p>
Compute principal components and write out the covariate file.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">covars</span> = pd.DataFrame(skd.PCA(n_components=10).fit(sample_mean).components_, columns=sample_mean.columns)
<span class="org-variable-name">covars.index.name</span> = <span class="org-string">'id'</span>
covars.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/counts/sample-mean-covars.txt'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<p>
Write out the <a href="https://qtltools.github.io/qtltools/pages/input_files.html">phenotype file</a> for <code>qtltools</code>. Hold out even chromosomes while
optimizing the power to detect eQTLs.
</p>

<div class="org-src-container">
<pre class="src src-ipython">write_pheno_file(
  sample_mean,
  gene_info,
  output_file=<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/counts/sample-mean.bed'</span>,
  holdout=<span class="org-constant">False</span>)
</pre>
</div>

<p>
Index the phenotype file.
</p>

<pre class="example">
Submitted batch job 55768305

</pre>

<p>
Run <code>qtltools</code>.
</p>

<pre class="example">
Submitted batch job 46254485

</pre>

<p>
Read the output.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">sample_mean_qtls</span> = read_qtltools_output(<span class="org-string">'scqtl-mapping/counts/sample-mean'</span>)
</pre>
</div>

<p>
Check the beta approximation to the permutation p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_approx_permutation(sample_mean_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/counts/sample-mean-qtl-beta-approx.png" alt="sample-mean-qtl-beta-approx.png">
</p>
</div>

<p>
Plot a QQ plot of the adjusted p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qqplot(sample_mean_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/counts/sample-mean-qtl-qq.png" alt="sample-mean-qtl-qq.png">
</p>
</div>

<p>
Take QTLs at FDR 10%.
</p>

<div class="org-src-container">
<pre class="src src-ipython">sample_mean_qtls[<span class="org-string">'fdr_pass'</span>].<span class="org-builtin">sum</span>()
</pre>
</div>

<pre class="example">
207

</pre>
</div>
</div>

<div id="outline-container-org7b5422f" class="outline-3">
<h3 id="org7b5422f">Call variance-QTLs</h3>
<div class="outline-text-3" id="text-org7b5422f">
<p>
Throw out individuals with fewer than 50 cells.
</p>

<p>
Read the UMI matrix.
</p>

<p>
Compute the sample variance of log CPM per individual, then normalize.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">sample_var</span> = (cpm(umi)
              .mask(umi == 0)
              .groupby(annotation[<span class="org-string">'chip_id'</span>].values, axis=1)
              .agg(np.var)
              .loc[num_individuals_pass &gt;= 50,keep_inds]
              .transform(<span class="org-keyword">lambda</span> x: (x - x.mean()) / x.std(), axis=1)
              .<span class="org-builtin">apply</span>(qqnorm, axis=0))
</pre>
</div>

<p>
Compute principal components and write out the covariate file.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">covars</span> = pd.DataFrame(skd.PCA(n_components=2).fit(sample_var).components_, columns=sample_var.columns)
<span class="org-variable-name">covars.index.name</span> = <span class="org-string">'id'</span>
covars.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/counts/sample-var-covars.txt'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<p>
Write out the <a href="https://qtltools.github.io/qtltools/pages/input_files.html">phenotype file</a> for <code>qtltools</code>. Hold out even chromosomes while
optimizing the power to detect eQTLs.
</p>

<div class="org-src-container">
<pre class="src src-ipython">write_pheno_file(sample_var, gene_info, <span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/counts/sample-var.bed'</span>, holdout=<span class="org-constant">False</span>)
</pre>
</div>

<p>
Index the phenotype file.
</p>

<pre class="example">
Submitted batch job 55769014

</pre>

<p>
Run <code>qtltools</code>.
</p>

<pre class="example">
Submitted batch job 55769016

</pre>

<p>
Read the output.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">sample_var_qtls</span> = read_qtltools_output(<span class="org-string">'scqtl-mapping/counts/sample-var'</span>)
</pre>
</div>

<p>
Check the beta approximation to the permutation p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_approx_permutation(sample_var_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/counts/sample-var-qtl-beta-approx.png" alt="sample-var-qtl-beta-approx.png">
</p>
</div>

<p>
Plot a QQ plot of the adjusted p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qqplot(sample_var_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/counts/sample-var-qtl-qq.png" alt="sample-var-qtl-qq.png">
</p>
</div>

<p>
Take QTLs at FDR 10%.
</p>

<div class="org-src-container">
<pre class="src src-ipython">sample_var_qtls[<span class="org-string">'fdr_pass'</span>].<span class="org-builtin">sum</span>()
</pre>
</div>

<pre class="example">
0

</pre>
</div>
</div>

<div id="outline-container-orga316a86" class="outline-3">
<h3 id="orga316a86">Call CV-QTLs</h3>
<div class="outline-text-3" id="text-orga316a86">
<p>
Throw out individuals with fewer than 50 cells.
</p>

<p>
Read the UMI matrix.
</p>

<p>
Compute the sample CV of log CPM per individual, then normalize.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">sample_cv</span> = (cpm(umi)
             .mask(umi == 0)
             .groupby(annotation[<span class="org-string">'chip_id'</span>].values, axis=1)
             .agg(<span class="org-keyword">lambda</span> x: np.std(x, axis=1) / (np.mean(x, axis=1) + 1e-8))
             .loc[num_individuals_pass &gt;= 50,keep_inds]
             .transform(<span class="org-keyword">lambda</span> x: (x - x.mean()) / x.std(), axis=1)
             .<span class="org-builtin">apply</span>(qqnorm, axis=0))
</pre>
</div>

<p>
Write out the <a href="https://qtltools.github.io/qtltools/pages/input_files.html">phenotype file</a> for <code>qtltools</code>. Hold out even chromosomes while
optimizing the power to detect eQTLs.
</p>

<div class="org-src-container">
<pre class="src src-ipython">write_pheno_file(sample_cv, gene_info, <span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/counts/sample-cv.bed'</span>, holdout=<span class="org-constant">False</span>)
</pre>
</div>

<p>
Index the phenotype file.
</p>

<pre class="example">
Submitted batch job 55769280

</pre>

<p>
Run <code>qtltools</code>.
</p>

<pre class="example">
Submitted batch job 55769282

</pre>

<p>
Read the output.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">sample_cv_qtls</span> = read_qtltools_output(<span class="org-string">'scqtl-mapping/counts/sample-cv'</span>)
</pre>
</div>

<p>
Check the beta approximation to the permutation p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_approx_permutation(sample_cv_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/counts/sample-cv-qtl-beta-approx.png" alt="sample-cv-qtl-beta-approx.png">
</p>
</div>

<p>
Plot a QQ plot of the adjusted p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qqplot(sample_cv_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/counts/sample-cv-qtl-qq.png" alt="sample-cv-qtl-qq.png">
</p>
</div>

<p>
Take QTLs at FDR 10%.
</p>

<div class="org-src-container">
<pre class="src src-ipython">sample_cv_qtls[<span class="org-string">'fdr_pass'</span>].<span class="org-builtin">sum</span>()
</pre>
</div>

<pre class="example">
3

</pre>
</div>
</div>

<div id="outline-container-org51712b9" class="outline-3">
<h3 id="org51712b9">Call Fano-QTLs</h3>
<div class="outline-text-3" id="text-org51712b9">
<p>
Throw out individuals with fewer than 50 cells.
</p>

<p>
Read the UMI matrix.
</p>

<p>
Fisher's index of dispersion is defined as \(V[x] / E[x]\). The Fano factor
is Fisher's index of dispersion over a fixed window (in our case, the total
number of reads).
</p>

<p>
Compute the sample Fano factor of log CPM per individual, then normalize.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">sample_fano</span> = (cpm(umi)
               .mask(umi == 0)
               .groupby(annotation[<span class="org-string">'chip_id'</span>].values, axis=1)
               .agg(<span class="org-keyword">lambda</span> x: np.var(x, axis=1) / (np.mean(x, axis=1)))
               .loc[num_individuals_pass &gt;= 50,keep_inds]
               .transform(<span class="org-keyword">lambda</span> x: (x - x.mean()) / x.std(), axis=1)
               .<span class="org-builtin">apply</span>(qqnorm, axis=0))
</pre>
</div>

<p>
Write out the <a href="https://qtltools.github.io/qtltools/pages/input_files.html">phenotype file</a> for <code>qtltools</code>. Hold out even chromosomes while
optimizing the power to detect eQTLs.
</p>

<div class="org-src-container">
<pre class="src src-ipython">write_pheno_file(sample_fano, gene_info, <span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/counts/sample_fano.bed'</span>, holdout=<span class="org-constant">False</span>)
</pre>
</div>

<p>
Index the phenotype file.
</p>

<pre class="example">
Submitted batch job 55769523

</pre>

<p>
Compute principal components and write out the covariate file.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">covars</span> = pd.DataFrame(skd.PCA(n_components=2).fit(sample_fano).components_, columns=sample_fano.columns)
<span class="org-variable-name">covars.index.name</span> = <span class="org-string">'id'</span>
covars.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/counts/sample-fano-covars.txt'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<p>
Run <code>qtltools</code>.
</p>

<pre class="example">
Submitted batch job 55769526

</pre>

<p>
Read the output.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">sample_fano_qtls</span> = read_qtltools_output(<span class="org-string">'scqtl-mapping/counts/sample_fano'</span>)
</pre>
</div>

<p>
Check the beta approximation to the permutation p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_approx_permutation(sample_fano_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/counts/sample-fano-qtl-beta-approx.png" alt="sample-fano-qtl-beta-approx.png">
</p>
</div>

<p>
Plot a QQ plot of the adjusted p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qqplot(sample_fano_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/counts/sample-fano-qtl-qq.png" alt="sample-fano-qtl-qq.png">
</p>
</div>

<p>
Take QTLs at FDR 10%.
</p>

<div class="org-src-container">
<pre class="src src-ipython">sample_fano_qtls[<span class="org-string">'fdr_pass'</span>].<span class="org-builtin">sum</span>()
</pre>
</div>

<pre class="example">
0

</pre>
</div>
</div>
</div>

<div id="outline-container-orgb470e33" class="outline-2">
<h2 id="orgb470e33">Analysis using ZINB</h2>
<div class="outline-text-2" id="text-orgb470e33">
</div>
<div id="outline-container-org5e2d9c2" class="outline-3">
<h3 id="org5e2d9c2">Call eQTLs</h3>
<div class="outline-text-3" id="text-org5e2d9c2">
<p>
Estimate the moments of latent gene expression. We have:
</p>

<p>
\[ \mathbb{E}[\lambda_{ijk}] = (1 - \pi_{ik}) \mu_{ik} \]
</p>

<p>
\[ \mathbb{V}[\lambda_{ijk}] = (1 - \pi_{ik}) \phi_{ik}^{-1} + \pi_{ik} (1 -
   \pi_{ik}) \mu_{ik}^2 \]
</p>

<div class="org-src-container">
<pre class="src src-ipython" id="org5a1b8ba"><span class="org-variable-name">log_mu</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-mu.txt.gz'</span>, index_col=0, sep=<span class="org-string">' '</span>)
<span class="org-variable-name">log_phi</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-phi.txt.gz'</span>, index_col=0, sep=<span class="org-string">' '</span>)
<span class="org-variable-name">logodds</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-logodds.txt.gz'</span>, index_col=0, sep=<span class="org-string">' '</span>)
<span class="org-keyword">for</span> x <span class="org-keyword">in</span> (log_mu, log_phi, logodds):
  <span class="org-keyword">del</span> x[<span class="org-string">'NA18498'</span>]

<span class="org-comment-delimiter"># </span><span class="org-comment">Important: log(sigmoid(x)) = -softplus(-x)</span>
<span class="org-variable-name">mean_by_ind</span> = np.exp(log_mu - np.log1p(np.exp(logodds)))
<span class="org-variable-name">variance_by_ind</span> = np.exp(2 * log_mu + log_phi - np.log1p(np.exp(logodds))) + np.exp(-np.log1p(np.exp(logodds)) - np.log1p(np.exp(-logodds)) + 2 * log_mu)
</pre>
</div>

<p>
Normalize the mean matrix analagous to the bulk data.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">mean</span> = (mean_by_ind
        .transform(<span class="org-keyword">lambda</span> x: (x - x.mean()) / x.std(), axis=1)
        .<span class="org-builtin">apply</span>(qqnorm, axis=0))
</pre>
</div>

<p>
Compute principal components of the mean matrix.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">covars</span> = pd.DataFrame(skd.PCA(n_components=10).fit(mean).components_, columns=mean.columns)
<span class="org-variable-name">covars.index.name</span> = <span class="org-string">'id'</span>
covars.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/zinb/mean-covars.txt'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<p>
Write out the <a href="https://qtltools.github.io/qtltools/pages/input_files.html">phenotype file</a> for <code>qtltools</code>. Hold out even chromosomes while
optimizing the power to detect eQTLs.
</p>

<div class="org-src-container">
<pre class="src src-ipython">write_pheno_file(mean, gene_info, <span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/zinb/mean.bed'</span>, holdout=<span class="org-constant">False</span>)
</pre>
</div>

<p>
Index the phenotype file.
</p>

<pre class="example">
Submitted batch job 55772051

</pre>

<p>
Run <code>qtltools</code>.
</p>

<pre class="example">
Submitted batch job 55772076

</pre>

<p>
Read the output.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">mean_qtls</span> = read_qtltools_output(<span class="org-string">'scqtl-mapping/zinb/mean'</span>)
</pre>
</div>

<p>
Check the beta approximation to the permutation p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_approx_permutation(mean_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/zinb/mean-qtl-beta-approx.png" alt="mean-qtl-beta-approx.png">
</p>
</div>

<p>
Plot a QQ plot of the adjusted p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qqplot(mean_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/zinb/mean-qtl-qq.png" alt="mean-qtl-qq.png">
</p>
</div>

<p>
Take QTLs at FDR 10%.
</p>

<div class="org-src-container">
<pre class="src src-ipython">mean_qtls[<span class="org-string">'fdr_pass'</span>].<span class="org-builtin">sum</span>()
</pre>
</div>

<pre class="example">
235

</pre>
</div>
</div>

<div id="outline-container-org6b97e20" class="outline-3">
<h3 id="org6b97e20">Fit multiplicative model</h3>
<div class="outline-text-3" id="text-org6b97e20">
<p>
Estimate the moments of latent gene expression. We have:
</p>

<p>
\[ \mathbb{E}[\lambda_{ijk}] = (1 - \pi_{ik}) \mu_{ik} \]
</p>

<p>
\[ \mathbb{V}[\lambda_{ijk}] = (1 - \pi_{ik}) \phi_{ik}^{-1} + \pi_{ik} (1 -
   \pi_{ik}) \mu_{ik}^2 \]
</p>

<div class="org-src-container">
<pre class="src src-ipython" id="orge4739dc"><span class="org-variable-name">log_mu</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-mu.txt.gz'</span>, index_col=0, sep=<span class="org-string">' '</span>)
<span class="org-variable-name">log_phi</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-phi.txt.gz'</span>, index_col=0, sep=<span class="org-string">' '</span>)
<span class="org-variable-name">logodds</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-logodds.txt.gz'</span>, index_col=0, sep=<span class="org-string">' '</span>)
<span class="org-keyword">for</span> x <span class="org-keyword">in</span> (log_mu, log_phi, logodds):
  <span class="org-keyword">del</span> x[<span class="org-string">'NA18498'</span>]

<span class="org-comment-delimiter"># </span><span class="org-comment">Important: log(sigmoid(x)) = -softplus(-x)</span>
<span class="org-variable-name">mean_by_ind</span> = np.exp(log_mu - np.log1p(np.exp(logodds)))
<span class="org-variable-name">variance_by_ind</span> = np.exp(2 * log_mu + log_phi - np.log1p(np.exp(logodds))) + np.exp(-np.log1p(np.exp(logodds)) - np.log1p(np.exp(-logodds)) + 2 * log_mu)
</pre>
</div>

<p>
Normalize the mean matrix analagous to the bulk data.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">multmean</span> = (np.log(mean_by_ind)
        .transform(<span class="org-keyword">lambda</span> x: (x - x.mean()) / x.std(), axis=1)
        .<span class="org-builtin">apply</span>(qqnorm, axis=0))
</pre>
</div>

<p>
Compute principal components of the mean matrix.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">covars</span> = pd.DataFrame(skd.PCA(n_components=10).fit(multmean).components_, columns=multmean.columns)
<span class="org-variable-name">covars.index.name</span> = <span class="org-string">'id'</span>
covars.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/zinb/multmean-covars.txt'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<p>
Write out the <a href="https://qtltools.github.io/qtltools/pages/input_files.html">phenotype file</a> for <code>qtltools</code>. Hold out even chromosomes while
optimizing the power to detect eQTLs.
</p>

<div class="org-src-container">
<pre class="src src-ipython">write_pheno_file(multmean, gene_info, <span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/zinb/multmean.bed'</span>, holdout=<span class="org-constant">False</span>)
</pre>
</div>

<p>
Index the phenotype file.
</p>

<pre class="example">
Submitted batch job 55772263

</pre>

<p>
Run <code>qtltools</code>.
</p>

<pre class="example">
Submitted batch job 55772298

</pre>

<p>
Read the output.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">multmean_qtls</span> = read_qtltools_output(<span class="org-string">'scqtl-mapping/zinb/mean'</span>)
</pre>
</div>

<p>
Check the beta approximation to the permutation p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_approx_permutation(multmean_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/zinb/multmean-qtl-beta-approx.png" alt="multmean-qtl-beta-approx.png">
</p>
</div>

<p>
Plot a QQ plot of the adjusted p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qqplot(multmean_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/zinb/multmean-qtl-qq.png" alt="multmean-qtl-qq.png">
</p>
</div>

<p>
Take QTLs at FDR 10%.
</p>

<div class="org-src-container">
<pre class="src src-ipython">multmean_qtls[<span class="org-string">'fdr_pass'</span>].<span class="org-builtin">sum</span>()
</pre>
</div>

<pre class="example">
235

</pre>
</div>
</div>

<div id="outline-container-orgdd7c4ab" class="outline-3">
<h3 id="orgdd7c4ab">Call &phi;-QTLs</h3>
<div class="outline-text-3" id="text-orgdd7c4ab">
<p>
Normalize the phenotype matrix.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">log_phi</span> = log_phi.transform(<span class="org-keyword">lambda</span> x: (x - x.mean()) / x.std(), axis=1).<span class="org-builtin">apply</span>(qqnorm, axis=1)
</pre>
</div>

<p>
Write out the phenotype file.
</p>

<div class="org-src-container">
<pre class="src src-ipython">write_pheno_file(log_phi, gene_info, holdout=<span class="org-constant">False</span>, output_file=<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/zinb/log_phi.bed'</span>)
</pre>
</div>

<p>
Index the phenotype file.
</p>

<pre class="example">
Submitted batch job 55772635

</pre>

<p>
Run <code>qtltools</code>.
</p>

<pre class="example">
Submitted batch job 55772639

</pre>

<p>
Read the output.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">log_phi_qtls</span> = read_qtltools_output(<span class="org-string">'scqtl-mapping/zinb/log_phi'</span>)
</pre>
</div>

<p>
Check the beta approximation to the permutation p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_approx_permutation(log_phi_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/zinb/phi-qtl-beta-approx.png" alt="phi-qtl-beta-approx.png">
</p>
</div>

<p>
Plot a QQ plot of the adjusted p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qqplot(log_phi_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/zinb/phi-qtl-qq.png" alt="phi-qtl-qq.png">
</p>
</div>

<p>
Take QTLs at FDR 10%.
</p>

<div class="org-src-container">
<pre class="src src-ipython">log_phi_qtls[<span class="org-string">'fdr_pass'</span>].<span class="org-builtin">sum</span>()
</pre>
</div>

<pre class="example">
0

</pre>
</div>
</div>

<div id="outline-container-orgf831642" class="outline-3">
<h3 id="orgf831642">Call variance-QTLs</h3>
<div class="outline-text-3" id="text-orgf831642">
<p>
Normalize the variance matrix.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">variance</span> = (variance_by_ind
            .transform(<span class="org-keyword">lambda</span> x: (x - x.mean()) / x.std(), axis=1)
            .<span class="org-builtin">apply</span>(qqnorm, axis=0))
</pre>
</div>

<p>
Compute principal components of the variance matrix.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">covars</span> = pd.DataFrame(skd.PCA(n_components=2).fit(variance).components_, columns=variance.columns)
<span class="org-variable-name">covars.index.name</span> = <span class="org-string">'id'</span>
covars.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/zinb/variance-covars.txt'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<p>
Write out the <a href="https://qtltools.github.io/qtltools/pages/input_files.html">phenotype file</a> for <code>qtltools</code>.
</p>

<div class="org-src-container">
<pre class="src src-ipython">write_pheno_file(variance, gene_info, <span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/zinb/variance.bed'</span>, holdout=<span class="org-constant">False</span>)
</pre>
</div>

<p>
Index the phenotype file.
</p>

<pre class="example">
Submitted batch job 55772747

</pre>

<p>
Run <code>qtltools</code>.
</p>

<pre class="example">
Submitted batch job 55772752

</pre>

<p>
Read the output.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">variance_qtls</span> = read_qtltools_output(<span class="org-string">'scqtl-mapping/zinb/variance'</span>)
</pre>
</div>

<p>
Check the beta approximation to the permutation p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_approx_permutation(variance_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/zinb/variance-qtl-beta-approx.png" alt="variance-qtl-beta-approx.png">
</p>
</div>

<p>
Plot a QQ plot of the adjusted p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qqplot(variance_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/zinb/variance-qtl-qq.png" alt="variance-qtl-qq.png">
</p>
</div>

<p>
Take QTLs at FDR 10%.
</p>

<div class="org-src-container">
<pre class="src src-ipython">variance_qtls[<span class="org-string">'fdr_pass'</span>].<span class="org-builtin">sum</span>()
</pre>
</div>

<pre class="example">
5

</pre>
</div>
</div>

<div id="outline-container-org416a231" class="outline-3">
<h3 id="org416a231">Call CV-QTLs</h3>
<div class="outline-text-3" id="text-org416a231">
<p>
Estimate the coefficient of variation.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">cv</span> = np.sqrt(variance_by_ind) / mean_by_ind
</pre>
</div>

<p>
Normalize the CV matrix.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">cv</span> = cv.transform(<span class="org-keyword">lambda</span> x: (x - x.mean()) / x.std(), axis=1).<span class="org-builtin">apply</span>(qqnorm, axis=0)
</pre>
</div>

<p>
Write out the <a href="https://qtltools.github.io/qtltools/pages/input_files.html">phenotype file</a> for <code>qtltools</code>. Hold out even chromosomes while
optimizing the power to detect eQTLs.
</p>

<div class="org-src-container">
<pre class="src src-ipython">write_pheno_file(cv, gene_info, <span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/zinb/cv.bed'</span>, holdout=<span class="org-constant">False</span>)
</pre>
</div>

<p>
Index the phenotype file.
</p>

<pre class="example">
Submitted batch job 55772866

</pre>

<p>
Run <code>qtltools</code>.
</p>

<pre class="example">
Submitted batch job 55772867

</pre>

<p>
Read the output.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">cv_qtls</span> = read_qtltools_output(<span class="org-string">'scqtl-mapping/zinb/cv'</span>)
</pre>
</div>

<p>
Check the beta approximation to the permutation p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_approx_permutation(cv_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/zinb/cv-qtl-beta-approx.png" alt="cv-qtl-beta-approx.png">
</p>
</div>

<p>
Plot a QQ plot of the adjusted p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qqplot(cv_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/zinb/cv-qtl-qq.png" alt="cv-qtl-qq.png">
</p>
</div>

<p>
Take QTLs at FDR 10%.
</p>

<div class="org-src-container">
<pre class="src src-ipython">cv_qtls[<span class="org-string">'fdr_pass'</span>].<span class="org-builtin">sum</span>()
</pre>
</div>

<pre class="example">
0

</pre>
</div>
</div>

<div id="outline-container-orgaa26c5a" class="outline-3">
<h3 id="orgaa26c5a">Call Fano-QTLs</h3>
<div class="outline-text-3" id="text-orgaa26c5a">
<p>
Estimate the coefficient of variation.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">fano</span> = variance_by_ind / mean_by_ind
</pre>
</div>

<p>
Normalize the Fano matrix.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">fano</span> = fano.transform(<span class="org-keyword">lambda</span> x: (x - x.mean()) / x.std(), axis=1).<span class="org-builtin">apply</span>(qqnorm, axis=0)
</pre>
</div>

<p>
Write out the <a href="https://qtltools.github.io/qtltools/pages/input_files.html">phenotype file</a> for <code>qtltools</code>. Hold out even chromosomes while
optimizing the power to detect eQTLs.
</p>

<div class="org-src-container">
<pre class="src src-ipython">write_pheno_file(fano, gene_info, <span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/zinb/fano.bed'</span>, holdout=<span class="org-constant">False</span>)
</pre>
</div>

<p>
Index the phenotype file.
</p>

<pre class="example">
Submitted batch job 55772970

</pre>

<p>
Run <code>qtltools</code>.
</p>

<pre class="example">
Submitted batch job 55772971

</pre>

<p>
Read the output.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">fano_qtls</span> = read_qtltools_output(<span class="org-string">'scqtl-mapping/zinb/fano'</span>)
</pre>
</div>

<p>
Check the beta approximation to the permutation p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_approx_permutation(fano_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/zinb/fano-qtl-beta-approx.png" alt="fano-qtl-beta-approx.png">
</p>
</div>

<p>
Plot a QQ plot of the adjusted p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qqplot(fano_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/zinb/fano-qtl-qq.png" alt="fano-qtl-qq.png">
</p>
</div>

<p>
Take QTLs at FDR 10%.
</p>

<div class="org-src-container">
<pre class="src src-ipython">fano_qtls[<span class="org-string">'fdr_pass'</span>].<span class="org-builtin">sum</span>()
</pre>
</div>

<pre class="example">
0

</pre>
</div>
</div>
</div>

<div id="outline-container-orga31f8af" class="outline-2">
<h2 id="orga31f8af">Explain away variance QTLs</h2>
<div class="outline-text-2" id="text-orga31f8af">
</div>
<div id="outline-container-orgdcaa8be" class="outline-3">
<h3 id="orgdcaa8be">Call variance-QTLs</h3>
<div class="outline-text-3" id="text-orgdcaa8be">
<p>
Regress out mean from variance.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">M</span> = mean_by_ind.transform(<span class="org-keyword">lambda</span> x: (x - x.mean()) / x.std(), axis=1)
<span class="org-variable-name">V</span> = variance_by_ind.transform(<span class="org-keyword">lambda</span> x: (x - x.mean()) / x.std(), axis=1)
<span class="org-variable-name">beta</span> = (M * V).<span class="org-builtin">sum</span>(axis=1) / M.shape[1]
</pre>
</div>

<p>
Normalize the variance matrix.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">resid</span> = ((V - M.mul(beta, axis=<span class="org-string">'index'</span>))
            .transform(<span class="org-keyword">lambda</span> x: (x - x.mean()) / x.std(), axis=1)
            .<span class="org-builtin">apply</span>(qqnorm, axis=0))
</pre>
</div>

<p>
Compute principal components of the resid matrix.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">covars</span> = pd.DataFrame(skd.PCA(n_components=2).fit(resid).components_, columns=resid.columns)
<span class="org-variable-name">covars.index.name</span> = <span class="org-string">'id'</span>
covars.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/zinb/resid-covars.txt'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<p>
Write out the <a href="https://qtltools.github.io/qtltools/pages/input_files.html">phenotype file</a> for <code>qtltools</code>.
</p>

<div class="org-src-container">
<pre class="src src-ipython">write_pheno_file(resid, gene_info, <span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/zinb/resid.bed'</span>, holdout=<span class="org-constant">False</span>)
</pre>
</div>

<p>
Index the phenotype file.
</p>

<pre class="example">
Submitted batch job 55773126

</pre>

<p>
Run <code>qtltools</code>.
</p>

<pre class="example">
Submitted batch job 55773130

</pre>

<p>
Read the output.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">resid_qtls</span> = read_qtltools_output(<span class="org-string">'scqtl-mapping/zinb/resid'</span>)
</pre>
</div>

<p>
Check the beta approximation to the permutation p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plot_approx_permutation(resid_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/zinb/resid-qtl-beta-approx.png" alt="resid-qtl-beta-approx.png">
</p>
</div>

<p>
Plot a QQ plot of the adjusted p-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qqplot(resid_qtls)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/zinb/resid-qtl-qq.png" alt="resid-qtl-qq.png">
</p>
</div>

<p>
Take QTLs at FDR 10%.
</p>

<div class="org-src-container">
<pre class="src src-ipython">resid_qtls[<span class="org-string">'fdr_pass'</span>].<span class="org-builtin">sum</span>()
</pre>
</div>

<pre class="example">
0

</pre>
</div>
</div>
</div>

<div id="outline-container-orgef0e820" class="outline-2">
<h2 id="orgef0e820">Write out the QTLs</h2>
<div class="outline-text-2" id="text-orgef0e820">
<div class="org-src-container">
<pre class="src src-sh">cp covars.txt bulk-covars.txt
cat test-qtl.*.txt | awk <span class="org-string">'BEGIN {print "gene", "chr", "start", "end", "strand", "num_vars", "distance", "id", "var_chr", "var_start", "var_end", "df", "dummy", "a", "b", "p_nominal", "beta", "p_empirical", "p_beta"} {print}'</span> | gzip &gt;bulk.txt.gz
cp test.bed.gz /project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-mapping/bulk.bed.gz
cp bulk-covars.txt bulk.txt.gz /project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-mapping/
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">sbatch --partition=mstephens
<span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/bash</span>
cat &gt;.rsync-filter &lt;&lt;EOF
<span class="org-sh-heredoc">+ */</span>
<span class="org-sh-heredoc">+ *.bed.gz</span>
<span class="org-sh-heredoc">+ *.txt.gz</span>
<span class="org-sh-heredoc">+ *covars*</span>
<span class="org-sh-heredoc">- *</span>
<span class="org-sh-heredoc">EOF</span>
<span class="org-keyword">function</span> <span class="org-function-name">z</span> {
    <span class="org-variable-name">pheno</span>=$(<span class="org-sh-quoted-exec">basename</span> $<span class="org-variable-name">1</span> -qtl.1.txt)
    <span class="org-variable-name">dir</span>=$(<span class="org-sh-quoted-exec">dirname</span> $(<span class="org-sh-quoted-exec">readlink</span> -f $<span class="org-variable-name">1</span>))
    <span class="org-builtin">test</span> $<span class="org-variable-name">1</span> -nt $<span class="org-variable-name">dir</span>/$<span class="org-variable-name">pheno</span>.txt.gz &amp;&amp; cat $<span class="org-variable-name">dir</span>/$<span class="org-variable-name">pheno</span>-qtl.*.txt | awk <span class="org-string">'BEGIN {print "gene", "chr", "start", "end", "strand", "num_vars", "distance", "id", "var_chr", "var_start", "var_end", "df", "dummy", "a", "b", "p_nominal", "beta", "p_empirical", "p_beta"} {print}'</span> | gzip &gt;$<span class="org-variable-name">dir</span>/$<span class="org-variable-name">pheno</span>.txt.gz;
}
<span class="org-builtin">export</span> -f z
find -name <span class="org-string">"*-qtl.1.txt"</span> | parallel -j1 z
rsync -FFau . /project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-mapping/
</pre>
</div>

<pre class="example">
Submitted batch job 55776894

</pre>
</div>

<div id="outline-container-org442eb7c" class="outline-3">
<h3 id="org442eb7c">QTL browser</h3>
<div class="outline-text-3" id="text-org442eb7c">
<p>
Read the QTLs.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">prefix</span> = <span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-mapping/'</span>
<span class="org-variable-name">qtls</span> = (pd.read_table(<span class="org-string">'{}/multmean.txt.gz'</span>.<span class="org-builtin">format</span>(prefix), sep=<span class="org-string">' '</span>)
        .sort_values(<span class="org-string">'p_beta'</span>)
        .head(n=100))
<span class="org-variable-name">norm</span> = (pd.read_table(<span class="org-string">'{}/multmean.bed.gz'</span>.<span class="org-builtin">format</span>(prefix))
        .set_index(<span class="org-string">'pid'</span>)
        .<span class="org-builtin">filter</span>(like=<span class="org-string">'NA'</span>, axis=<span class="org-string">'columns'</span>))
<span class="org-variable-name">X</span>, <span class="org-variable-name">Y</span> = extract_qtl_gene_pair(qtls, norm, <span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz'</span>)
</pre>
</div>

<p>
Read the un-normalized phenotypes.
</p>

<p>
Read the estimated standard errors.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">log_mean_sampling_var</span> = pd.read_table(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/power/log_mean-se.txt.gz'</span>, index_col=0)
<span class="org-variable-name">log_phi_sampling_var</span> = pd.read_table(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/power/disp-se.txt.gz'</span>, index_col=0)
</pre>
</div>

<p>
Annotate the genes with the estimated measurement error variances.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">W</span> = qtls.align(np.log(mean_by_ind), axis=<span class="org-string">'index'</span>, join=<span class="org-string">'inner'</span>)[1]
<span class="org-variable-name">Z</span> = qtls.align(log_mean_sampling_var, axis=<span class="org-string">'index'</span>, join=<span class="org-string">'inner'</span>)[1]
<span class="org-variable-name">qtls</span>[<span class="org-string">'log_mean_error_var'</span>] = Z.mean(axis=1)
<span class="org-variable-name">qtls</span>[<span class="org-string">'log_mean_resid_var'</span>] = W.var(axis=1) - Z.mean(axis=1)

<span class="org-variable-name">W</span> = qtls.align(log_phi, axis=<span class="org-string">'index'</span>, join=<span class="org-string">'inner'</span>)[1]
<span class="org-variable-name">Z</span> = qtls.align(log_phi_sampling_var, axis=<span class="org-string">'index'</span>, join=<span class="org-string">'inner'</span>)[1]
<span class="org-variable-name">qtls</span>[<span class="org-string">'log_phi_error_var'</span>] = Z.mean(axis=1)
<span class="org-variable-name">qtls</span>[<span class="org-string">'log_phi_resid_var'</span>] = W.var(axis=1) - Z.mean(axis=1)
</pre>
</div>

<p>
Read the un-normalized effect sizes.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">mean_stats</span> = pd.read_table(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/power/analytic/mean.txt.gz'</span>)
<span class="org-variable-name">disp_stats</span> = pd.read_table(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/power/analytic/disp.txt.gz'</span>)
</pre>
</div>

<p>
Read the fitted <code>ash</code> models.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">with</span> <span class="org-builtin">open</span>(<span class="org-string">'fold-change-ash-results.pkl'</span>, <span class="org-string">'rb'</span>) <span class="org-keyword">as</span> f:
  <span class="org-variable-name">ash_results</span> = pickle.load(f)
</pre>
</div>

<p>
Annotate the genes with the posterior marginal effect size.
</p>

<div class="org-src-container">
<pre class="src src-ipython">pandas2ri.activate()
<span class="org-variable-name">mean_stats_subset</span> = mean_stats.merge(qtls.reset_index(), left_on=[<span class="org-string">'gene'</span>, <span class="org-string">'Unnamed: 0'</span>], right_on=[<span class="org-string">'gene'</span>, <span class="org-string">'id'</span>], suffixes=[<span class="org-string">''</span>, <span class="org-string">'_norm'</span>])
<span class="org-variable-name">res</span> = ashr.ash(mean_stats_subset[<span class="org-string">'beta'</span>], mean_stats_subset[<span class="org-string">'se'</span>], fixg=<span class="org-constant">True</span>, g=ash_results[<span class="org-string">'mean'</span>].rx2(<span class="org-string">'fitted_g'</span>))
<span class="org-variable-name">mean_stats_subset</span>[<span class="org-string">'pm'</span>] = np.array(ashr.get_pm(res))
<span class="org-variable-name">mean_stats_subset</span>[<span class="org-string">'lfsr'</span>] = np.array(ashr.get_lfsr(res))

<span class="org-variable-name">disp_stats_subset</span> = disp_stats.merge(qtls.reset_index(), left_on=[<span class="org-string">'gene'</span>, <span class="org-string">'Unnamed: 0'</span>], right_on=[<span class="org-string">'gene'</span>, <span class="org-string">'id'</span>], suffixes=[<span class="org-string">''</span>, <span class="org-string">'_norm'</span>])
<span class="org-variable-name">res</span> = ashr.ash(disp_stats_subset[<span class="org-string">'beta'</span>], disp_stats_subset[<span class="org-string">'se'</span>], fixg=<span class="org-constant">True</span>, g=ash_results[<span class="org-string">'disp'</span>].rx2(<span class="org-string">'fitted_g'</span>))
<span class="org-variable-name">disp_stats_subset</span>[<span class="org-string">'pm'</span>] = np.array(ashr.get_pm(res))
<span class="org-variable-name">disp_stats_subset</span>[<span class="org-string">'lfsr'</span>] = np.array(ashr.get_lfsr(res))
</pre>
</div>

<p>
Read the counts.
</p>

<div class="org-src-container">
<pre class="src src-ipython">(mean_stats_subset
 .dropna()
 .merge(disp_stats_subset, on=[<span class="org-string">'Unnamed: 0'</span>, <span class="org-string">'gene'</span>, <span class="org-string">'log_mean_resid_var'</span>, <span class="org-string">'log_mean_error_var'</span>, <span class="org-string">'log_phi_resid_var'</span>, <span class="org-string">'log_phi_error_var'</span>], suffixes=[<span class="org-string">'_mean'</span>, <span class="org-string">'_disp'</span>])
 .merge(gene_info, left_on=<span class="org-string">'gene'</span>, right_index=<span class="org-constant">True</span>)
 .rename(columns={<span class="org-string">'Unnamed: 0'</span>: <span class="org-string">'id'</span>})
 [[<span class="org-string">'gene'</span>, <span class="org-string">'name'</span>, <span class="org-string">'id'</span>, <span class="org-string">'beta_mean'</span>, <span class="org-string">'pm_mean'</span>, <span class="org-string">'lfsr_mean'</span>, <span class="org-string">'beta_disp'</span>, <span class="org-string">'pm_disp'</span>, <span class="org-string">'lfsr_disp'</span>,
   <span class="org-string">'log_mean_resid_var'</span>, <span class="org-string">'log_mean_error_var'</span>, <span class="org-string">'log_phi_resid_var'</span>, <span class="org-string">'log_phi_error_var'</span>]]).head()
</pre>
</div>

<pre class="example">
gene    name                          id  beta_mean   pm_mean  \
0  ENSG00000005075  POLR2J  rs113524320.chr7.102091990  -0.133238 -0.122851
1  ENSG00000008394   MGST1    rs9332891.chr12.16503789  -0.052297 -0.048002
2  ENSG00000008988   RPS20    rs73679777.chr8.56987059  -0.051499 -0.049712
3  ENSG00000029639   TFB1M   rs79805895.chr6.155635281  -0.128963 -0.108330
4  ENSG00000042753   AP2S1   rs10569642.chr19.47352660  -0.045408 -0.035699

lfsr_mean  beta_disp   pm_disp  lfsr_disp  log_mean_resid_var  \
0  6.306067e-14   0.156411  0.084523   0.133519            0.018223
1  1.324717e-05  -0.031652 -0.002645   0.888211            0.003425
2  4.717338e-13  -0.104588 -0.006367   0.839005            0.000912
3  1.837927e-05  -0.010367 -0.000462   0.905676            0.025056
4  9.047097e-03  -0.129085 -0.009645   0.800620            0.001014

log_mean_error_var  log_phi_resid_var  log_phi_error_var
0            0.011825           0.088176           0.038666
1            0.003648           0.098297           0.023262
2            0.003831           0.332455           0.021787
3            0.014941           0.264272           0.140184
4            0.006730           0.295754           0.037082
</pre>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">with</span> sqlite3.connect(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/browser/browser.db'</span>) <span class="org-keyword">as</span> conn:
  (mean_stats_subset
   .dropna()
   .merge(disp_stats_subset, on=[<span class="org-string">'Unnamed: 0'</span>, <span class="org-string">'gene'</span>, <span class="org-string">'log_mean_resid_var'</span>, <span class="org-string">'log_mean_error_var'</span>, <span class="org-string">'log_phi_resid_var'</span>, <span class="org-string">'log_phi_error_var'</span>], suffixes=[<span class="org-string">'_mean'</span>, <span class="org-string">'_disp'</span>])
   .merge(gene_info, left_on=<span class="org-string">'gene'</span>, right_index=<span class="org-constant">True</span>)
   .rename(columns={<span class="org-string">'Unnamed: 0'</span>: <span class="org-string">'id'</span>})
   [[<span class="org-string">'gene'</span>, <span class="org-string">'name'</span>, <span class="org-string">'id'</span>, <span class="org-string">'beta_mean'</span>, <span class="org-string">'pm_mean'</span>, <span class="org-string">'lfsr_mean'</span>, <span class="org-string">'beta_disp'</span>, <span class="org-string">'pm_disp'</span>, <span class="org-string">'lfsr_disp'</span>,
     <span class="org-string">'log_mean_resid_var'</span>, <span class="org-string">'log_mean_error_var'</span>, <span class="org-string">'log_phi_resid_var'</span>, <span class="org-string">'log_phi_error_var'</span>]]
   .to_sql(<span class="org-string">'qtls'</span>, conn, index=<span class="org-constant">False</span>, if_exists=<span class="org-string">'replace'</span>))
  conn.execute(<span class="org-string">'create index ix_mean_qtls on qtls("gene");'</span>)

  (X.reset_index()
   .melt(id_vars=<span class="org-string">'index'</span>, var_name=<span class="org-string">'ind'</span>)
   .rename(columns={<span class="org-string">'index'</span>: <span class="org-string">'gene'</span>})
   .to_sql(<span class="org-string">'mean_qtl_geno'</span>, conn, index=<span class="org-constant">False</span>, if_exists=<span class="org-string">'replace'</span>))
  conn.execute(<span class="org-string">'create index ix_mean_qtl_geno on mean_qtl_geno("gene", "ind");'</span>)

  (Y.reset_index()
   .melt(id_vars=<span class="org-string">'index'</span>, var_name=<span class="org-string">'ind'</span>)
   .rename(columns={<span class="org-string">'index'</span>: <span class="org-string">'gene'</span>, <span class="org-string">'value'</span>: <span class="org-string">'norm'</span>})
   .merge(
     log_mu.reset_index().melt(id_vars=<span class="org-string">'gene'</span>, var_name=<span class="org-string">'ind'</span>).rename(columns={<span class="org-string">'value'</span>: <span class="org-string">'log_mu'</span>})
   )
   .merge(
     log_phi.reset_index().melt(id_vars=<span class="org-string">'gene'</span>, var_name=<span class="org-string">'ind'</span>).rename(columns={<span class="org-string">'value'</span>: <span class="org-string">'log_phi'</span>})
   )
   .merge(
     logodds.reset_index().melt(id_vars=<span class="org-string">'gene'</span>, var_name=<span class="org-string">'ind'</span>).rename(columns={<span class="org-string">'value'</span>: <span class="org-string">'logodds'</span>})     
   )
   .merge(
     np.log(mean_by_ind).reset_index().melt(id_vars=<span class="org-string">'gene'</span>, var_name=<span class="org-string">'ind'</span>).rename(columns={<span class="org-string">'value'</span>: <span class="org-string">'log_mean'</span>})
   )
   .merge(
     np.sqrt(log_mean_sampling_var).reset_index().melt(id_vars=<span class="org-string">'gene'</span>, var_name=<span class="org-string">'ind'</span>).rename(columns={<span class="org-string">'value'</span>: <span class="org-string">'log_mean_se'</span>})
   )
   .merge(
     np.sqrt(log_phi_sampling_var).reset_index().melt(id_vars=<span class="org-string">'gene'</span>, var_name=<span class="org-string">'ind'</span>).rename(columns={<span class="org-string">'value'</span>: <span class="org-string">'log_phi_se'</span>})     
   )
   .to_sql(<span class="org-string">'params'</span>, conn, index=<span class="org-constant">False</span>, if_exists=<span class="org-string">'replace'</span>))
  conn.execute(<span class="org-string">'create index ix_params on params("gene", "ind");'</span>)


  (umi.loc[qtls.index]
   .reset_index()
   .melt(id_vars=<span class="org-string">'gene'</span>, var_name=<span class="org-string">'sample'</span>)
   .to_sql(<span class="org-string">'umi'</span>, conn, index=<span class="org-constant">False</span>, if_exists=<span class="org-string">'replace'</span>))
  conn.execute(<span class="org-string">'create index ix_umi on umi("gene", "ind");'</span>)

  <span class="org-variable-name">annotations</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-annotation.txt'</span>)
  <span class="org-variable-name">annotations</span>[<span class="org-string">'sample'</span>] = annotations.<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: <span class="org-string">'{chip_id}.{experiment:08d}.{well}'</span>.<span class="org-builtin">format</span>(**<span class="org-builtin">dict</span>(x)), axis=1)
  <span class="org-variable-name">annotations</span>[<span class="org-string">'size'</span>] = annotations[<span class="org-string">'mol_hs'</span>]
  (annotations.loc[keep_samples.values.ravel(), [<span class="org-string">'sample'</span>, <span class="org-string">'chip_id'</span>, <span class="org-string">'size'</span>]]
   .to_sql(<span class="org-string">'annotation'</span>, con=conn, if_exists=<span class="org-string">'replace'</span>))
  conn.execute(<span class="org-string">'create index ix_annotation on annotation(chip_id, sample);'</span>)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orge536d76" class="outline-2">
<h2 id="orge536d76">QTL overlap</h2>
<div class="outline-text-2" id="text-orge536d76">
</div>
<div id="outline-container-org6af2200" class="outline-3">
<h3 id="org6af2200">Replication rates</h3>
<div class="outline-text-3" id="text-org6af2200">
<p>
Read the QTLs and normalized expression matrices.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">prefix</span> = <span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-mapping/'</span>
<span class="org-variable-name">qtls</span> = {pheno: [pd.read_table(<span class="org-string">'{}/{}.txt.gz'</span>.<span class="org-builtin">format</span>(prefix, pheno), sep=<span class="org-string">' '</span>),
                pd.read_table(<span class="org-string">'{}/{}.bed.gz'</span>.<span class="org-builtin">format</span>(prefix, pheno)).set_index(<span class="org-string">'pid'</span>).<span class="org-builtin">filter</span>(like=<span class="org-string">'NA'</span>, axis=<span class="org-string">'columns'</span>)]
        <span class="org-keyword">for</span> pheno <span class="org-keyword">in</span> [<span class="org-string">'bulk'</span>, <span class="org-string">'zinb/mean'</span>, <span class="org-string">'zinb/multmean'</span>, <span class="org-string">'zinb/variance'</span>, <span class="org-string">'zinb/cv'</span>, <span class="org-string">'zinb/fano'</span>]}
</pre>
</div>

<p>
Read covariates.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">base</span> = pathlib.Path(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-mapping/'</span>)
<span class="org-variable-name">covars</span> = [pd.read_table(base / <span class="org-string">'{}-covars.txt'</span>.<span class="org-builtin">format</span>(f), sep=<span class="org-string">'\s+'</span>, engine=<span class="org-string">'python'</span>, index_col=0)
          <span class="org-keyword">for</span> f <span class="org-keyword">in</span> (<span class="org-string">'bulk'</span>, <span class="org-string">'zinb/mean'</span>, <span class="org-string">'zinb/multmean'</span>, <span class="org-string">'zinb/variance'</span>)]
</pre>
</div>

<p>
The bulk QTL gene names need to be munged.
</p>

<div class="org-src-container">
<pre class="src src-ipython">qtls[<span class="org-string">'bulk'</span>][0][<span class="org-string">'gene'</span>] = qtls[<span class="org-string">'bulk'</span>][0][<span class="org-string">'gene'</span>].<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: x.split(<span class="org-string">'.'</span>)[0])
qtls[<span class="org-string">'bulk'</span>][1]<span class="org-variable-name">.index</span> = [x.split(<span class="org-string">'.'</span>)[0] <span class="org-keyword">for</span> x <span class="org-keyword">in</span> qtls[<span class="org-string">'bulk'</span>][1].index]
</pre>
</div>

<p>
Compute the gene-level FDR filter.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">for</span> k <span class="org-keyword">in</span> qtls:
  qtls[k][0][<span class="org-string">'fdr_pass'</span>] = bh(qtls[k][0][<span class="org-string">'p_beta'</span>]) &lt; 0.1
</pre>
</div>

<p>
Estimate replication rates for mean QTLs.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">pd.options.display.float_format</span> = <span class="org-string">'{:.3g}'</span>.<span class="org-builtin">format</span>
pairwise_replication(
  qtls,
  phenos=[<span class="org-string">'bulk'</span>, <span class="org-string">'zinb/mean'</span>, <span class="org-string">'zinb/multmean'</span>],
  ticks=[<span class="org-string">'Bulk'</span>, <span class="org-string">'Mean'</span>, <span class="org-string">'log mean'</span>],
  covars=covars[:3])
</pre>
</div>

<pre class="example">
Bulk  Mean  log mean
Bulk       100    79      78.9
Mean      80.4   100       100
log mean    82   100       100
</pre>

<p>
Estimate the rate at which variance QTLs replicate as mean QTLs (and vice versa).
</p>

<div class="org-src-container">
<pre class="src src-ipython">pairwise_replication(qtls,
                     phenos=[<span class="org-string">'zinb/mean'</span>, <span class="org-string">'zinb/variance'</span>, <span class="org-string">'zinb/cv'</span>, <span class="org-string">'zinb/fano'</span>],
                     ticks=[<span class="org-string">'Mean'</span>, <span class="org-string">'Variance'</span>, <span class="org-string">'CV'</span>, <span class="org-string">'Fano'</span>],
                     covars=[covars[1], covars[3], <span class="org-constant">None</span>, <span class="org-constant">None</span>])
</pre>
</div>

<pre class="example">
Mean  Variance   CV  Fano
Mean       100      85.1 42.6  66.4
Variance   100       100  100   100
CV         100       100  100   100
Fano       100       100  100   100
</pre>
</div>
</div>

<div id="outline-container-org28345be" class="outline-3">
<h3 id="org28345be">Relationship of \(p\)-values, effect sizes, and expression levels</h3>
<div class="outline-text-3" id="text-org28345be">
<p>
Compute relative abundance per individual.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">log_mu</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-mu.txt.gz'</span>, index_col=0, sep=<span class="org-string">' '</span>)
<span class="org-variable-name">logodds</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-logodds.txt.gz'</span>, index_col=0, sep=<span class="org-string">' '</span>)

<span class="org-variable-name">abundance</span> = log_mu - np.log1p(np.exp(logodds))
<span class="org-variable-name">abundance</span> -= sp.logsumexp(abundance, axis=0)
<span class="org-variable-name">abundance</span> /= np.log(2)
</pre>
</div>

<p>
Investigate whether variance QTL \(p\)-values are correlated with relative
abundance.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">variance_qtls</span> = qtls[<span class="org-string">'zinb/variance'</span>][0]
<span class="org-variable-name">thresh_pass</span> = variance_qtls[<span class="org-string">'p_beta'</span>] &lt; 1e-2
<span class="org-variable-name">var_qtl_abundance</span>, <span class="org-variable-name">var_qtl_stats</span> = abundance.align(variance_qtls[thresh_pass].set_index(<span class="org-string">'gene'</span>), axis=<span class="org-string">'index'</span>, join=<span class="org-string">'inner'</span>)
<span class="org-variable-name">fdr_pass</span> = var_qtl_stats[<span class="org-string">'fdr_pass'</span>]
</pre>
</div>

<p>
Count how many variance QTLs have \(p < 10^{-2}\)
</p>

<div class="org-src-container">
<pre class="src src-ipython">thresh_pass.<span class="org-builtin">sum</span>()
</pre>
</div>

<pre class="example">
121

</pre>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.errorbar(x=var_qtl_abundance.mean(axis=1), y=-np.log10(var_qtl_stats[<span class="org-string">'p_beta'</span>]), xerr=var_qtl_abundance.std(axis=1), fmt=<span class="org-string">'none'</span>, label=<span class="org-constant">None</span>, lw=1, ecolor=<span class="org-string">'.8'</span>, zorder=-1)
plt.scatter(x=var_qtl_abundance[fdr_pass].mean(axis=1), y=-np.log10(var_qtl_stats[fdr_pass][<span class="org-string">'p_beta'</span>]), c=<span class="org-string">'r'</span>, s=4, label=<span class="org-string">'FDR 10%'</span>)
plt.scatter(x=var_qtl_abundance[~fdr_pass].mean(axis=1), y=-np.log10(var_qtl_stats[~fdr_pass][<span class="org-string">'p_beta'</span>]), c=<span class="org-string">'k'</span>, s=4, label=<span class="org-string">'p &lt; 0.01'</span>)
plt.legend(loc=<span class="org-string">'upper left'</span>, frameon=<span class="org-constant">False</span>)
plt.xlabel(<span class="org-string">'$\log_2(\mathrm{relative\ abundance})$'</span>)
<span class="org-variable-name">_</span> = plt.ylabel(<span class="org-string">'Variance QTL $-\log_{10}(p)$'</span>)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/var-qtl-vs-log-mu.png" alt="var-qtl-vs-log-mu.png">
</p>
</div>

<p>
Make sure our effect sizes match <code>qtltools</code>.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">variance</span> = qtls[<span class="org-string">'zinb/variance'</span>][1]
<span class="org-variable-name">Xv</span>, <span class="org-variable-name">Yv</span> = extract_qtl_gene_pair(variance_qtls[thresh_pass], variance, dosages=<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz'</span>)
<span class="org-variable-name">Cv</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-mapping/variance-covars.txt'</span>, index_col=0)
<span class="org-variable-name">Cv</span> = Cv.align(Xv, axis=<span class="org-string">'columns'</span>, join=<span class="org-string">'inner'</span>)[0]
<span class="org-variable-name">my_var_qtl_stats</span> = replication_tests(Xv, Yv, Cv)
my_var_qtl_stats.merge(variance_qtls, on=<span class="org-string">'gene'</span>).<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: <span class="org-builtin">abs</span>(x[<span class="org-string">'beta_x'</span>] - x[<span class="org-string">'beta_y'</span>]), axis=1).describe()
</pre>
</div>

<pre class="example">
count       121
mean     0.0904
std       0.105
min     0.00246
25%      0.0255
50%      0.0601
75%       0.132
max       0.867
dtype: float64
</pre>

<p>
Look at the gene with max difference in estimated effect size.
</p>

<div class="org-src-container">
<pre class="src src-ipython">my_var_qtl_stats.iloc[my_var_qtl_stats.merge(variance_qtls, on=<span class="org-string">'gene'</span>).<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: <span class="org-builtin">abs</span>(x[<span class="org-string">'beta_x'</span>] - x[<span class="org-string">'beta_y'</span>]), axis=1).idxmax()]
</pre>
</div>

<pre class="example">
beta               20.3
gene    ENSG00000079102
p                 0.157
se                 14.4
Name: 116, dtype: object
</pre>

<p>
Estimate standard errors via the bootstrap.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">var_qtl_stats</span>[<span class="org-string">'bootstrap_se'</span>] = bootstrap_se(Xv, Yv, Cv)
<span class="org-variable-name">var_qtl_stats</span>[<span class="org-string">'se'</span>] = my_var_qtl_stats.set_index(<span class="org-string">'gene'</span>)[<span class="org-string">'se'</span>]
</pre>
</div>

<p>
Investigate whether analytic SEs are reasonable:
</p>

<div class="org-src-container">
<pre class="src src-ipython">var_qtl_stats[<span class="org-string">'se'</span>].describe()
</pre>
</div>

<pre class="example">
count       121
mean       0.18
std         1.3
min     0.00832
25%      0.0311
50%      0.0447
75%       0.078
max        14.4
Name: se, dtype: float64
</pre>

<div class="org-src-container">
<pre class="src src-ipython">var_qtl_stats[<span class="org-string">'bootstrap_se'</span>].describe()
</pre>
</div>

<pre class="example">
count      121
mean      1.22
std       9.12
min     0.0995
25%      0.178
50%      0.217
75%      0.285
max        100
Name: bootstrap_se, dtype: float64
</pre>

<p>
Plot analytic SEs against bootstrap SEs.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.gcf().set_size_inches(3, 3)
plt.scatter(var_qtl_stats[<span class="org-string">'se'</span>], var_qtl_stats[<span class="org-string">'bootstrap_se'</span>], s=1, c=<span class="org-string">'k'</span>)
plt.plot([0, 1], [0, 1], c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
plt.xlim([0, 1])
plt.ylim([0, 1])
plt.xlabel(<span class="org-string">'Analytic SE'</span>)
<span class="org-variable-name">_</span> = plt.ylabel(<span class="org-string">'Bootstrap SE'</span>)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/var-qtl-se.png" alt="var-qtl-se.png">
</p>
</div>

<p>
Compute \(z\)-scores using the bootstrap SEs.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">var_qtl_stats</span>[<span class="org-string">'z'</span>] = var_qtl_stats[<span class="org-string">'beta'</span>] / var_qtl_stats[<span class="org-string">'bootstrap_se'</span>]
</pre>
</div>

<p>
Compute a \(z\)-score from the estimated effect size and the \(p\)-value.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">var_qtl_stats</span>[<span class="org-string">'isf_z'</span>] = np.sign(var_qtl_stats[<span class="org-string">'beta'</span>]) * np.sqrt(st.chi2(1).isf(var_qtl_stats[<span class="org-string">'p_nominal'</span>]))
</pre>
</div>

<p>
Plot bootstrap \(z\)-scores against inverse-transformed \(z\)-scores.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.gcf().set_size_inches(3, 3)
plt.scatter(var_qtl_stats[<span class="org-string">'z'</span>], var_qtl_stats[<span class="org-string">'isf_z'</span>], s=3, c=<span class="org-string">'k'</span>)
plt.axhline(y=0, c=<span class="org-string">'k'</span>, lw=1)
plt.axvline(x=0, c=<span class="org-string">'k'</span>, lw=1)
plt.plot([-15, 15], [-15, 15], c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
plt.xlim([-15, 15])
plt.ylim([-15, 15])
plt.xlabel(<span class="org-string">'Bootstrap $z$-score'</span>)
<span class="org-variable-name">_</span> = plt.ylabel(<span class="org-string">'Inverse CDF $z$-score'</span>)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/bootstrap-z-vs-nominal-p-inverse-cdf.png" alt="bootstrap-z-vs-nominal-p-inverse-cdf.png">
</p>
</div>

<p>
Investigate whether \(z\)-scores based on bootstrap SEs agree with
permutation \(p\)-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.scatter(-np.log10(var_qtl_stats[fdr_pass][<span class="org-string">'p_beta'</span>]), var_qtl_stats[fdr_pass][<span class="org-string">'z'</span>], c=<span class="org-string">'r'</span>, label=<span class="org-string">'FDR 10%'</span>, s=4)
plt.scatter(-np.log10(var_qtl_stats[~fdr_pass][<span class="org-string">'p_beta'</span>]), var_qtl_stats[~fdr_pass][<span class="org-string">'z'</span>], c=<span class="org-string">'k'</span>, label=<span class="org-string">'p &lt; 0.01'</span>, s=4)
plt.xlabel(<span class="org-string">'Variance QTL $-\log_{10}(p)$'</span>)
plt.ylabel(<span class="org-string">'Variance QTL $z$-score'</span>)
</pre>
</div>

<pre class="example">
Text(0,0.5,'Variance QTL $z$-score')

</pre>

<div class="figure">
<p><img src="figure/qtl-mapping.org/var-qtl-z.png" alt="var-qtl-z.png">
</p>
</div>

<p>
Investigate whether variance QTL \(z\)-scores are correlated with relative
abundance.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">var_qtl_abundance</span> = var_qtl_abundance.align(var_qtl_stats, axis=<span class="org-string">'index'</span>, join=<span class="org-string">'inner'</span>)[0]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.errorbar(x=var_qtl_abundance.mean(axis=1), y=var_qtl_stats[<span class="org-string">'z'</span>], xerr=var_qtl_abundance.std(axis=1), fmt=<span class="org-string">'none'</span>, label=<span class="org-constant">None</span>, lw=1, ecolor=<span class="org-string">'.8'</span>, zorder=1)
plt.scatter(x=var_qtl_abundance[fdr_pass].mean(axis=1), y=var_qtl_stats[fdr_pass][<span class="org-string">'z'</span>], c=<span class="org-string">'r'</span>, s=2, label=<span class="org-string">'FDR 10%'</span>, zorder=2)
plt.scatter(x=var_qtl_abundance[~fdr_pass].mean(axis=1), y=var_qtl_stats[~fdr_pass][<span class="org-string">'z'</span>], c=<span class="org-string">'k'</span>, s=2, label=<span class="org-string">'p &lt; 0.01'</span>, zorder=2)
plt.legend(frameon=<span class="org-constant">False</span>)
plt.axhline(y=0, c=<span class="org-string">'k'</span>)
plt.xlabel(<span class="org-string">'$\log_2(\mathrm{relative\ abundance})$'</span>)
<span class="org-variable-name">_</span> = plt.ylabel(<span class="org-string">'Variance QTL $z$-score'</span>)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/var-qtl-z-vs-log-mu.png" alt="var-qtl-z-vs-log-mu.png">
</p>
</div>

<p>
Investigate whether variance QTL \(z\)-scores are correlated with mean QTL
\(z\)-scores.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">Xm</span>, <span class="org-variable-name">Ym</span> = extract_qtl_gene_pair(variance_qtls[thresh_pass], qtls[<span class="org-string">'zinb/mean'</span>][1], dosages=<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz'</span>)
<span class="org-variable-name">Cm</span> = covars[1]
<span class="org-variable-name">Cm</span> = Cm.align(Xm, axis=<span class="org-string">'columns'</span>, join=<span class="org-string">'inner'</span>)[0]
<span class="org-variable-name">var_qtl_stats</span>[<span class="org-string">'mean_beta'</span>] = replication_tests(Xm, Ym, Cm).set_index(<span class="org-string">'gene'</span>)[<span class="org-string">'beta'</span>]
<span class="org-variable-name">var_qtl_stats</span>[<span class="org-string">'mean_z'</span>] = var_qtl_stats[<span class="org-string">'mean_beta'</span>] / bootstrap_se(Xm, Ym, Cm)
</pre>
</div>

<p>
Plot variance QTL \(z\)-scores against pooled QTL \(z\)-scores.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">lim</span> = [-12, 12]
plt.clf()
plt.gcf().set_size_inches(3, 3)
plt.plot(lim, lim, c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
plt.scatter(var_qtl_stats[fdr_pass][<span class="org-string">'z'</span>], var_qtl_stats[fdr_pass][<span class="org-string">'mean_z'</span>], c=<span class="org-string">'r'</span>, s=3, label=<span class="org-string">'FDR 10%'</span>)
plt.scatter(var_qtl_stats[~fdr_pass][<span class="org-string">'z'</span>], var_qtl_stats[~fdr_pass][<span class="org-string">'mean_z'</span>], c=<span class="org-string">'k'</span>, s=3, label=<span class="org-string">'$p &lt; 10^{-2}$'</span>)
plt.legend(frameon=<span class="org-constant">False</span>, markerscale=2, loc=(-.01, .75))
plt.axhline(y=0, c=<span class="org-string">'k'</span>, lw=1)
plt.axvline(x=0, c=<span class="org-string">'k'</span>, lw=1)
plt.xlim(lim)
plt.ylim(lim)
plt.xlabel(<span class="org-string">'vQTL $z$-score'</span>)
<span class="org-variable-name">_</span> = plt.ylabel(<span class="org-string">'eQTL $z$-score'</span>)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/var-qtl-vs-mean-qtl.png" alt="var-qtl-vs-mean-qtl.png">
</p>
</div>

<p>
Compute the same in the other direction.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">mean_qtl_stats</span> = qtls[<span class="org-string">'zinb/mean'</span>][0]
<span class="org-variable-name">mean_qtl_stats</span> = mean_qtl_stats[mean_qtl_stats[<span class="org-string">'fdr_pass'</span>]].copy()
<span class="org-variable-name">X</span>, <span class="org-variable-name">Y</span> = extract_qtl_gene_pair(mean_qtl_stats, qtls[<span class="org-string">'zinb/mean'</span>][1], dosages=<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz'</span>)
<span class="org-variable-name">z</span> = mean_qtl_stats.set_index(<span class="org-string">'gene'</span>)[<span class="org-string">'beta'</span>] / bootstrap_se(X, Y, Cm)

<span class="org-variable-name">X</span>, <span class="org-variable-name">Y</span> = extract_qtl_gene_pair(mean_qtl_stats, qtls[<span class="org-string">'zinb/variance'</span>][1], dosages=<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz'</span>)
<span class="org-variable-name">vz</span> = replication_tests(X, Y, Cv).set_index(<span class="org-string">'gene'</span>)[<span class="org-string">'beta'</span>] / bootstrap_se(X, Y, Cv)

<span class="org-variable-name">Xb</span>, <span class="org-variable-name">Yb</span> = extract_qtl_gene_pair(mean_qtl_stats, qtls[<span class="org-string">'bulk'</span>][1], dosages=<span class="org-string">'/scratch/midway2/aksarkar/singlecell/scqtl-mapping/yri-120-dosages.vcf.gz'</span>)
<span class="org-variable-name">Cb</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-mapping/bulk-covars.txt'</span>, sep=r<span class="org-string">'\s+'</span>, engine=<span class="org-string">'python'</span>)
<span class="org-variable-name">Cb</span> = Cb.align(Xb, axis=<span class="org-string">'columns'</span>, join=<span class="org-string">'inner'</span>)[0]
<span class="org-variable-name">bulk_z</span> = replication_tests(Xb, Yb, Cb).set_index(<span class="org-string">'gene'</span>)[<span class="org-string">'beta'</span>] / bootstrap_se(Xb, Yb, Cb)

<span class="org-variable-name">mean_qtl_stats</span> = mean_qtl_stats.set_index(<span class="org-string">'gene'</span>)
<span class="org-variable-name">mean_qtl_stats</span>[<span class="org-string">'z'</span>] = z
<span class="org-variable-name">mean_qtl_stats</span>[<span class="org-string">'var_z'</span>] = vz
<span class="org-variable-name">mean_qtl_stats</span>[<span class="org-string">'bulk_z'</span>] = bulk_z
<span class="org-variable-name">mean_qtl_stats</span>[<span class="org-string">'var_fdr_pass'</span>] = mean_qtl_stats.index.isin(fdr_pass[fdr_pass].index)
</pre>
</div>

<p>
Plot mean vs. variance \(z\)-scores at eQTL SNP-gene pairs.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">lim</span> = [-12, 12]
plt.clf()
plt.gcf().set_size_inches(3, 3)
plt.plot(lim, lim, c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
plt.scatter(mean_qtl_stats.loc[mean_qtl_stats[<span class="org-string">'var_fdr_pass'</span>], <span class="org-string">'var_z'</span>],
            mean_qtl_stats.loc[mean_qtl_stats[<span class="org-string">'var_fdr_pass'</span>], <span class="org-string">'z'</span>], c=<span class="org-string">'r'</span>,
            s=3, label=<span class="org-string">'vQTL'</span>)
plt.scatter(mean_qtl_stats.loc[~mean_qtl_stats[<span class="org-string">'var_fdr_pass'</span>], <span class="org-string">'var_z'</span>],
            mean_qtl_stats.loc[~mean_qtl_stats[<span class="org-string">'var_fdr_pass'</span>], <span class="org-string">'z'</span>], c=<span class="org-string">'k'</span>,
            s=3, label=<span class="org-string">'Not vQTL'</span>)
plt.legend(frameon=<span class="org-constant">False</span>, markerscale=2, loc=(-.01, .75))
plt.axhline(y=0, c=<span class="org-string">'k'</span>, lw=1)
plt.axvline(x=0, c=<span class="org-string">'k'</span>, lw=1)
plt.xlim(lim)
plt.ylim(lim)
plt.xlabel(<span class="org-string">'vQTL $z$-score'</span>)
<span class="org-variable-name">_</span> = plt.ylabel(<span class="org-string">'eQTL $z$-score'</span>)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/mean-qtl-vs-var-qtl.png" alt="mean-qtl-vs-var-qtl.png">
</p>
</div>

<p>
Plot single cell eQTL \(z\)-scores against bulk eQTL \(z\)-scores.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">lim</span> = [-12, 12]
plt.clf()
plt.gcf().set_size_inches(3, 3)
plt.plot(lim, lim, c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
plt.scatter(mean_qtl_stats[<span class="org-string">'z'</span>], mean_qtl_stats[<span class="org-string">'bulk_z'</span>], c=<span class="org-string">'k'</span>, s=3)
plt.axhline(y=0, c=<span class="org-string">'k'</span>, lw=1)
plt.axvline(x=0, c=<span class="org-string">'k'</span>, lw=1)
plt.xlim(lim)
plt.ylim(lim)
plt.xlabel(<span class="org-string">'Single cell eQTL $z$-score'</span>)
<span class="org-variable-name">_</span> = plt.ylabel(<span class="org-string">'Bulk eQTL $z$-score'</span>)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/bulk-qtl-vs-mean-qtl.png" alt="bulk-qtl-vs-mean-qtl.png">
</p>
</div>
</div>
</div>

<div id="outline-container-org16e2f8b" class="outline-3">
<h3 id="org16e2f8b">Joint distribution of summary statistics</h3>
<div class="outline-text-3" id="text-org16e2f8b">
<p>
Read the nominal summary statistics.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">stats</span> = {x: pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/power/{}.txt.gz'</span>.<span class="org-builtin">format</span>(x), index_col=0)
         <span class="org-keyword">for</span> x <span class="org-keyword">in</span> (<span class="org-string">'bulk'</span>, <span class="org-string">'mean'</span>, <span class="org-string">'variance'</span>)}
</pre>
</div>

<p>
Compute \(z\)-scores.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">for</span> k <span class="org-keyword">in</span> stats:
  stats[k][<span class="org-string">'z'</span>] = stats[k][<span class="org-string">'beta'</span>] / stats[k][<span class="org-string">'se'</span>]
</pre>
</div>

<p>
Munge the bulk gene names.
</p>

<div class="org-src-container">
<pre class="src src-ipython">stats[<span class="org-string">'bulk'</span>][<span class="org-string">'gene'</span>] = [x.split(<span class="org-string">'.'</span>)[0] <span class="org-keyword">for</span> x <span class="org-keyword">in</span> stats[<span class="org-string">'bulk'</span>][<span class="org-string">'gene'</span>]]
</pre>
</div>

<p>
Munge the index names.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">for</span> k <span class="org-keyword">in</span> stats:
  stats[k]<span class="org-variable-name">.index.name</span> = <span class="org-string">'id'</span>
</pre>
</div>

<p>
Plot the joint distribution of bulk/mean \(z\)-scores.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">J</span> = stats[<span class="org-string">'mean'</span>].reset_index().merge(stats[<span class="org-string">'bulk'</span>].reset_index(), on=[<span class="org-string">'id'</span>, <span class="org-string">'gene'</span>])[[<span class="org-string">'z_x'</span>, <span class="org-string">'z_y'</span>]]
plt.clf()
plt.gcf().set_size_inches(3, 4)
plt.hexbin(J[<span class="org-string">'z_x'</span>], J[<span class="org-string">'z_y'</span>], gridsize=30, extent=[-10, 10, -10, 10], bins=<span class="org-string">'log'</span>, cmap=colorcet.cm[<span class="org-string">'gray_r'</span>])
plt.gca().set_aspect(<span class="org-string">'equal'</span>)
plt.xlim(-10, 10)
plt.ylim(-10, 10)
plt.plot(plt.ylim(), plt.ylim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
<span class="org-variable-name">cb</span> = plt.colorbar(orientation=<span class="org-string">'horizontal'</span>)
cb.set_label(<span class="org-string">'$\log_{10}$ number of SNP-gene pairs'</span>)
plt.xlabel(<span class="org-string">'Single cell eQTL $z$-score'</span>)
plt.ylabel(<span class="org-string">'Bulk eQTL $z$-score'</span>)
plt.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/bulk-sc-mean-joint-z.png" alt="bulk-sc-mean-joint-z.png">
</p>
</div>

<p>
Plot single cell eQTL \(z\)-scores against bulk eQTL \(z\)-scores.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">J</span> = (stats[<span class="org-string">'mean'</span>]
     .reset_index()
     .merge(qtls[<span class="org-string">'mean'</span>][0][qtls[<span class="org-string">'mean'</span>][0][<span class="org-string">'fdr_pass'</span>]], on=[<span class="org-string">'id'</span>, <span class="org-string">'gene'</span>])
     [[<span class="org-string">'id'</span>, <span class="org-string">'gene'</span>, <span class="org-string">'beta_x'</span>, <span class="org-string">'se'</span>]]
     .merge(stats[<span class="org-string">'bulk'</span>].reset_index(), on=[<span class="org-string">'id'</span>, <span class="org-string">'gene'</span>]))
<span class="org-variable-name">lim</span> = [-12, 12]
plt.clf()
plt.gcf().set_size_inches(3, 3)
plt.plot(lim, lim, c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
plt.scatter(J[<span class="org-string">'beta_x'</span>] / J[<span class="org-string">'se_x'</span>], J[<span class="org-string">'beta'</span>] / J[<span class="org-string">'se_y'</span>], c=<span class="org-string">'k'</span>, s=3)
plt.axhline(y=0, c=<span class="org-string">'k'</span>, lw=1)
plt.axvline(x=0, c=<span class="org-string">'k'</span>, lw=1)
plt.xlim(lim)
plt.ylim(lim)
plt.xlabel(<span class="org-string">'Single cell eQTL $z$-score'</span>)
<span class="org-variable-name">_</span> = plt.ylabel(<span class="org-string">'Bulk eQTL $z$-score'</span>)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/bulk-qtl-vs-mean-qtl.png" alt="bulk-qtl-vs-mean-qtl.png">
</p>
</div>

<p>
Plot the joint distribution of mean/variance \(z\)-scores.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">J</span> = stats[<span class="org-string">'mean'</span>].reset_index().merge(stats[<span class="org-string">'variance'</span>].reset_index(), on=[<span class="org-string">'id'</span>, <span class="org-string">'gene'</span>])[[<span class="org-string">'z_x'</span>, <span class="org-string">'z_y'</span>]]
plt.clf()
plt.gcf().set_size_inches(3, 4)
plt.hexbin(J[<span class="org-string">'z_x'</span>], J[<span class="org-string">'z_y'</span>], gridsize=30, extent=[-10, 10, -10, 10], bins=<span class="org-string">'log'</span>, cmap=colorcet.cm[<span class="org-string">'gray_r'</span>])
plt.gca().set_aspect(<span class="org-string">'equal'</span>)
plt.xlim(-12, 12)
plt.ylim(-12, 12)
plt.plot(plt.ylim(), plt.ylim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">'--'</span>, lw=1)
<span class="org-variable-name">cb</span> = plt.colorbar(orientation=<span class="org-string">'horizontal'</span>)
cb.set_label(<span class="org-string">'$\log_{10}$ number of SNP-gene pairs'</span>)
plt.xlabel(<span class="org-string">'Single cell eQTL $z$-score'</span>)
plt.ylabel(<span class="org-string">'vQTL $z$-score'</span>)
plt.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/sc-mean-variance-joint-z.png" alt="sc-mean-variance-joint-z.png">
</p>
</div>

<p>
Plot the significant SC vQTL \(z\)-scores, and their corresponding
\(z\)-score for the mean.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">J</span> = (stats[<span class="org-string">'variance'</span>]
     .reset_index()
     .merge(qtls[<span class="org-string">'variance'</span>][0][qtls[<span class="org-string">'variance'</span>][0][<span class="org-string">'fdr_pass'</span>]], on=[<span class="org-string">'id'</span>, <span class="org-string">'gene'</span>])
     [[<span class="org-string">'id'</span>, <span class="org-string">'gene'</span>, <span class="org-string">'beta_x'</span>, <span class="org-string">'se'</span>]]
     .merge(stats[<span class="org-string">'mean'</span>].reset_index(), on=[<span class="org-string">'id'</span>, <span class="org-string">'gene'</span>]))
<span class="org-variable-name">lim</span> = [-12, 12]
plt.clf()
plt.gcf().set_size_inches(3, 3)
plt.plot(lim, lim, c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
plt.scatter(J[<span class="org-string">'beta_x'</span>] / J[<span class="org-string">'se_x'</span>], J[<span class="org-string">'beta'</span>] / J[<span class="org-string">'se_y'</span>], c=<span class="org-string">'k'</span>, s=3)
plt.axhline(y=0, c=<span class="org-string">'k'</span>, lw=1)
plt.axvline(x=0, c=<span class="org-string">'k'</span>, lw=1)
plt.xlim(lim)
plt.ylim(lim)
plt.xlabel(<span class="org-string">'vQTL $z$-score'</span>)
<span class="org-variable-name">_</span> = plt.ylabel(<span class="org-string">'eQTL $z$-score'</span>)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/var-qtl-vs-mean-qtl.png" alt="var-qtl-vs-mean-qtl.png">
</p>
</div>

<p>
Plot the significant SC eQTL \(z\)-scores, and their corresponding
\(z\)-score for the mean.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">J</span> = (stats[<span class="org-string">'mean'</span>]
     .reset_index()
     .merge(qtls[<span class="org-string">'mean'</span>][0][qtls[<span class="org-string">'mean'</span>][0][<span class="org-string">'fdr_pass'</span>]], on=[<span class="org-string">'id'</span>, <span class="org-string">'gene'</span>])
     [[<span class="org-string">'id'</span>, <span class="org-string">'gene'</span>, <span class="org-string">'beta_x'</span>, <span class="org-string">'se'</span>]]
     .merge(stats[<span class="org-string">'variance'</span>].reset_index(), on=[<span class="org-string">'id'</span>, <span class="org-string">'gene'</span>])
     .merge(qtls[<span class="org-string">'variance'</span>][0], on=[<span class="org-string">'id'</span>, <span class="org-string">'gene'</span>], suffixes=[<span class="org-string">'_y'</span>, <span class="org-string">'_z'</span>], how=<span class="org-string">'left'</span>)
     .fillna(<span class="org-constant">False</span>))
<span class="org-variable-name">lim</span> = [-12, 12]
plt.clf()
plt.gcf().set_size_inches(3, 3)
plt.plot(lim, lim, c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
<span class="org-variable-name">colors</span> = {<span class="org-constant">True</span>: <span class="org-string">'r'</span>, <span class="org-constant">False</span>: <span class="org-string">'k'</span>}
<span class="org-variable-name">labels</span> = {<span class="org-constant">True</span>: <span class="org-string">'vQTL'</span>, <span class="org-constant">False</span>: <span class="org-string">'not vQTL'</span>}
<span class="org-keyword">for</span> k, g <span class="org-keyword">in</span> J.groupby(<span class="org-string">'fdr_pass'</span>):
  plt.scatter(g[<span class="org-string">'beta_x'</span>] / g[<span class="org-string">'se_x'</span>], g[<span class="org-string">'beta_y'</span>] / g[<span class="org-string">'se_y'</span>], c=colors[k], s=3, label=labels[k])
plt.legend(frameon=<span class="org-constant">False</span>, markerscale=2, handletextpad=0, loc=(-.01, .75))
plt.axhline(y=0, c=<span class="org-string">'k'</span>, lw=1)
plt.axvline(x=0, c=<span class="org-string">'k'</span>, lw=1)
plt.xlim(lim)
plt.ylim(lim)
plt.ylabel(<span class="org-string">'vQTL $z$-score'</span>)
<span class="org-variable-name">_</span> = plt.xlabel(<span class="org-string">'eQTL $z$-score'</span>)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/mean-qtl-vs-var-qtl.png" alt="mean-qtl-vs-var-qtl.png">
</p>
</div>
</div>
</div>

<div id="outline-container-org35950e4" class="outline-3">
<h3 id="org35950e4">Predicting mean QTLs from variance QTLs</h3>
<div class="outline-text-3" id="text-org35950e4">
<p>
As we change the threshold for calling mean (variance) QTLs, track the
precision and recall of variance (mean) QTLs.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.gcf().set_size_inches(3, 3)
<span class="org-variable-name">Y</span>, <span class="org-variable-name">P</span> = qtls[<span class="org-string">'mean'</span>][0][<span class="org-string">'fdr_pass'</span>].align(qtls[<span class="org-string">'variance'</span>][0][<span class="org-string">'p_beta'</span>].dropna(), join=<span class="org-string">'inner'</span>)
<span class="org-variable-name">p</span>, <span class="org-variable-name">r</span>, <span class="org-variable-name">_</span> = sklearn.metrics.precision_recall_curve(Y.astype(<span class="org-builtin">int</span>), -np.log(P))
<span class="org-variable-name">auprc_mean_var</span> = sklearn.metrics.average_precision_score(Y.astype(<span class="org-builtin">int</span>), -np.log(P))
plt.plot(r[::10], p[::10], lw=1, c=<span class="org-string">'k'</span>, label=<span class="org-string">'Variance'</span>)
<span class="org-variable-name">Y</span>, <span class="org-variable-name">P</span> = qtls[<span class="org-string">'variance'</span>][0][<span class="org-string">'fdr_pass'</span>].align(qtls[<span class="org-string">'mean'</span>][0][<span class="org-string">'p_beta'</span>].dropna(), join=<span class="org-string">'inner'</span>)
<span class="org-variable-name">p</span>, <span class="org-variable-name">r</span>, <span class="org-variable-name">_</span> = sklearn.metrics.precision_recall_curve(Y.astype(<span class="org-builtin">int</span>), -np.log(P))
<span class="org-variable-name">auprc_var_mean</span> = sklearn.metrics.average_precision_score(Y.astype(<span class="org-builtin">int</span>), -np.log(P))
plt.plot(r[::10], p[::10], lw=1, c=<span class="org-string">'r'</span>, label=<span class="org-string">'Mean'</span>)
plt.legend(frameon=<span class="org-constant">False</span>)
plt.xlabel(<span class="org-string">'Recall of QTLs at FDR 10%'</span>)
<span class="org-variable-name">_</span> = plt.ylabel(<span class="org-string">'Precision of QTLs at FDR 10%'</span>)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/var-qtl-mean-qtl-prc.png" alt="var-qtl-mean-qtl-prc.png">
</p>
</div>

<p>
Tabulate the AUPRC.
</p>

<div class="org-src-container">
<pre class="src src-ipython">auprc_mean_var, auprc_var_mean
</pre>
</div>

<pre class="example">
(0.5212419583724434, 0.6044457996921822)

</pre>

<p>
Track sensitivity and specificity of mean QTLs.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.gcf().set_size_inches(3, 3)
<span class="org-variable-name">Y</span>, <span class="org-variable-name">P</span> = qtls[<span class="org-string">'mean'</span>][0][<span class="org-string">'fdr_pass'</span>].align(qtls[<span class="org-string">'variance'</span>][0][<span class="org-string">'p_beta'</span>].dropna(), join=<span class="org-string">'inner'</span>)
<span class="org-variable-name">fpr</span>, <span class="org-variable-name">tpr</span>, <span class="org-variable-name">_</span> = sklearn.metrics.roc_curve(Y.astype(<span class="org-builtin">int</span>), -np.log(P))
<span class="org-variable-name">auroc_mean_var</span> = sklearn.metrics.roc_auc_score(Y.astype(<span class="org-builtin">int</span>), -np.log(P))
plt.plot(fpr[::10], tpr[::10], lw=1, c=<span class="org-string">'k'</span>, label=<span class="org-string">'Variance'</span>)
<span class="org-variable-name">Y</span>, <span class="org-variable-name">P</span> = qtls[<span class="org-string">'variance'</span>][0][<span class="org-string">'fdr_pass'</span>].align(qtls[<span class="org-string">'mean'</span>][0][<span class="org-string">'p_beta'</span>].dropna(), join=<span class="org-string">'inner'</span>)
<span class="org-variable-name">fpr</span>, <span class="org-variable-name">tpr</span>, <span class="org-variable-name">_</span> = sklearn.metrics.roc_curve(Y.astype(<span class="org-builtin">int</span>), -np.log(P))
<span class="org-variable-name">auroc_var_mean</span> = sklearn.metrics.roc_auc_score(Y.astype(<span class="org-builtin">int</span>), -np.log(P))
plt.plot(fpr[::10], tpr[::10], lw=1, c=<span class="org-string">'r'</span>, label=<span class="org-string">'Mean'</span>)
plt.legend(frameon=<span class="org-constant">False</span>)
plt.xlabel(<span class="org-string">'False positive rate of QTLs at FDR 10%'</span>)
<span class="org-variable-name">_</span> = plt.ylabel(<span class="org-string">'True positive rate of QTLs at FDR 10%'</span>)
</pre>
</div>


<div class="figure">
<p><img src="figure/qtl-mapping.org/var-qtl-mean-qtl-roc.png" alt="var-qtl-mean-qtl-roc.png">
</p>
</div>

<p>
Tabulate the AUROC.
</p>

<div class="org-src-container">
<pre class="src src-ipython">auroc_mean_var, auroc_var_mean
</pre>
</div>

<pre class="example">
(0.8968614143396433, 0.9555166119581557)

</pre>

<p>
Find the threshold at which 90% of eQTLs are recovered.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">Y</span>, <span class="org-variable-name">P</span> = qtls[<span class="org-string">'variance'</span>][0].set_index(<span class="org-string">'gene'</span>)[<span class="org-string">'fdr_pass'</span>].align(qtls[<span class="org-string">'mean'</span>][0].set_index(<span class="org-string">'gene'</span>)[<span class="org-string">'p_beta'</span>].dropna(), join=<span class="org-string">'inner'</span>)
<span class="org-variable-name">fpr</span>, <span class="org-variable-name">tpr</span>, <span class="org-variable-name">thresh</span> = sklearn.metrics.roc_curve(Y.astype(<span class="org-builtin">int</span>), -np.log(P))
np.exp(-thresh[np.where(tpr &lt;= 0.9)].<span class="org-builtin">min</span>())
</pre>
</div>

<pre class="example">
0.05222859999999999

</pre>

<p>
Find the vQTLs which are not predictive of eQTLs.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">true_negatives</span> = Y[np.logical_and(Y, -np.log(P) &lt; thresh[np.where(tpr &lt;= 0.9)].<span class="org-builtin">min</span>())].to_frame().merge(gene_info, left_index=<span class="org-constant">True</span>, right_index=<span class="org-constant">True</span>)[[<span class="org-string">'name'</span>]]
true_negatives
</pre>
</div>

<pre class="example">
name
gene
ENSG00000122574      WIPF3
ENSG00000112367       FIG4
ENSG00000121481       RNF2
ENSG00000214194  LINC00998
ENSG00000133935    C14orf1
ENSG00000243725       TTC4
ENSG00000132849      INADL
ENSG00000171130   ATP6V0E2
ENSG00000129518       EAPP
ENSG00000182400   TRAPPC6B
ENSG00000182117      NOP10
ENSG00000068024      HDAC4
ENSG00000169714       CNBP
ENSG00000133030      MPRIP
ENSG00000108528   SLC25A11
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Abhishek Sarkar</p>
<p class="date">Created: 2018-12-18 Tue 10:25</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
