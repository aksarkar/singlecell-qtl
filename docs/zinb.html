<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2018-03-19 Mon 14:54 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Mean/dispersion estimation</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Abhishek Sarkar">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
<style type="text/css">body {width: 60em; margin:auto} pre.src {overflow:auto}</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Mean/dispersion estimation</h1>

<div id="outline-container-orgde98ea2" class="outline-2">
<h2 id="orgde98ea2">Introduction</h2>
<div class="outline-text-2" id="text-orgde98ea2">
<p>
We take a modular approach to call QTLs:
</p>

<ol class="org-ol">
<li>Estimate a mean and a dispersion for each individual</li>
<li>Treat the mean/dispersion as continuous phenotypes and perform QTL mapping</li>
</ol>

<p>
Here, we solve (1).
</p>

<ol class="org-ol">
<li><a href="#org6ace9b3">We implement CPU-based ML estimation</a></li>
<li><a href="#orgebc1920">We estimate per-gene indexes of dispersion</a> accounting for the fact that
data came from multiple individuals</li>
</ol>
</div>
</div>

<div id="outline-container-org83e68c4" class="outline-2">
<h2 id="org83e68c4">Model specification</h2>
<div class="outline-text-2" id="text-org83e68c4">
<p>
Let \(r_{ijk}\) denote the number of molecules for individual \(i\), cell
\(j\), gene \(k\). Let \(R_{ij}\) denote a size factor for each cell. As a
first pass, define \(R_{ij} = \sum_k r_{ijk}\).
</p>

<p>
Following Hilbe 2012, we derive the negative binomial as a Poisson-Gamma
mixture:
</p>

<p>
\[ r_{ijk} \sim \text{Pois}(R_{ij} \mu_{ik} u_{ijk}) \]
</p>

<p>
\[ u_{ijk} \sim \text{Gamma}(\phi_{ik}^{-1}, \phi_{ik}^{-1}) \]
</p>

<p>
Here, \(\mu_{ik}u_{ijk}\) denotes relative expression
(<a href="https://arxiv.org/abs/1104.3889">Pachter 2011</a>). Marginalizing out \(u\)
yields the negative binomial distribution, with log likelihood:
</p>

<p>
\[ \ln p(r_{ijk} \mid R_{ij}, \mu_{ik}, \phi_{ik}) = r_{ijk} \ln\left(\frac{R_{ij}\mu_{ik}\phi_{ik}}{1 + R_{ij}\mu_{ik}\phi_{ik}}\right) - \phi_{ik}^{-1} \ln(1 + R_{ij}\mu_{ik}\phi_{ik}) + \ln \Gamma(r_{ijk} + \phi_{ik}^{-1}) - \ln \Gamma(r_{ijk} + 1) - \ln \Gamma(\phi^{-1}) \]
</p>

<p>
We have multiple data points (30-200 cells) per mean/dispersion parameter, so
simply minimizing the negative log likelihood should give reasonable
estimates.
</p>

<p>
We additionally account for zero-inflation, by letting \(\pi_{ik}\) denote
the probability of observing an excess zero (not arising from the
negative-binomial).
</p>

<p>
Then, the log-likelihood of the data is:
</p>

<p>
\[ \ln p(r_{ijk} \mid \cdot) = \ln(\pi_{ik} + (1 -  \pi_{ik}) p(r_{ijk}
    \mid R_{ij}, \mu_{ik}, \phi_{ik}))\ \text{if}\ r_{ijk} = 0 \]
\[ \ln p(r_{ijk} \mid \cdot) = \ln(1 - \pi_{ik}) + \ln p(r_{ijk} \mid
    R_{ij}, \mu_{ik}, \phi_{ik})\ \text{otherwise} \]
</p>
</div>
</div>

<div id="outline-container-org614c5c8" class="outline-2">
<h2 id="org614c5c8">Tensorflow implementation</h2>
<div class="outline-text-2" id="text-org614c5c8">
<p>
We optimize all of the parameters together, using one-hot encoding to map
parameters to data points. This makes inference more amenable to running on
the GPU.
</p>

<p>
Use <code>tensorflow</code> to automatically differentiate the negative log likelihood and
perform gradient descent.
</p>

<div class="org-src-container">
<pre class="src src-ipython" id="orgc619ce3"><span class="org-keyword">def</span> <span class="org-function-name">sigmoid</span>(x):
  <span class="org-doc">"""Numerically safe sigmoid"""</span>
  <span class="org-keyword">return</span> tf.clip_by_value(tf.sigmoid(x), -13, 13)

<span class="org-keyword">def</span> <span class="org-function-name">log</span>(x):
  <span class="org-doc">"""Numerically safe log"""</span>
  <span class="org-keyword">return</span> tf.log(x + 1e-8)

<span class="org-keyword">def</span> <span class="org-function-name">nb_llik</span>(x, mean, inv_disp):
  <span class="org-doc">"""Log likelihood of x distributed as NB</span>

<span class="org-doc">  See Hilbe 2012, eq. 8.10</span>

<span class="org-doc">  mean - mean (&gt; 0)</span>
<span class="org-doc">  inv_disp - inverse dispersion (&gt; 0)</span>

<span class="org-doc">  """</span>
  <span class="org-keyword">return</span> (x * log(mean / inv_disp) -
          x * log(1 + mean / inv_disp) -
          inv_disp * log(1 + mean / inv_disp) +
          tf.lgamma(x + inv_disp) -
          tf.lgamma(inv_disp) -
          tf.lgamma(x + 1))

<span class="org-keyword">def</span> <span class="org-function-name">zinb_llik</span>(x, mean, inv_disp, logodds, eps=1e-8):
  <span class="org-doc">"""Log likelihood of x distributed as ZINB</span>

<span class="org-doc">  See Hilbe 2012, eq. 11.12, 11.13</span>

<span class="org-doc">  mean - mean (&gt; 0)</span>
<span class="org-doc">  inv_disp - inverse dispersion (&gt; 0)</span>
<span class="org-doc">  logodds - dropout log odds</span>

<span class="org-doc">  """</span>
  <span class="org-variable-name">case_zero</span> = log(sigmoid(-logodds) + sigmoid(logodds) * tf.exp(nb_llik(x, mean, inv_disp)))
  <span class="org-variable-name">case_non_zero</span> = -tf.nn.softplus(logodds) + nb_llik(x, mean, inv_disp)
  <span class="org-keyword">return</span> tf.where(tf.less(x, 1e-8), case_zero, case_non_zero)

<span class="org-keyword">def</span> <span class="org-function-name">fit</span>(umi, onehot, size_factor, gene_dropout=<span class="org-constant">False</span>, ind_dropout=<span class="org-constant">False</span>, learning_rate=1e-2, max_epochs=1000):
  <span class="org-doc">"""Return estimated log mean and log dispersion. </span>

<span class="org-doc">  If fitting a zero-inflated model, additionally return dropout log odds.</span>

<span class="org-doc">  umi - count matrix (n x p; float32)</span>
<span class="org-doc">  onehot - mapping of individuals to cells (m x n; float32)</span>
<span class="org-doc">  size_factor - size factor vector (n x 1; float32)</span>
<span class="org-doc">  gene_dropout - fit one dropout parameter per gene</span>
<span class="org-doc">  ind_dropout - fit one dropout parameter per individual</span>
<span class="org-doc">  init_log_mean - initial value for estimated log mean (m x p; float32)</span>
<span class="org-doc">  init_log_disp - initial value for estimated log dispersion (m x p; float32)</span>

<span class="org-doc">  If ind_dropout is True, gene_dropout must be True, otherwise raises</span>
<span class="org-doc">  ArgumentError.</span>

<span class="org-doc">  Returns:</span>

<span class="org-doc">  log_mean - log mean parameter (m x p)</span>
<span class="org-doc">  log_disp - log dispersion parameter (m x p)</span>
<span class="org-doc">  dropout - dropout log odds (1 x p if gene_dropout, n x p if ind_dropout)</span>

<span class="org-doc">  """</span>
  <span class="org-variable-name">n</span>, <span class="org-variable-name">p</span> = umi.shape
  <span class="org-variable-name">_</span>, <span class="org-variable-name">m</span> = onehot.shape

  <span class="org-variable-name">params</span> = <span class="org-builtin">locals</span>()
  <span class="org-variable-name">graph</span> = tf.Graph()
  <span class="org-keyword">with</span> graph.as_default(), graph.device(<span class="org-string">'/gpu:*'</span>):
    <span class="org-variable-name">size_factor</span> = tf.Variable(size_factor, trainable=<span class="org-constant">False</span>)
    <span class="org-variable-name">umi</span> = tf.Variable(umi, trainable=<span class="org-constant">False</span>)
    <span class="org-variable-name">onehot</span> = tf.Variable(onehot, trainable=<span class="org-constant">False</span>)

    <span class="org-variable-name">mean</span> = tf.exp(tf.Variable(tf.zeros([m, p])))
    <span class="org-variable-name">inv_disp</span> = tf.exp(tf.Variable(tf.zeros([m, p])))

    <span class="org-keyword">if</span> gene_dropout:
      <span class="org-keyword">if</span> ind_dropout:
        <span class="org-variable-name">dropout_params</span> = tf.Variable(tf.zeros([m, p]))
        <span class="org-variable-name">dropout</span> = tf.matmul(onehot, dropout_params)
      <span class="org-keyword">else</span>:
        <span class="org-variable-name">dropout_params</span> = tf.Variable(tf.zeros([1, p]))
        <span class="org-variable-name">dropout</span> = dropout_params
      <span class="org-variable-name">llik</span> = tf.reduce_mean(
        zinb_llik(umi, size_factor * tf.matmul(onehot, mean),
                  tf.matmul(onehot, inv_disp), dropout))
    <span class="org-keyword">elif</span> ind_dropout:
      <span class="org-keyword">raise</span> <span class="org-type">ValueError</span>(<span class="org-string">'Cannot specify individual-specific dropout without gene-specific dropout'</span>)
    <span class="org-keyword">else</span>:
      <span class="org-variable-name">llik</span> = tf.reduce_mean(
        nb_llik(umi, size_factor * tf.matmul(onehot, mean),
                tf.matmul(onehot, inv_disp)))

    <span class="org-variable-name">train</span> = tf.train.AdamOptimizer(learning_rate=learning_rate).minimize(-llik)
    <span class="org-variable-name">opt</span> = [tf.log(mean), -tf.log(inv_disp)]
    <span class="org-keyword">if</span> gene_dropout:
      opt.append(dropout_params)
    <span class="org-variable-name">curr</span> = <span class="org-builtin">float</span>(<span class="org-string">'-inf'</span>)
    <span class="org-keyword">with</span> tf.Session() <span class="org-keyword">as</span> sess:
      sess.run(tf.global_variables_initializer())
      <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(max_epochs):
        <span class="org-variable-name">_</span>, <span class="org-variable-name">update</span> = sess.run([train, llik])
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> np.isfinite(update):
          <span class="org-keyword">raise</span> tf.train.NanLossDuringTrainingError
        <span class="org-keyword">if</span> <span class="org-keyword">not</span> i % 100:
          <span class="org-keyword">print</span>(i, update)
      <span class="org-keyword">return</span> sess.run(opt)
</pre>
</div>
</div>

<div id="outline-container-orgda943b5" class="outline-3">
<h3 id="orgda943b5">Read the data</h3>
<div class="outline-text-3" id="text-orgda943b5">
<p>
Read the QC'ed data.
</p>

<p>
Onehot-encode the samples.
</p>

<div class="org-src-container">
<pre class="src src-ipython" id="orgb1779d3"><span class="org-variable-name">individuals</span> = <span class="org-builtin">sorted</span>(annotations[<span class="org-string">'chip_id'</span>].unique())
<span class="org-variable-name">onehot</span> = np.zeros((umi.shape[1], <span class="org-builtin">len</span>(individuals)), dtype=np.float32)
onehot[np.arange(onehot.shape[0]),annotations[<span class="org-string">'chip_id'</span>].<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: individuals.index(x))] = 1
<span class="org-variable-name">onehot</span> = pd.DataFrame(onehot, columns=individuals, index=umi.columns)
onehot.shape
</pre>
</div>

<pre class="example">
(4995, 54)

</pre>

<p>
Check that one-hot encoding is OK:
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">for</span> _ <span class="org-keyword">in</span> <span class="org-builtin">range</span>(100):
  <span class="org-variable-name">gene</span> = np.random.choice(umi.index)
  <span class="org-variable-name">ind</span> = np.random.choice(individuals)
  <span class="org-variable-name">idx</span> = individuals.index(ind)
  <span class="org-keyword">assert</span> (umi.loc[gene, (annotations[<span class="org-string">'chip_id'</span>] == ind).values] == 
          umi.loc[gene, onehot.dot(np.eye(onehot.shape[1])[idx]).astype(<span class="org-builtin">bool</span>)]).<span class="org-builtin">all</span>()
</pre>
</div>
</div>
</div>

<div id="outline-container-orga1dc686" class="outline-3">
<h3 id="orga1dc686">Fit NB</h3>
<div class="outline-text-3" id="text-orga1dc686">
<p>
Estimate means and dispersions assuming no dropout.
</p>

<div class="org-src-container">
<pre class="src src-ipython">&lt;&lt;zinb-imports&gt;&gt;
&lt;&lt;tf-imports&gt;&gt;
&lt;&lt;zinb-impl&gt;&gt;
&lt;&lt;read-data-qc&gt;&gt;
&lt;&lt;onehot-qc&gt;&gt;
<span class="org-variable-name">mean</span>, <span class="org-variable-name">dispersion</span> = fit(
  umi=umi.values.T.astype(np.float32),
  onehot=onehot.values.astype(np.float32),
  size_factor=umi.agg(np.<span class="org-builtin">sum</span>).astype(np.float32).values.reshape(-1, 1),
  learning_rate=1e-2,
  max_epochs=8000)
pd.DataFrame(mean.T, index=umi.index, columns=onehot.columns).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/mean2.txt.gz'</span>, sep=<span class="org-string">' '</span>, compression=<span class="org-string">'gzip'</span>)
pd.DataFrame(dispersion.T, index=umi.index, columns=onehot.columns).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/dispersion2.txt.gz'</span>, sep=<span class="org-string">' '</span>, compression=<span class="org-string">'gzip'</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb50c3a6" class="outline-3">
<h3 id="orgb50c3a6">Fit ZINB</h3>
<div class="outline-text-3" id="text-orgb50c3a6">
<p>
Estimate the parameters of the zero-inflated model assuming dropout per gene.
</p>

<div class="org-src-container">
<pre class="src src-ipython">&lt;&lt;zinb-imports&gt;&gt;
&lt;&lt;tf-imports&gt;&gt;
&lt;&lt;zinb-impl&gt;&gt;
&lt;&lt;read-data-qc&gt;&gt;
&lt;&lt;onehot-qc&gt;&gt;
<span class="org-variable-name">mean</span>, <span class="org-variable-name">dispersion</span>, <span class="org-variable-name">dropout</span> = fit(
  umi=umi.values.T.astype(np.float32),
  onehot=onehot.values.astype(np.float32),
  size_factor=umi.agg(np.<span class="org-builtin">sum</span>).astype(np.float32).values.reshape(-1, 1),
  gene_dropout=<span class="org-constant">True</span>,
  learning_rate=1e-2,
  max_epochs=8000)
pd.DataFrame(mean.T, index=umi.index, columns=onehot.columns).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/zi-mean.txt.gz'</span>, sep=<span class="org-string">' '</span>, compression=<span class="org-string">'gzip'</span>)
pd.DataFrame(dispersion.T, index=umi.index, columns=onehot.columns).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/zi-dispersion.txt.gz'</span>, sep=<span class="org-string">' '</span>, compression=<span class="org-string">'gzip'</span>)
pd.DataFrame(dropout.T, index=umi.index).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/zi-dropout.txt.gz'</span>, sep=<span class="org-string">' '</span>, compression=<span class="org-string">'gzip'</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf48a12b" class="outline-3">
<h3 id="orgf48a12b">Fit ZINB2</h3>
<div class="outline-text-3" id="text-orgf48a12b">
<p>
Estimate the parameters of the zero-inflated model assuming dropout per
individual and gene.
</p>

<div class="org-src-container">
<pre class="src src-ipython">&lt;&lt;zinb-imports&gt;&gt;
&lt;&lt;tf-imports&gt;&gt;
&lt;&lt;zinb-impl&gt;&gt;
&lt;&lt;read-data-qc&gt;&gt;
&lt;&lt;onehot-qc&gt;&gt;
<span class="org-variable-name">mean</span>, <span class="org-variable-name">dispersion</span>, <span class="org-variable-name">dropout</span> = fit(
  umi=umi.values.T.astype(np.float32),
  onehot=onehot.values.astype(np.float32),
  size_factor=umi.agg(np.<span class="org-builtin">sum</span>).astype(np.float32).values.reshape(-1, 1),
  gene_dropout=<span class="org-constant">True</span>,
  ind_dropout=<span class="org-constant">True</span>,
  learning_rate=1e-2,
  max_epochs=8000)
pd.DataFrame(mean.T, index=umi.index, columns=onehot.columns).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/zi2-mean.txt.gz'</span>, sep=<span class="org-string">' '</span>, compression=<span class="org-string">'gzip'</span>)
pd.DataFrame(dispersion.T, index=umi.index, columns=onehot.columns).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/zi2-dispersion.txt.gz'</span>, sep=<span class="org-string">' '</span>, compression=<span class="org-string">'gzip'</span>)
pd.DataFrame(dropout.T, index=umi.index, columns=onehot.columns).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/zi2-dropout.txt.gz'</span>, sep=<span class="org-string">' '</span>, compression=<span class="org-string">'gzip'</span>)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org6ace9b3" class="outline-2">
<h2 id="org6ace9b3">numpy/scipy implementation</h2>
<div class="outline-text-2" id="text-org6ace9b3">
<p>
Optimize the negative log-likelihood.
</p>

<div class="org-src-container">
<pre class="src src-ipython" id="org9951dba"><span class="org-keyword">import</span> scipy.optimize <span class="org-keyword">as</span> so

<span class="org-keyword">def</span> <span class="org-function-name">log</span>(x):
  <span class="org-doc">"""Numerically safe log"""</span>
  <span class="org-keyword">return</span> np.log(x + 1e-8)

<span class="org-keyword">def</span> <span class="org-function-name">sigmoid</span>(x):
  <span class="org-doc">"""Numerically safe sigmoid"""</span>
  <span class="org-variable-name">lim</span> = np.log(np.finfo(np.float64).resolution)
  <span class="org-keyword">return</span> np.clip(sp.expit(x), lim, -lim)

<span class="org-keyword">def</span> <span class="org-function-name">zinb</span>(theta, x, size):
  <span class="org-variable-name">theta</span>, <span class="org-variable-name">dropout</span> = theta[:2], sigmoid(theta[2])
  <span class="org-variable-name">case_zero</span> = log(dropout + (1 - dropout) * np.exp(-nb(theta, x, size)))
  <span class="org-variable-name">case_non_zero</span> = log(1 - dropout) - nb(theta, x, size)
  <span class="org-keyword">return</span> -np.where(x &lt; 1e-8, case_zero, case_non_zero).mean()

<span class="org-keyword">def</span> <span class="org-function-name">nb</span>(theta, x, size):
  <span class="org-variable-name">mean</span>, <span class="org-variable-name">inv_disp</span> = np.exp(theta)
  <span class="org-variable-name">mean</span> *= size
  <span class="org-keyword">assert</span> mean.shape == x.shape
  <span class="org-keyword">return</span> -(x * log(mean / inv_disp) -
           x * log(1 + mean / inv_disp) -
           inv_disp * log(1 + mean / inv_disp) +
           sp.gammaln(x + inv_disp) -
           sp.gammaln(inv_disp) -
           sp.gammaln(x + 1)).mean()
</pre>
</div>

<p>
Write the data to the database. Use the pass through the count matrix to
compute and write out size factors for each cell.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">annotations</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-annotation.txt'</span>)
<span class="org-variable-name">keep_genes</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/genes-pass-filter.txt'</span>, index_col=0, header=<span class="org-constant">None</span>)
<span class="org-variable-name">keep_samples</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/quality-single-cells.txt'</span>, index_col=0, header=<span class="org-constant">None</span>)
<span class="org-variable-name">annotations</span> = annotations.loc[keep_samples.values.ravel()]
<span class="org-variable-name">annotations</span>[<span class="org-string">'sample'</span>] = annotation.<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: <span class="org-string">'{chip_id}.{experiment:08d}.{well}'</span>.<span class="org-builtin">format</span>(**<span class="org-builtin">dict</span>(x)), axis=1)
<span class="org-variable-name">annotations</span> = annotations.set_index(<span class="org-string">'sample'</span>)
<span class="org-variable-name">annotations</span>[<span class="org-string">'size'</span>] = np.zeros(annotations.shape[0])
<span class="org-keyword">with</span> sqlite3.connect(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/browser/browser.db'</span>) <span class="org-keyword">as</span> conn:
  conn.execute(<span class="org-string">'drop table if exists umi;'</span>)
  <span class="org-keyword">for</span> chunk <span class="org-keyword">in</span> pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-counts.txt.gz'</span>, index_col=0, chunksize=100):
    <span class="org-variable-name">chunk</span> = (chunk
             .<span class="org-builtin">filter</span>(items=keep_genes[keep_genes.values.ravel()].index, axis=<span class="org-string">'index'</span>)
             .loc[:,keep_samples.values.ravel()])
    <span class="org-keyword">if</span> <span class="org-keyword">not</span> chunk.empty:
      <span class="org-variable-name">annotations</span>[<span class="org-string">'size'</span>] += chunk.<span class="org-builtin">sum</span>(axis=0)
      chunk.reset_index().melt(id_vars=<span class="org-string">'gene'</span>, var_name=<span class="org-string">'sample'</span>).to_sql(name=<span class="org-string">'umi'</span>, con=conn, index=<span class="org-constant">False</span>, if_exists=<span class="org-string">'append'</span>)
  annotations[[<span class="org-string">'chip_id'</span>, <span class="org-string">'size'</span>]].to_sql(name=<span class="org-string">'annotation'</span>, con=conn, if_exists=<span class="org-string">'replace'</span>)
  conn.execute(<span class="org-string">'create index ix_umi on umi(gene, sample);'</span>)
</pre>
</div>

<p>
Use this to check the parameter estimation for a particular gene/individual.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">def</span> <span class="org-function-name">extract_data</span>(ind, gene):
  <span class="org-keyword">with</span> sqlite3.connect(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/browser/browser.db'</span>) <span class="org-keyword">as</span> conn:
    <span class="org-variable-name">umi</span> = pd.read_sql(<span class="org-string">"""select umi.value, annotation.size from umi, annotation </span>
<span class="org-string">    where annotation.chip_id == ? and gene == ? and </span>
<span class="org-string">    umi.sample == annotation.sample;"""</span>, con=conn, params=(ind, gene))
    <span class="org-keyword">return</span> umi
</pre>
</div>

<p>
Shard the data to parallelize over nodes. Doing this in one pass over the
count matrix is easier than doing this in one pass over the database table
because we don't have to worry about accidentally splitting up data for an
individual/gene pair across chunks.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">with</span> sqlite3.connect(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/browser/browser.db'</span>) <span class="org-keyword">as</span> conn:
  <span class="org-variable-name">annotation</span> = pd.read_sql(<span class="org-string">'select * from annotation'</span>, con=conn)

<span class="org-variable-name">keep_samples</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/quality-single-cells.txt'</span>, index_col=0, header=<span class="org-constant">None</span>)
<span class="org-variable-name">keep_genes</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/genes-pass-filter.txt'</span>, index_col=0, header=<span class="org-constant">None</span>)
<span class="org-variable-name">keep_genes</span> = keep_genes[keep_genes.values].index
<span class="org-variable-name">i</span> = 0
<span class="org-keyword">for</span> chunk <span class="org-keyword">in</span> pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-counts.txt.gz'</span>, index_col=0, chunksize=1000):
  <span class="org-keyword">print</span>(<span class="org-string">'Processing chunk {}'</span>.<span class="org-builtin">format</span>(i))
  <span class="org-variable-name">chunk</span> = (chunk
           .loc[:,keep_samples.values.ravel()]
           .<span class="org-builtin">filter</span>(items=keep_genes, axis=<span class="org-string">'index'</span>))
  <span class="org-keyword">if</span> <span class="org-keyword">not</span> chunk.empty:
    <span class="org-variable-name">chunk</span> = (chunk
             .reset_index()
             .melt(id_vars=<span class="org-string">'gene'</span>, var_name=<span class="org-string">'sample'</span>)
             .merge(annotation[[<span class="org-string">'chip_id'</span>, <span class="org-string">'sample'</span>, <span class="org-string">'size'</span>]], on=<span class="org-string">'sample'</span>)
             .sort_values([<span class="org-string">'gene'</span>, <span class="org-string">'chip_id'</span>, <span class="org-string">'sample'</span>]))
    chunk.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/density-estimation/chunk-{}.txt.gz'</span>.<span class="org-builtin">format</span>(i), columns=[<span class="org-string">'gene'</span>, <span class="org-string">'chip_id'</span>, <span class="org-string">'sample'</span>, <span class="org-string">'value'</span>, <span class="org-string">'size'</span>], compression=<span class="org-string">'gzip'</span>, sep=<span class="org-string">'\t'</span>)
    <span class="org-variable-name">i</span> += 1
</pre>
</div>

<p>
Process each chunk in parallel.
</p>

<div class="org-src-container">
<pre class="src src-ipython" id="orgbd92003"><span class="org-keyword">def</span> <span class="org-function-name">fit_gene</span>(chunk):
  <span class="org-variable-name">res0</span> = so.minimize(nb, x0=[0, 0], args=(chunk[:,0], chunk[:,1]))
  <span class="org-variable-name">pi0</span> = (chunk[:,0] == 0).<span class="org-builtin">sum</span>() / chunk.shape[0] + 1e-8
  <span class="org-variable-name">res</span> = so.minimize(zinb, x0=<span class="org-builtin">list</span>(res0.x) + [sp.logit(pi0 + 1e-8)], args=(chunk[:,0], chunk[:,1]))
  <span class="org-comment-delimiter"># </span><span class="org-comment">Log likelihood of ZINB vs. NB. We need to flip signs again</span>
  <span class="org-variable-name">llr</span> = chunk.shape[0] * (res0.fun - res.fun)
  <span class="org-keyword">return</span> <span class="org-builtin">list</span>(res0.x) + [res0.success] + <span class="org-builtin">list</span>(res.x) + [res.success, llr]

<span class="org-keyword">def</span> <span class="org-function-name">compute_breaks</span>(chunk, by_ind=<span class="org-constant">False</span>):
  <span class="org-comment-delimiter"># </span><span class="org-comment">Each subproblem has fixed size, so we can just split on integer indices</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">(instead of grouping)</span>
  <span class="org-variable-name">num_genes</span> = <span class="org-builtin">len</span>(<span class="org-builtin">set</span>(chunk[<span class="org-string">'gene'</span>]))
  <span class="org-variable-name">num_samples</span> = <span class="org-builtin">len</span>(<span class="org-builtin">set</span>(chunk[<span class="org-string">'sample'</span>]))
  <span class="org-variable-name">breaks</span> = num_samples * np.arange(num_genes).reshape(-1, 1)
  <span class="org-keyword">if</span> by_ind:
    <span class="org-variable-name">num_samples_per_ind</span> = chunk.iloc[:num_samples][<span class="org-string">'chip_id'</span>].value_counts().sort_index().values
    <span class="org-comment-delimiter"># </span><span class="org-comment">This can't be written += because of broadcasting</span>
    <span class="org-variable-name">breaks</span> = breaks + np.cumsum(num_samples_per_ind).reshape(1, -1)
  <span class="org-keyword">else</span>:
    <span class="org-comment-delimiter"># </span><span class="org-comment">We need to get the right end point of each subproblem (exclusive)</span>
    <span class="org-variable-name">breaks</span> += num_samples
  <span class="org-keyword">return</span> breaks.ravel()
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">&lt;&lt;zinb-imports&gt;&gt;
<span class="org-keyword">import</span> argparse
<span class="org-keyword">import</span> gzip
<span class="org-keyword">import</span> os
<span class="org-keyword">import</span> multiprocessing <span class="org-keyword">as</span> mp
<span class="org-keyword">import</span> sqlite3
&lt;&lt;np-zinb-impl&gt;&gt;
&lt;&lt;process-chunk-impl&gt;&gt;

<span class="org-keyword">with</span> mp.Pool() <span class="org-keyword">as</span> pool:
  <span class="org-variable-name">chunk</span> = pd.read_table(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/density-estimation/chunk-{}.txt.gz'</span>.<span class="org-builtin">format</span>(os.getenv(<span class="org-string">'SLURM_ARRAY_TASK_ID'</span>)))
  <span class="org-variable-name">breaks</span> = compute_breaks(chunk, by_ind=<span class="org-constant">True</span>)
  <span class="org-variable-name">res</span> = pool.<span class="org-builtin">map</span>(fit_gene, np.split(chunk[[<span class="org-string">'value'</span>, <span class="org-string">'size'</span>]].values, breaks[:-1]))

<span class="org-keyword">with</span> gzip.<span class="org-builtin">open</span>(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/density-estimation/result-{}.txt.gz'</span>.<span class="org-builtin">format</span>(os.getenv(<span class="org-string">'SLURM_ARRAY_TASK_ID'</span>)), <span class="org-string">'wt'</span>) <span class="org-keyword">as</span> f:
  <span class="org-keyword">for</span> b <span class="org-keyword">in</span> breaks:
    <span class="org-variable-name">gene</span>, <span class="org-variable-name">ind</span> = chunk.iloc[b - 1][[<span class="org-string">'gene'</span>, <span class="org-string">'chip_id'</span>]]
    <span class="org-keyword">print</span>(gene, ind, *res.pop(0), <span class="org-builtin">file</span>=f)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">sbatch --partition=broadwl --job-name=<span class="org-string">"np-zinb"</span> --mem=4G -a 0-20 -n1 -c28 --exclusive
<span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/bash</span>
<span class="org-builtin">source</span> activate scqtl
python /scratch/midway2/aksarkar/singlecell/np-zinb.py
</pre>
</div>

<p>
Populate the database.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">with</span> sqlite3.connect(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/browser/browser.db'</span>) <span class="org-keyword">as</span> conn:
  conn.execute(<span class="org-string">'drop table if exists params;'</span>)
  <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(20):
    <span class="org-keyword">for</span> chunk <span class="org-keyword">in</span> pd.read_table(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/density-estimation/result-{}.txt.gz'</span>.<span class="org-builtin">format</span>(i), sep=<span class="org-string">' '</span>, header=<span class="org-constant">None</span>, chunksize=1000):
      <span class="org-variable-name">chunk.columns</span> = [<span class="org-string">'gene'</span>, <span class="org-string">'ind'</span>, <span class="org-string">'nb_log_mean'</span>, <span class="org-string">'nb_log_disp'</span>, <span class="org-string">'nb_success'</span>, <span class="org-string">'zinb2_log_mean'</span>, <span class="org-string">'zinb2_log_disp'</span>, <span class="org-string">'zinb2_logodds'</span>, <span class="org-string">'zinb_success'</span>, <span class="org-string">'llr'</span>]
      chunk.to_sql(name=<span class="org-string">'params'</span>, con=conn, index=<span class="org-constant">False</span>, if_exists=<span class="org-string">'append'</span>)
  conn.execute(<span class="org-string">'create index ix_params on params(gene, ind);'</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgebc1920" class="outline-2">
<h2 id="orgebc1920">Genome-wide distribution of dispersion</h2>
<div class="outline-text-2" id="text-orgebc1920">
<p>
The index of dispersion for observed data \(r_{ijk}\) at gene \(k\) is:
</p>

<p>
\[ D_k = \frac{V[r_{ijk}]}{E[r_{ijk}]} \]
</p>

<p>
where expectations (variances) are taken over individuals \(i\) and cells
\(j\).
</p>

<p>
Let \(g_{ijk}\) denote the zero-inflated negative binomial density as defined
above. Then, we have:
</p>

<p>
\[ r_{ijk} \sim \sum_{ijk} \frac{1}{N} g_{ijk}(\cdot) \]
</p>

<p>
Fixing gene \(k\), the mixture density has expectation:
</p>

<p>
\[ \mu_k = \frac{1}{N} \sum_{ijk} E_{g_{ijk}}[r_{ijk}] \]
</p>

<p>
and variance (<a href="http://www.springer.com/us/book/9780387329093">Frühwirth-Schnatter 2006</a>):
</p>

<p>
\[ \sigma^2_k = \frac{1}{N} \sum (E_{g_{ijk}}[r_{ijk}] - \mu)^2 + V_{g_{ijk}}
  [r_{ijk}] \]
</p>

<p>
Fixing individual \(i\) and cell \(j\), we have:
</p>

<p>
\[ E[r_{ijk}] = (1 - \pi_{ik}) R_{ij} \mu_{ik} \]
</p>

<p>
\[ V[r_[ijk]] = (1 - \pi_{ik}) \left(R_{ij} \mu_{ik} + (R_{ij} \mu_{ik})^2 \phi_{ik}\right) \]
</p>

<p>
Read the estimated parameters, throwing out individuals with fewer than 50
cells.
</p>

<p>
Compute the index of dispersion as described above. Use the sharded results
to parallelize. <b>Important: we parameterized in terms of inverse dispersion,
so we need to flip signs here.</b>
</p>

<div class="org-src-container">
<pre class="src src-ipython">
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">&lt;&lt;zinb-imports&gt;&gt;
<span class="org-keyword">import</span> multiprocessing <span class="org-keyword">as</span> mp
<span class="org-keyword">import</span> sqlite3

<span class="org-keyword">def</span> <span class="org-function-name">process_gene</span>(chunk):
  <span class="org-keyword">global</span> annotation
  gene, ind, *<span class="org-variable-name">_</span> = chunk.iloc[0]
  <span class="org-keyword">if</span> ind <span class="org-keyword">in</span> annotation[<span class="org-string">'chip_id'</span>]:
    <span class="org-variable-name">exp_value</span> = annotation[annotation[<span class="org-string">'chip_id'</span>] == ind][<span class="org-string">'size'</span>] * np.exp(chunk[<span class="org-string">'log_mean'</span>])
    <span class="org-variable-name">var</span> = exp_value + exp_value * exp_value * np.exp(-g[<span class="org-string">'log_disp'</span>])
    <span class="org-variable-name">gene_mean</span> = exp_value.mean()
    <span class="org-variable-name">gene_var</span> = (np.square(exp_value - gene_mean) + var).mean()
    <span class="org-keyword">return</span>
  <span class="org-keyword">else</span>:
    <span class="org-keyword">return</span> {}

<span class="org-keyword">with</span> mp.Pool() <span class="org-keyword">as</span> pool:
  <span class="org-keyword">with</span> sqlite3.connect(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/browser/browser.db'</span>) <span class="org-keyword">as</span> conn:
    <span class="org-variable-name">annotation</span> = pd.read_sql(<span class="org-string">'select * from annotation group by chip_id having count(distinct sample) &gt;= 50;'</span>, conn)
  <span class="org-variable-name">chunk</span> = pd.read_table(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/density-estimation/result-{}.txt.gz'</span>.<span class="org-builtin">format</span>(os.getenv(<span class="org-string">'SLURM_ARRAY_TASK_ID'</span>)), header=<span class="org-constant">None</span>)
  <span class="org-variable-name">chunk.columns</span> = [<span class="org-string">'gene'</span>, <span class="org-string">'ind'</span>, <span class="org-string">'nb_log_mean'</span>, <span class="org-string">'nb_log_disp'</span>, <span class="org-string">'nb_success'</span>, <span class="org-string">'zinb2_log_mean'</span>, <span class="org-string">'zinb2_log_disp'</span>, <span class="org-string">'zinb2_logodds'</span>, <span class="org-string">'zinb2_success'</span>, <span class="org-string">'llr'</span>]
  <span class="org-variable-name">chunk</span>[<span class="org-string">'log_mean'</span>] = np.where(chunk[<span class="org-string">'llr'</span>] &lt; 1, chunk[<span class="org-string">'nb_log_mean'</span>], chunk[<span class="org-string">'zinb2_log_mean'</span>])
  <span class="org-variable-name">chunk</span>[<span class="org-string">'log_disp'</span>] = np.where(chunk[<span class="org-string">'llr'</span>] &lt; 1, chunk[<span class="org-string">'nb_log_disp'</span>], chunk[<span class="org-string">'zinb2_log_disp'</span>])
  <span class="org-comment-delimiter"># </span><span class="org-comment">Subproblems have fixed size</span>
  <span class="org-variable-name">num_genes</span> = <span class="org-builtin">len</span>(<span class="org-builtin">set</span>(chunk[<span class="org-string">'gene'</span>]))
  <span class="org-variable-name">num_inds</span> = <span class="org-builtin">len</span>(<span class="org-builtin">set</span>(chunk[<span class="org-string">'chip_id'</span>]))
  <span class="org-comment-delimiter"># </span><span class="org-comment">Get the right endpoints (exclusive)</span>
  <span class="org-variable-name">breaks</span> = num_inds * np.arange(1, num_genes + 1)
  <span class="org-variable-name">res</span> = pd.DataFrame.from_dict(pool.<span class="org-builtin">map</span>(process_gene, np.split(chunk[[<span class="org-string">'gene'</span>, <span class="org-string">'ind'</span>, <span class="org-string">'log_mean'</span>, <span class="org-string">'log_disp'</span>]].values, breaks[:-1])))
  res.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/density-estimation/dispersion-index-{}.txt.gz'</span>.<span class="org-builtin">format</span>(os.getenv(<span class="org-string">'SLURM_ARRAY_TASK_ID'</span>)), compression=<span class="org-string">'gzip'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">sbatch --partition=broadwl --job-name=<span class="org-string">"np-zinb"</span> --mem=4G -a 0-20 -n1 -c28 --exclusive
<span class="org-comment-delimiter">#</span><span class="org-comment">!/bin/bash</span>
<span class="org-builtin">source</span> activate scqtl
python /scratch/midway2/aksarkar/singlecell/np-zinb.py
</pre>
</div>

<p>
Plot the distribution of dispersions.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.hist(dispersion[np.isfinite(dispersion)], bins=50, color=<span class="org-string">'k'</span>)
plt.xlabel(<span class="org-string">'Index of dispersion'</span>)
<span class="org-variable-name">_</span> = plt.ylabel(<span class="org-string">'Number of genes'</span>)
</pre>
</div>


<div class="figure">
<p><img src="figure/zinb.org/global-dispersion-hist.png" alt="global-dispersion-hist.png">
</p>
</div>

<p>
Write out the computed dispersions.
</p>

<div class="org-src-container">
<pre class="src src-ipython">dispersion[np.isfinite(dispersion)].to_frame().to_csv(<span class="org-string">'/scratch/midway2/aksarkar/singlecell/index-dispersion-by-gene.txt.gz'</span>, compression=<span class="org-string">'gzip'</span>, header=<span class="org-constant">False</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Abhishek Sarkar</p>
<p class="date">Created: 2018-03-19 Mon 14:54</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
